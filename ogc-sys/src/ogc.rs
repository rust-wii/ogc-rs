/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.4.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const NULL: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 3412;
pub const BIG_ENDIAN: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const DSPTASK_INIT: u32 = 0;
pub const DSPTASK_RUN: u32 = 1;
pub const DSPTASK_YIELD: u32 = 2;
pub const DSPTASK_DONE: u32 = 3;
pub const DSPTASK_CLEARALL: u32 = 0;
pub const DSPTASK_ATTACH: u32 = 1;
pub const DSPTASK_CANCEL: u32 = 2;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const AR_MRAMTOARAM: u32 = 0;
pub const AR_ARAMTOMRAM: u32 = 1;
pub const AR_ARAMINTALL: u32 = 0;
pub const AR_ARAMINTUSER: u32 = 1;
pub const ARQ_MRAMTOARAM: u32 = 0;
pub const ARQ_ARAMTOMRAM: u32 = 1;
pub const ARQ_DEF_CHUNK_SIZE: u32 = 4096;
pub const ARQ_PRIO_LO: u32 = 0;
pub const ARQ_PRIO_HI: u32 = 1;
pub const AI_STREAM_STOP: u32 = 0;
pub const AI_STREAM_START: u32 = 1;
pub const AI_SAMPLERATE_32KHZ: u32 = 0;
pub const AI_SAMPLERATE_48KHZ: u32 = 1;
pub const LC_BASEPREFIX: u32 = 57344;
pub const LC_BASE: u32 = 3758096384;
pub const CARD_SLOTA: u32 = 0;
pub const CARD_SLOTB: u32 = 1;
pub const CARD_WORKAREA_SIZE: u32 = 40960;
pub const CARD_READSIZE: u32 = 512;
pub const CARD_FILENAMELEN: u32 = 32;
pub const CARD_MAXFILES: u32 = 127;
pub const CARD_ERROR_UNLOCKED: u32 = 1;
pub const CARD_ERROR_READY: u32 = 0;
pub const CARD_ERROR_BUSY: i32 = -1;
pub const CARD_ERROR_WRONGDEVICE: i32 = -2;
pub const CARD_ERROR_NOCARD: i32 = -3;
pub const CARD_ERROR_NOFILE: i32 = -4;
pub const CARD_ERROR_IOERROR: i32 = -5;
pub const CARD_ERROR_BROKEN: i32 = -6;
pub const CARD_ERROR_EXIST: i32 = -7;
pub const CARD_ERROR_NOENT: i32 = -8;
pub const CARD_ERROR_INSSPACE: i32 = -9;
pub const CARD_ERROR_NOPERM: i32 = -10;
pub const CARD_ERROR_LIMIT: i32 = -11;
pub const CARD_ERROR_NAMETOOLONG: i32 = -12;
pub const CARD_ERROR_ENCODING: i32 = -13;
pub const CARD_ERROR_CANCELED: i32 = -14;
pub const CARD_ERROR_FATAL_ERROR: i32 = -128;
pub const CARD_ATTRIB_PUBLIC: u32 = 4;
pub const CARD_ATTRIB_NOCOPY: u32 = 8;
pub const CARD_ATTRIB_NOMOVE: u32 = 16;
pub const CARD_BANNER_W: u32 = 96;
pub const CARD_BANNER_H: u32 = 32;
pub const CARD_BANNER_NONE: u32 = 0;
pub const CARD_BANNER_CI: u32 = 1;
pub const CARD_BANNER_RGB: u32 = 2;
pub const CARD_BANNER_MASK: u32 = 3;
pub const CARD_MAXICONS: u32 = 8;
pub const CARD_ICON_W: u32 = 32;
pub const CARD_ICON_H: u32 = 32;
pub const CARD_ICON_NONE: u32 = 0;
pub const CARD_ICON_CI: u32 = 1;
pub const CARD_ICON_RGB: u32 = 2;
pub const CARD_ICON_MASK: u32 = 3;
pub const CARD_ANIM_LOOP: u32 = 0;
pub const CARD_ANIM_BOUNCE: u32 = 4;
pub const CARD_ANIM_MASK: u32 = 4;
pub const CARD_SPEED_END: u32 = 0;
pub const CARD_SPEED_FAST: u32 = 1;
pub const CARD_SPEED_MIDDLE: u32 = 2;
pub const CARD_SPEED_SLOW: u32 = 3;
pub const CARD_SPEED_MASK: u32 = 3;
pub const GQR2: u32 = 914;
pub const GQR3: u32 = 915;
pub const GQR4: u32 = 916;
pub const GQR5: u32 = 917;
pub const GQR6: u32 = 918;
pub const GQR7: u32 = 919;
pub const GQR_TYPE_F32: u32 = 0;
pub const GQR_TYPE_U8: u32 = 4;
pub const GQR_TYPE_U16: u32 = 5;
pub const GQR_TYPE_S8: u32 = 6;
pub const GQR_TYPE_S16: u32 = 7;
pub const GQR_CAST_U8: u32 = 2;
pub const GQR_CAST_U16: u32 = 3;
pub const GQR_CAST_S8: u32 = 4;
pub const GQR_CAST_S16: u32 = 5;
pub const COLOR_BLACK: u32 = 276828288;
pub const COLOR_MAROON: u32 = 829239736;
pub const COLOR_GREEN: u32 = 1364939089;
pub const COLOR_OLIVE: u32 = 1900573065;
pub const COLOR_NAVY: u32 = 498605431;
pub const COLOR_PURPLE: u32 = 1034239407;
pub const COLOR_TEAL: u32 = 1569938760;
pub const COLOR_GRAY: u32 = 2122350208;
pub const COLOR_SILVER: u32 = 3045111168;
pub const COLOR_RED: u32 = 1364873712;
pub const COLOR_LIME: u32 = 2436272418;
pub const COLOR_YELLOW: u32 = 3524317842;
pub const COLOR_BLUE: u32 = 703605102;
pub const COLOR_FUCHSIA: u32 = 1791650526;
pub const COLOR_AQUA: u32 = 2863049232;
pub const COLOR_WHITE: u32 = 3951094656;
pub const COLOR_MONEYGREEN: u32 = 3279471478;
pub const COLOR_SKYBLUE: u32 = 3096885357;
pub const COLOR_CREAM: u32 = 3900434563;
pub const COLOR_MEDGRAY: u32 = 2592250496;
pub const FEATURE_MEDIUM_CANREAD: u32 = 1;
pub const FEATURE_MEDIUM_CANWRITE: u32 = 2;
pub const FEATURE_GAMECUBE_SLOTA: u32 = 16;
pub const FEATURE_GAMECUBE_SLOTB: u32 = 32;
pub const FEATURE_GAMECUBE_DVD: u32 = 64;
pub const FEATURE_GAMECUBE_PORT2: u32 = 128;
pub const FEATURE_WII_SD: u32 = 256;
pub const FEATURE_WII_USB: u32 = 512;
pub const FEATURE_WII_DVD: u32 = 1024;
pub const DVD_STATE_FATAL_ERROR: i32 = -1;
pub const DVD_STATE_END: u32 = 0;
pub const DVD_STATE_BUSY: u32 = 1;
pub const DVD_STATE_WAITING: u32 = 2;
pub const DVD_STATE_COVER_CLOSED: u32 = 3;
pub const DVD_STATE_NO_DISK: u32 = 4;
pub const DVD_STATE_COVER_OPEN: u32 = 5;
pub const DVD_STATE_WRONG_DISK: u32 = 6;
pub const DVD_STATE_MOTOR_STOPPED: u32 = 7;
pub const DVD_STATE_IGNORED: u32 = 8;
pub const DVD_STATE_CANCELED: u32 = 10;
pub const DVD_STATE_RETRY: u32 = 11;
pub const DVD_ERROR_OK: u32 = 0;
pub const DVD_ERROR_FATAL: i32 = -1;
pub const DVD_ERROR_IGNORED: i32 = -2;
pub const DVD_ERROR_CANCELED: i32 = -3;
pub const DVD_ERROR_COVER_CLOSED: i32 = -4;
pub const DVD_RESETHARD: u32 = 0;
pub const DVD_RESETSOFT: u32 = 1;
pub const DVD_RESETNONE: u32 = 2;
pub const DVD_SPINMOTOR_DOWN: u32 = 0;
pub const DVD_SPINMOTOR_UP: u32 = 256;
pub const DVD_SPINMOTOR_ACCEPT: u32 = 16384;
pub const DVD_SPINMOTOR_CHECKDISK: u32 = 32768;
pub const EXI_READ: u32 = 0;
pub const EXI_WRITE: u32 = 1;
pub const EXI_READWRITE: u32 = 2;
pub const EXI_CHANNEL_0: u32 = 0;
pub const EXI_CHANNEL_1: u32 = 1;
pub const EXI_CHANNEL_2: u32 = 2;
pub const EXI_CHANNEL_MAX: u32 = 3;
pub const EXI_DEVICE_0: u32 = 0;
pub const EXI_DEVICE_1: u32 = 1;
pub const EXI_DEVICE_2: u32 = 2;
pub const EXI_DEVICE_MAX: u32 = 3;
pub const EXI_SPEED1MHZ: u32 = 0;
pub const EXI_SPEED2MHZ: u32 = 1;
pub const EXI_SPEED4MHZ: u32 = 2;
pub const EXI_SPEED8MHZ: u32 = 3;
pub const EXI_SPEED16MHZ: u32 = 4;
pub const EXI_SPEED32MHZ: u32 = 5;
pub const EXI_FLAG_DMA: u32 = 1;
pub const EXI_FLAG_IMM: u32 = 2;
pub const EXI_FLAG_SELECT: u32 = 4;
pub const EXI_FLAG_ATTACH: u32 = 8;
pub const EXI_FLAG_LOCKED: u32 = 16;
pub const EXI_MEMCARD59: u32 = 4;
pub const EXI_MEMCARD123: u32 = 8;
pub const EXI_MEMCARD251: u32 = 16;
pub const EXI_MEMCARD507: u32 = 32;
pub const EXI_MEMCARD1019: u32 = 64;
pub const EXI_MEMCARD2043: u32 = 128;
pub const M_PI: f64 = 3.141592653589793;
pub const M_DTOR: f64 = 0.017453292519943295;
pub const LWP_CLOSED: i32 = -1;
pub const LWP_SUCCESSFUL: u32 = 0;
pub const LWP_ALREADY_SUSPENDED: u32 = 1;
pub const LWP_NOT_SUSPENDED: u32 = 2;
pub const LWP_PRIO_IDLE: u32 = 0;
pub const LWP_PRIO_HIGHEST: u32 = 127;
pub const LWP_THREAD_NULL: u32 = 4294967295;
pub const LWP_TQUEUE_NULL: u32 = 4294967295;
pub const GX_FALSE: u32 = 0;
pub const GX_TRUE: u32 = 1;
pub const GX_DISABLE: u32 = 0;
pub const GX_ENABLE: u32 = 1;
pub const GX_CLIP_DISABLE: u32 = 1;
pub const GX_CLIP_ENABLE: u32 = 0;
pub const GX_FIFO_MINSIZE: u32 = 65536;
pub const GX_FIFO_HIWATERMARK: u32 = 16384;
pub const GX_FIFO_OBJSIZE: u32 = 128;
pub const GX_PERSPECTIVE: u32 = 0;
pub const GX_ORTHOGRAPHIC: u32 = 1;
pub const GX_MT_NULL: u32 = 0;
pub const GX_MT_XF_FLUSH: u32 = 1;
pub const GX_MT_DL_SAVE_CTX: u32 = 2;
pub const GX_XF_FLUSH_NONE: u32 = 0;
pub const GX_XF_FLUSH_SAFE: u32 = 1;
pub const GX_COLOR0: u32 = 0;
pub const GX_COLOR1: u32 = 1;
pub const GX_ALPHA0: u32 = 2;
pub const GX_ALPHA1: u32 = 3;
pub const GX_COLOR0A0: u32 = 4;
pub const GX_COLOR1A1: u32 = 5;
pub const GX_COLORZERO: u32 = 6;
pub const GX_ALPHA_BUMP: u32 = 7;
pub const GX_ALPHA_BUMPN: u32 = 8;
pub const GX_COLORNULL: u32 = 255;
pub const GX_MTX3x4: u32 = 0;
pub const GX_MTX2x4: u32 = 1;
pub const GX_VTXFMT0: u32 = 0;
pub const GX_VTXFMT1: u32 = 1;
pub const GX_VTXFMT2: u32 = 2;
pub const GX_VTXFMT3: u32 = 3;
pub const GX_VTXFMT4: u32 = 4;
pub const GX_VTXFMT5: u32 = 5;
pub const GX_VTXFMT6: u32 = 6;
pub const GX_VTXFMT7: u32 = 7;
pub const GX_MAXVTXFMT: u32 = 8;
pub const GX_NONE: u32 = 0;
pub const GX_DIRECT: u32 = 1;
pub const GX_INDEX8: u32 = 2;
pub const GX_INDEX16: u32 = 3;
pub const GX_U8: u32 = 0;
pub const GX_S8: u32 = 1;
pub const GX_U16: u32 = 2;
pub const GX_S16: u32 = 3;
pub const GX_F32: u32 = 4;
pub const GX_RGB565: u32 = 0;
pub const GX_RGB8: u32 = 1;
pub const GX_RGBX8: u32 = 2;
pub const GX_RGBA4: u32 = 3;
pub const GX_RGBA6: u32 = 4;
pub const GX_RGBA8: u32 = 5;
pub const GX_POS_XY: u32 = 0;
pub const GX_POS_XYZ: u32 = 1;
pub const GX_NRM_XYZ: u32 = 0;
pub const GX_NRM_NBT: u32 = 1;
pub const GX_NRM_NBT3: u32 = 2;
pub const GX_CLR_RGB: u32 = 0;
pub const GX_CLR_RGBA: u32 = 1;
pub const GX_TEX_S: u32 = 0;
pub const GX_TEX_ST: u32 = 1;
pub const GX_VA_PTNMTXIDX: u32 = 0;
pub const GX_VA_TEX0MTXIDX: u32 = 1;
pub const GX_VA_TEX1MTXIDX: u32 = 2;
pub const GX_VA_TEX2MTXIDX: u32 = 3;
pub const GX_VA_TEX3MTXIDX: u32 = 4;
pub const GX_VA_TEX4MTXIDX: u32 = 5;
pub const GX_VA_TEX5MTXIDX: u32 = 6;
pub const GX_VA_TEX6MTXIDX: u32 = 7;
pub const GX_VA_TEX7MTXIDX: u32 = 8;
pub const GX_VA_POS: u32 = 9;
pub const GX_VA_NRM: u32 = 10;
pub const GX_VA_CLR0: u32 = 11;
pub const GX_VA_CLR1: u32 = 12;
pub const GX_VA_TEX0: u32 = 13;
pub const GX_VA_TEX1: u32 = 14;
pub const GX_VA_TEX2: u32 = 15;
pub const GX_VA_TEX3: u32 = 16;
pub const GX_VA_TEX4: u32 = 17;
pub const GX_VA_TEX5: u32 = 18;
pub const GX_VA_TEX6: u32 = 19;
pub const GX_VA_TEX7: u32 = 20;
pub const GX_POSMTXARRAY: u32 = 21;
pub const GX_NRMMTXARRAY: u32 = 22;
pub const GX_TEXMTXARRAY: u32 = 23;
pub const GX_LIGHTARRAY: u32 = 24;
pub const GX_VA_NBT: u32 = 25;
pub const GX_VA_MAXATTR: u32 = 26;
pub const GX_VA_NULL: u32 = 255;
pub const GX_POINTS: u32 = 184;
pub const GX_LINES: u32 = 168;
pub const GX_LINESTRIP: u32 = 176;
pub const GX_TRIANGLES: u32 = 144;
pub const GX_TRIANGLESTRIP: u32 = 152;
pub const GX_TRIANGLEFAN: u32 = 160;
pub const GX_QUADS: u32 = 128;
pub const GX_SRC_REG: u32 = 0;
pub const GX_SRC_VTX: u32 = 1;
pub const GX_LIGHT0: u32 = 1;
pub const GX_LIGHT1: u32 = 2;
pub const GX_LIGHT2: u32 = 4;
pub const GX_LIGHT3: u32 = 8;
pub const GX_LIGHT4: u32 = 16;
pub const GX_LIGHT5: u32 = 32;
pub const GX_LIGHT6: u32 = 64;
pub const GX_LIGHT7: u32 = 128;
pub const GX_MAXLIGHT: u32 = 256;
pub const GX_LIGHTNULL: u32 = 0;
pub const GX_DF_NONE: u32 = 0;
pub const GX_DF_SIGNED: u32 = 1;
pub const GX_DF_CLAMP: u32 = 2;
pub const GX_AF_SPEC: u32 = 0;
pub const GX_AF_SPOT: u32 = 1;
pub const GX_AF_NONE: u32 = 2;
pub const GX_PNMTX0: u32 = 0;
pub const GX_PNMTX1: u32 = 3;
pub const GX_PNMTX2: u32 = 6;
pub const GX_PNMTX3: u32 = 9;
pub const GX_PNMTX4: u32 = 12;
pub const GX_PNMTX5: u32 = 15;
pub const GX_PNMTX6: u32 = 18;
pub const GX_PNMTX7: u32 = 21;
pub const GX_PNMTX8: u32 = 24;
pub const GX_PNMTX9: u32 = 27;
pub const GX_TEXMTX0: u32 = 30;
pub const GX_TEXMTX1: u32 = 33;
pub const GX_TEXMTX2: u32 = 36;
pub const GX_TEXMTX3: u32 = 39;
pub const GX_TEXMTX4: u32 = 42;
pub const GX_TEXMTX5: u32 = 45;
pub const GX_TEXMTX6: u32 = 48;
pub const GX_TEXMTX7: u32 = 51;
pub const GX_TEXMTX8: u32 = 54;
pub const GX_TEXMTX9: u32 = 57;
pub const GX_IDENTITY: u32 = 60;
pub const GX_DTTMTX0: u32 = 64;
pub const GX_DTTMTX1: u32 = 67;
pub const GX_DTTMTX2: u32 = 70;
pub const GX_DTTMTX3: u32 = 73;
pub const GX_DTTMTX4: u32 = 76;
pub const GX_DTTMTX5: u32 = 79;
pub const GX_DTTMTX6: u32 = 82;
pub const GX_DTTMTX7: u32 = 85;
pub const GX_DTTMTX8: u32 = 88;
pub const GX_DTTMTX9: u32 = 91;
pub const GX_DTTMTX10: u32 = 94;
pub const GX_DTTMTX11: u32 = 97;
pub const GX_DTTMTX12: u32 = 100;
pub const GX_DTTMTX13: u32 = 103;
pub const GX_DTTMTX14: u32 = 106;
pub const GX_DTTMTX15: u32 = 109;
pub const GX_DTTMTX16: u32 = 112;
pub const GX_DTTMTX17: u32 = 115;
pub const GX_DTTMTX18: u32 = 118;
pub const GX_DTTMTX19: u32 = 121;
pub const GX_DTTIDENTITY: u32 = 125;
pub const GX_TEXCOORD0: u32 = 0;
pub const GX_TEXCOORD1: u32 = 1;
pub const GX_TEXCOORD2: u32 = 2;
pub const GX_TEXCOORD3: u32 = 3;
pub const GX_TEXCOORD4: u32 = 4;
pub const GX_TEXCOORD5: u32 = 5;
pub const GX_TEXCOORD6: u32 = 6;
pub const GX_TEXCOORD7: u32 = 7;
pub const GX_MAXCOORD: u32 = 8;
pub const GX_TEXCOORDNULL: u32 = 255;
pub const _GX_TF_ZTF: u32 = 16;
pub const _GX_TF_CTF: u32 = 32;
pub const GX_TF_I4: u32 = 0;
pub const GX_TF_I8: u32 = 1;
pub const GX_TF_IA4: u32 = 2;
pub const GX_TF_IA8: u32 = 3;
pub const GX_TF_RGB565: u32 = 4;
pub const GX_TF_RGB5A3: u32 = 5;
pub const GX_TF_RGBA8: u32 = 6;
pub const GX_TF_CI4: u32 = 8;
pub const GX_TF_CI8: u32 = 9;
pub const GX_TF_CI14: u32 = 10;
pub const GX_TF_CMPR: u32 = 14;
pub const GX_TL_IA8: u32 = 0;
pub const GX_TL_RGB565: u32 = 1;
pub const GX_TL_RGB5A3: u32 = 2;
pub const GX_CTF_R4: u32 = 32;
pub const GX_CTF_RA4: u32 = 34;
pub const GX_CTF_RA8: u32 = 35;
pub const GX_CTF_YUVA8: u32 = 38;
pub const GX_CTF_A8: u32 = 39;
pub const GX_CTF_R8: u32 = 40;
pub const GX_CTF_G8: u32 = 41;
pub const GX_CTF_B8: u32 = 42;
pub const GX_CTF_RG8: u32 = 43;
pub const GX_CTF_GB8: u32 = 44;
pub const GX_TF_Z8: u32 = 17;
pub const GX_TF_Z16: u32 = 19;
pub const GX_TF_Z24X8: u32 = 22;
pub const GX_CTF_Z4: u32 = 48;
pub const GX_CTF_Z8M: u32 = 57;
pub const GX_CTF_Z8L: u32 = 58;
pub const GX_CTF_Z16L: u32 = 60;
pub const GX_TF_A8: u32 = 39;
pub const GX_TLUT_16: u32 = 1;
pub const GX_TLUT_32: u32 = 2;
pub const GX_TLUT_64: u32 = 4;
pub const GX_TLUT_128: u32 = 8;
pub const GX_TLUT_256: u32 = 16;
pub const GX_TLUT_512: u32 = 32;
pub const GX_TLUT_1K: u32 = 64;
pub const GX_TLUT_2K: u32 = 128;
pub const GX_TLUT_4K: u32 = 256;
pub const GX_TLUT_8K: u32 = 512;
pub const GX_TLUT_16K: u32 = 1024;
pub const GX_ZT_DISABLE: u32 = 0;
pub const GX_ZT_ADD: u32 = 1;
pub const GX_ZT_REPLACE: u32 = 2;
pub const GX_MAX_ZTEXOP: u32 = 3;
pub const GX_TG_MTX3x4: u32 = 0;
pub const GX_TG_MTX2x4: u32 = 1;
pub const GX_TG_BUMP0: u32 = 2;
pub const GX_TG_BUMP1: u32 = 3;
pub const GX_TG_BUMP2: u32 = 4;
pub const GX_TG_BUMP3: u32 = 5;
pub const GX_TG_BUMP4: u32 = 6;
pub const GX_TG_BUMP5: u32 = 7;
pub const GX_TG_BUMP6: u32 = 8;
pub const GX_TG_BUMP7: u32 = 9;
pub const GX_TG_SRTG: u32 = 10;
pub const GX_TG_POS: u32 = 0;
pub const GX_TG_NRM: u32 = 1;
pub const GX_TG_BINRM: u32 = 2;
pub const GX_TG_TANGENT: u32 = 3;
pub const GX_TG_TEX0: u32 = 4;
pub const GX_TG_TEX1: u32 = 5;
pub const GX_TG_TEX2: u32 = 6;
pub const GX_TG_TEX3: u32 = 7;
pub const GX_TG_TEX4: u32 = 8;
pub const GX_TG_TEX5: u32 = 9;
pub const GX_TG_TEX6: u32 = 10;
pub const GX_TG_TEX7: u32 = 11;
pub const GX_TG_TEXCOORD0: u32 = 12;
pub const GX_TG_TEXCOORD1: u32 = 13;
pub const GX_TG_TEXCOORD2: u32 = 14;
pub const GX_TG_TEXCOORD3: u32 = 15;
pub const GX_TG_TEXCOORD4: u32 = 16;
pub const GX_TG_TEXCOORD5: u32 = 17;
pub const GX_TG_TEXCOORD6: u32 = 18;
pub const GX_TG_COLOR0: u32 = 19;
pub const GX_TG_COLOR1: u32 = 20;
pub const GX_NEVER: u32 = 0;
pub const GX_LESS: u32 = 1;
pub const GX_EQUAL: u32 = 2;
pub const GX_LEQUAL: u32 = 3;
pub const GX_GREATER: u32 = 4;
pub const GX_NEQUAL: u32 = 5;
pub const GX_GEQUAL: u32 = 6;
pub const GX_ALWAYS: u32 = 7;
pub const GX_CLAMP: u32 = 0;
pub const GX_REPEAT: u32 = 1;
pub const GX_MIRROR: u32 = 2;
pub const GX_MAXTEXWRAPMODE: u32 = 3;
pub const GX_BM_NONE: u32 = 0;
pub const GX_BM_BLEND: u32 = 1;
pub const GX_BM_LOGIC: u32 = 2;
pub const GX_BM_SUBTRACT: u32 = 3;
pub const GX_MAX_BLENDMODE: u32 = 4;
pub const GX_BL_ZERO: u32 = 0;
pub const GX_BL_ONE: u32 = 1;
pub const GX_BL_SRCCLR: u32 = 2;
pub const GX_BL_INVSRCCLR: u32 = 3;
pub const GX_BL_SRCALPHA: u32 = 4;
pub const GX_BL_INVSRCALPHA: u32 = 5;
pub const GX_BL_DSTALPHA: u32 = 6;
pub const GX_BL_INVDSTALPHA: u32 = 7;
pub const GX_BL_DSTCLR: u32 = 2;
pub const GX_BL_INVDSTCLR: u32 = 3;
pub const GX_LO_CLEAR: u32 = 0;
pub const GX_LO_AND: u32 = 1;
pub const GX_LO_REVAND: u32 = 2;
pub const GX_LO_COPY: u32 = 3;
pub const GX_LO_INVAND: u32 = 4;
pub const GX_LO_NOOP: u32 = 5;
pub const GX_LO_XOR: u32 = 6;
pub const GX_LO_OR: u32 = 7;
pub const GX_LO_NOR: u32 = 8;
pub const GX_LO_EQUIV: u32 = 9;
pub const GX_LO_INV: u32 = 10;
pub const GX_LO_REVOR: u32 = 11;
pub const GX_LO_INVCOPY: u32 = 12;
pub const GX_LO_INVOR: u32 = 13;
pub const GX_LO_NAND: u32 = 14;
pub const GX_LO_SET: u32 = 15;
pub const GX_TO_ZERO: u32 = 0;
pub const GX_TO_SIXTEENTH: u32 = 1;
pub const GX_TO_EIGHTH: u32 = 2;
pub const GX_TO_FOURTH: u32 = 3;
pub const GX_TO_HALF: u32 = 4;
pub const GX_TO_ONE: u32 = 5;
pub const GX_MAX_TEXOFFSET: u32 = 6;
pub const GX_MODULATE: u32 = 0;
pub const GX_DECAL: u32 = 1;
pub const GX_BLEND: u32 = 2;
pub const GX_REPLACE: u32 = 3;
pub const GX_PASSCLR: u32 = 4;
pub const GX_CC_CPREV: u32 = 0;
pub const GX_CC_APREV: u32 = 1;
pub const GX_CC_C0: u32 = 2;
pub const GX_CC_A0: u32 = 3;
pub const GX_CC_C1: u32 = 4;
pub const GX_CC_A1: u32 = 5;
pub const GX_CC_C2: u32 = 6;
pub const GX_CC_A2: u32 = 7;
pub const GX_CC_TEXC: u32 = 8;
pub const GX_CC_TEXA: u32 = 9;
pub const GX_CC_RASC: u32 = 10;
pub const GX_CC_RASA: u32 = 11;
pub const GX_CC_ONE: u32 = 12;
pub const GX_CC_HALF: u32 = 13;
pub const GX_CC_KONST: u32 = 14;
pub const GX_CC_ZERO: u32 = 15;
pub const GX_CA_APREV: u32 = 0;
pub const GX_CA_A0: u32 = 1;
pub const GX_CA_A1: u32 = 2;
pub const GX_CA_A2: u32 = 3;
pub const GX_CA_TEXA: u32 = 4;
pub const GX_CA_RASA: u32 = 5;
pub const GX_CA_KONST: u32 = 6;
pub const GX_CA_ZERO: u32 = 7;
pub const GX_TEVSTAGE0: u32 = 0;
pub const GX_TEVSTAGE1: u32 = 1;
pub const GX_TEVSTAGE2: u32 = 2;
pub const GX_TEVSTAGE3: u32 = 3;
pub const GX_TEVSTAGE4: u32 = 4;
pub const GX_TEVSTAGE5: u32 = 5;
pub const GX_TEVSTAGE6: u32 = 6;
pub const GX_TEVSTAGE7: u32 = 7;
pub const GX_TEVSTAGE8: u32 = 8;
pub const GX_TEVSTAGE9: u32 = 9;
pub const GX_TEVSTAGE10: u32 = 10;
pub const GX_TEVSTAGE11: u32 = 11;
pub const GX_TEVSTAGE12: u32 = 12;
pub const GX_TEVSTAGE13: u32 = 13;
pub const GX_TEVSTAGE14: u32 = 14;
pub const GX_TEVSTAGE15: u32 = 15;
pub const GX_MAX_TEVSTAGE: u32 = 16;
pub const GX_TEV_ADD: u32 = 0;
pub const GX_TEV_SUB: u32 = 1;
pub const GX_TEV_COMP_R8_GT: u32 = 8;
pub const GX_TEV_COMP_R8_EQ: u32 = 9;
pub const GX_TEV_COMP_GR16_GT: u32 = 10;
pub const GX_TEV_COMP_GR16_EQ: u32 = 11;
pub const GX_TEV_COMP_BGR24_GT: u32 = 12;
pub const GX_TEV_COMP_BGR24_EQ: u32 = 13;
pub const GX_TEV_COMP_RGB8_GT: u32 = 14;
pub const GX_TEV_COMP_RGB8_EQ: u32 = 15;
pub const GX_TEV_COMP_A8_GT: u32 = 14;
pub const GX_TEV_COMP_A8_EQ: u32 = 15;
pub const GX_TB_ZERO: u32 = 0;
pub const GX_TB_ADDHALF: u32 = 1;
pub const GX_TB_SUBHALF: u32 = 2;
pub const GX_MAX_TEVBIAS: u32 = 3;
pub const GX_TC_LINEAR: u32 = 0;
pub const GX_TC_GE: u32 = 1;
pub const GX_TC_EQ: u32 = 2;
pub const GX_TC_LE: u32 = 3;
pub const GX_MAX_TEVCLAMPMODE: u32 = 4;
pub const GX_CS_SCALE_1: u32 = 0;
pub const GX_CS_SCALE_2: u32 = 1;
pub const GX_CS_SCALE_4: u32 = 2;
pub const GX_CS_DIVIDE_2: u32 = 3;
pub const GX_MAX_TEVSCALE: u32 = 4;
pub const GX_TEVPREV: u32 = 0;
pub const GX_TEVREG0: u32 = 1;
pub const GX_TEVREG1: u32 = 2;
pub const GX_TEVREG2: u32 = 3;
pub const GX_MAX_TEVREG: u32 = 4;
pub const GX_CULL_NONE: u32 = 0;
pub const GX_CULL_FRONT: u32 = 1;
pub const GX_CULL_BACK: u32 = 2;
pub const GX_CULL_ALL: u32 = 3;
pub const GX_TEXMAP0: u32 = 0;
pub const GX_TEXMAP1: u32 = 1;
pub const GX_TEXMAP2: u32 = 2;
pub const GX_TEXMAP3: u32 = 3;
pub const GX_TEXMAP4: u32 = 4;
pub const GX_TEXMAP5: u32 = 5;
pub const GX_TEXMAP6: u32 = 6;
pub const GX_TEXMAP7: u32 = 7;
pub const GX_MAX_TEXMAP: u32 = 8;
pub const GX_TEXMAP_NULL: u32 = 255;
pub const GX_TEXMAP_DISABLE: u32 = 256;
pub const GX_AOP_AND: u32 = 0;
pub const GX_AOP_OR: u32 = 1;
pub const GX_AOP_XOR: u32 = 2;
pub const GX_AOP_XNOR: u32 = 3;
pub const GX_MAX_ALPHAOP: u32 = 4;
pub const GX_KCOLOR0: u32 = 0;
pub const GX_KCOLOR1: u32 = 1;
pub const GX_KCOLOR2: u32 = 2;
pub const GX_KCOLOR3: u32 = 3;
pub const GX_KCOLOR_MAX: u32 = 4;
pub const GX_TEV_KCSEL_1: u32 = 0;
pub const GX_TEV_KCSEL_7_8: u32 = 1;
pub const GX_TEV_KCSEL_3_4: u32 = 2;
pub const GX_TEV_KCSEL_5_8: u32 = 3;
pub const GX_TEV_KCSEL_1_2: u32 = 4;
pub const GX_TEV_KCSEL_3_8: u32 = 5;
pub const GX_TEV_KCSEL_1_4: u32 = 6;
pub const GX_TEV_KCSEL_1_8: u32 = 7;
pub const GX_TEV_KCSEL_K0: u32 = 12;
pub const GX_TEV_KCSEL_K1: u32 = 13;
pub const GX_TEV_KCSEL_K2: u32 = 14;
pub const GX_TEV_KCSEL_K3: u32 = 15;
pub const GX_TEV_KCSEL_K0_R: u32 = 16;
pub const GX_TEV_KCSEL_K1_R: u32 = 17;
pub const GX_TEV_KCSEL_K2_R: u32 = 18;
pub const GX_TEV_KCSEL_K3_R: u32 = 19;
pub const GX_TEV_KCSEL_K0_G: u32 = 20;
pub const GX_TEV_KCSEL_K1_G: u32 = 21;
pub const GX_TEV_KCSEL_K2_G: u32 = 22;
pub const GX_TEV_KCSEL_K3_G: u32 = 23;
pub const GX_TEV_KCSEL_K0_B: u32 = 24;
pub const GX_TEV_KCSEL_K1_B: u32 = 25;
pub const GX_TEV_KCSEL_K2_B: u32 = 26;
pub const GX_TEV_KCSEL_K3_B: u32 = 27;
pub const GX_TEV_KCSEL_K0_A: u32 = 28;
pub const GX_TEV_KCSEL_K1_A: u32 = 29;
pub const GX_TEV_KCSEL_K2_A: u32 = 30;
pub const GX_TEV_KCSEL_K3_A: u32 = 31;
pub const GX_TEV_KASEL_1: u32 = 0;
pub const GX_TEV_KASEL_7_8: u32 = 1;
pub const GX_TEV_KASEL_3_4: u32 = 2;
pub const GX_TEV_KASEL_5_8: u32 = 3;
pub const GX_TEV_KASEL_1_2: u32 = 4;
pub const GX_TEV_KASEL_3_8: u32 = 5;
pub const GX_TEV_KASEL_1_4: u32 = 6;
pub const GX_TEV_KASEL_1_8: u32 = 7;
pub const GX_TEV_KASEL_K0_R: u32 = 16;
pub const GX_TEV_KASEL_K1_R: u32 = 17;
pub const GX_TEV_KASEL_K2_R: u32 = 18;
pub const GX_TEV_KASEL_K3_R: u32 = 19;
pub const GX_TEV_KASEL_K0_G: u32 = 20;
pub const GX_TEV_KASEL_K1_G: u32 = 21;
pub const GX_TEV_KASEL_K2_G: u32 = 22;
pub const GX_TEV_KASEL_K3_G: u32 = 23;
pub const GX_TEV_KASEL_K0_B: u32 = 24;
pub const GX_TEV_KASEL_K1_B: u32 = 25;
pub const GX_TEV_KASEL_K2_B: u32 = 26;
pub const GX_TEV_KASEL_K3_B: u32 = 27;
pub const GX_TEV_KASEL_K0_A: u32 = 28;
pub const GX_TEV_KASEL_K1_A: u32 = 29;
pub const GX_TEV_KASEL_K2_A: u32 = 30;
pub const GX_TEV_KASEL_K3_A: u32 = 31;
pub const GX_TEV_SWAP0: u32 = 0;
pub const GX_TEV_SWAP1: u32 = 1;
pub const GX_TEV_SWAP2: u32 = 2;
pub const GX_TEV_SWAP3: u32 = 3;
pub const GX_MAX_TEVSWAP: u32 = 4;
pub const GX_CH_RED: u32 = 0;
pub const GX_CH_GREEN: u32 = 1;
pub const GX_CH_BLUE: u32 = 2;
pub const GX_CH_ALPHA: u32 = 3;
pub const GX_INDTEXSTAGE0: u32 = 0;
pub const GX_INDTEXSTAGE1: u32 = 1;
pub const GX_INDTEXSTAGE2: u32 = 2;
pub const GX_INDTEXSTAGE3: u32 = 3;
pub const GX_MAX_INDTEXSTAGE: u32 = 4;
pub const GX_ITF_8: u32 = 0;
pub const GX_ITF_5: u32 = 1;
pub const GX_ITF_4: u32 = 2;
pub const GX_ITF_3: u32 = 3;
pub const GX_MAX_ITFORMAT: u32 = 4;
pub const GX_ITB_NONE: u32 = 0;
pub const GX_ITB_S: u32 = 1;
pub const GX_ITB_T: u32 = 2;
pub const GX_ITB_ST: u32 = 3;
pub const GX_ITB_U: u32 = 4;
pub const GX_ITB_SU: u32 = 5;
pub const GX_ITB_TU: u32 = 6;
pub const GX_ITB_STU: u32 = 7;
pub const GX_MAX_ITBIAS: u32 = 8;
pub const GX_ITM_OFF: u32 = 0;
pub const GX_ITM_0: u32 = 1;
pub const GX_ITM_1: u32 = 2;
pub const GX_ITM_2: u32 = 3;
pub const GX_ITM_S0: u32 = 5;
pub const GX_ITM_S1: u32 = 6;
pub const GX_ITM_S2: u32 = 7;
pub const GX_ITM_T0: u32 = 9;
pub const GX_ITM_T1: u32 = 10;
pub const GX_ITM_T2: u32 = 11;
pub const GX_ITW_OFF: u32 = 0;
pub const GX_ITW_256: u32 = 1;
pub const GX_ITW_128: u32 = 2;
pub const GX_ITW_64: u32 = 3;
pub const GX_ITW_32: u32 = 4;
pub const GX_ITW_16: u32 = 5;
pub const GX_ITW_0: u32 = 6;
pub const GX_MAX_ITWRAP: u32 = 7;
pub const GX_ITBA_OFF: u32 = 0;
pub const GX_ITBA_S: u32 = 1;
pub const GX_ITBA_T: u32 = 2;
pub const GX_ITBA_U: u32 = 3;
pub const GX_MAX_ITBALPHA: u32 = 4;
pub const GX_ITS_1: u32 = 0;
pub const GX_ITS_2: u32 = 1;
pub const GX_ITS_4: u32 = 2;
pub const GX_ITS_8: u32 = 3;
pub const GX_ITS_16: u32 = 4;
pub const GX_ITS_32: u32 = 5;
pub const GX_ITS_64: u32 = 6;
pub const GX_ITS_128: u32 = 7;
pub const GX_ITS_256: u32 = 8;
pub const GX_MAX_ITSCALE: u32 = 9;
pub const GX_FOG_NONE: u32 = 0;
pub const GX_FOG_PERSP_LIN: u32 = 2;
pub const GX_FOG_PERSP_EXP: u32 = 4;
pub const GX_FOG_PERSP_EXP2: u32 = 5;
pub const GX_FOG_PERSP_REVEXP: u32 = 6;
pub const GX_FOG_PERSP_REVEXP2: u32 = 7;
pub const GX_FOG_ORTHO_LIN: u32 = 10;
pub const GX_FOG_ORTHO_EXP: u32 = 12;
pub const GX_FOG_ORTHO_EXP2: u32 = 13;
pub const GX_FOG_ORTHO_REVEXP: u32 = 14;
pub const GX_FOG_ORTHO_REVEXP2: u32 = 15;
pub const GX_FOG_LIN: u32 = 2;
pub const GX_FOG_EXP: u32 = 4;
pub const GX_FOG_EXP2: u32 = 5;
pub const GX_FOG_REVEXP: u32 = 6;
pub const GX_FOG_REVEXP2: u32 = 7;
pub const GX_PF_RGB8_Z24: u32 = 0;
pub const GX_PF_RGBA6_Z24: u32 = 1;
pub const GX_PF_RGB565_Z16: u32 = 2;
pub const GX_PF_Z24: u32 = 3;
pub const GX_PF_Y8: u32 = 4;
pub const GX_PF_U8: u32 = 5;
pub const GX_PF_V8: u32 = 6;
pub const GX_PF_YUV420: u32 = 7;
pub const GX_ZC_LINEAR: u32 = 0;
pub const GX_ZC_NEAR: u32 = 1;
pub const GX_ZC_MID: u32 = 2;
pub const GX_ZC_FAR: u32 = 3;
pub const GX_CLAMP_NONE: u32 = 0;
pub const GX_CLAMP_TOP: u32 = 1;
pub const GX_CLAMP_BOTTOM: u32 = 2;
pub const GX_GM_1_0: u32 = 0;
pub const GX_GM_1_7: u32 = 1;
pub const GX_GM_2_2: u32 = 2;
pub const GX_COPY_PROGRESSIVE: u32 = 0;
pub const GX_COPY_INTLC_EVEN: u32 = 2;
pub const GX_COPY_INTLC_ODD: u32 = 3;
pub const GX_READ_00: u32 = 0;
pub const GX_READ_FF: u32 = 1;
pub const GX_READ_NONE: u32 = 2;
pub const GX_TEXCACHE_32K: u32 = 0;
pub const GX_TEXCACHE_128K: u32 = 1;
pub const GX_TEXCACHE_512K: u32 = 2;
pub const GX_TEXCACHE_NONE: u32 = 3;
pub const GX_DA_OFF: u32 = 0;
pub const GX_DA_GENTLE: u32 = 1;
pub const GX_DA_MEDIUM: u32 = 2;
pub const GX_DA_STEEP: u32 = 3;
pub const GX_SP_OFF: u32 = 0;
pub const GX_SP_FLAT: u32 = 1;
pub const GX_SP_COS: u32 = 2;
pub const GX_SP_COS2: u32 = 3;
pub const GX_SP_SHARP: u32 = 4;
pub const GX_SP_RING1: u32 = 5;
pub const GX_SP_RING2: u32 = 6;
pub const GX_NEAR: u32 = 0;
pub const GX_LINEAR: u32 = 1;
pub const GX_NEAR_MIP_NEAR: u32 = 2;
pub const GX_LIN_MIP_NEAR: u32 = 3;
pub const GX_NEAR_MIP_LIN: u32 = 4;
pub const GX_LIN_MIP_LIN: u32 = 5;
pub const GX_ANISO_1: u32 = 0;
pub const GX_ANISO_2: u32 = 1;
pub const GX_ANISO_4: u32 = 2;
pub const GX_MAX_ANISOTROPY: u32 = 3;
pub const GX_VC_POS: u32 = 0;
pub const GX_VC_NRM: u32 = 1;
pub const GX_VC_CLR0: u32 = 2;
pub const GX_VC_CLR1: u32 = 3;
pub const GX_VC_TEX0: u32 = 4;
pub const GX_VC_TEX1: u32 = 5;
pub const GX_VC_TEX2: u32 = 6;
pub const GX_VC_TEX3: u32 = 7;
pub const GX_VC_TEX4: u32 = 8;
pub const GX_VC_TEX5: u32 = 9;
pub const GX_VC_TEX6: u32 = 10;
pub const GX_VC_TEX7: u32 = 11;
pub const GX_VC_ALL: u32 = 15;
pub const GX_PERF0_VERTICES: u32 = 0;
pub const GX_PERF0_CLIP_VTX: u32 = 1;
pub const GX_PERF0_CLIP_CLKS: u32 = 2;
pub const GX_PERF0_XF_WAIT_IN: u32 = 3;
pub const GX_PERF0_XF_WAIT_OUT: u32 = 4;
pub const GX_PERF0_XF_XFRM_CLKS: u32 = 5;
pub const GX_PERF0_XF_LIT_CLKS: u32 = 6;
pub const GX_PERF0_XF_BOT_CLKS: u32 = 7;
pub const GX_PERF0_XF_REGLD_CLKS: u32 = 8;
pub const GX_PERF0_XF_REGRD_CLKS: u32 = 9;
pub const GX_PERF0_CLIP_RATIO: u32 = 10;
pub const GX_PERF0_TRIANGLES: u32 = 11;
pub const GX_PERF0_TRIANGLES_CULLED: u32 = 12;
pub const GX_PERF0_TRIANGLES_PASSED: u32 = 13;
pub const GX_PERF0_TRIANGLES_SCISSORED: u32 = 14;
pub const GX_PERF0_TRIANGLES_0TEX: u32 = 15;
pub const GX_PERF0_TRIANGLES_1TEX: u32 = 16;
pub const GX_PERF0_TRIANGLES_2TEX: u32 = 17;
pub const GX_PERF0_TRIANGLES_3TEX: u32 = 18;
pub const GX_PERF0_TRIANGLES_4TEX: u32 = 19;
pub const GX_PERF0_TRIANGLES_5TEX: u32 = 20;
pub const GX_PERF0_TRIANGLES_6TEX: u32 = 21;
pub const GX_PERF0_TRIANGLES_7TEX: u32 = 22;
pub const GX_PERF0_TRIANGLES_8TEX: u32 = 23;
pub const GX_PERF0_TRIANGLES_0CLR: u32 = 24;
pub const GX_PERF0_TRIANGLES_1CLR: u32 = 25;
pub const GX_PERF0_TRIANGLES_2CLR: u32 = 26;
pub const GX_PERF0_QUAD_0CVG: u32 = 27;
pub const GX_PERF0_QUAD_NON0CVG: u32 = 28;
pub const GX_PERF0_QUAD_1CVG: u32 = 29;
pub const GX_PERF0_QUAD_2CVG: u32 = 30;
pub const GX_PERF0_QUAD_3CVG: u32 = 31;
pub const GX_PERF0_QUAD_4CVG: u32 = 32;
pub const GX_PERF0_AVG_QUAD_CNT: u32 = 33;
pub const GX_PERF0_CLOCKS: u32 = 34;
pub const GX_PERF0_NONE: u32 = 35;
pub const GX_PERF1_TEXELS: u32 = 0;
pub const GX_PERF1_TX_IDLE: u32 = 1;
pub const GX_PERF1_TX_REGS: u32 = 2;
pub const GX_PERF1_TX_MEMSTALL: u32 = 3;
pub const GX_PERF1_TC_CHECK1_2: u32 = 4;
pub const GX_PERF1_TC_CHECK3_4: u32 = 5;
pub const GX_PERF1_TC_CHECK5_6: u32 = 6;
pub const GX_PERF1_TC_CHECK7_8: u32 = 7;
pub const GX_PERF1_TC_MISS: u32 = 8;
pub const GX_PERF1_VC_ELEMQ_FULL: u32 = 9;
pub const GX_PERF1_VC_MISSQ_FULL: u32 = 10;
pub const GX_PERF1_VC_MEMREQ_FULL: u32 = 11;
pub const GX_PERF1_VC_STATUS7: u32 = 12;
pub const GX_PERF1_VC_MISSREP_FULL: u32 = 13;
pub const GX_PERF1_VC_STREAMBUF_LOW: u32 = 14;
pub const GX_PERF1_VC_ALL_STALLS: u32 = 15;
pub const GX_PERF1_VERTICES: u32 = 16;
pub const GX_PERF1_FIFO_REQ: u32 = 17;
pub const GX_PERF1_CALL_REQ: u32 = 18;
pub const GX_PERF1_VC_MISS_REQ: u32 = 19;
pub const GX_PERF1_CP_ALL_REQ: u32 = 20;
pub const GX_PERF1_CLOCKS: u32 = 21;
pub const GX_PERF1_NONE: u32 = 22;
pub const GX_TLUT0: u32 = 0;
pub const GX_TLUT1: u32 = 1;
pub const GX_TLUT2: u32 = 2;
pub const GX_TLUT3: u32 = 3;
pub const GX_TLUT4: u32 = 4;
pub const GX_TLUT5: u32 = 5;
pub const GX_TLUT6: u32 = 6;
pub const GX_TLUT7: u32 = 7;
pub const GX_TLUT8: u32 = 8;
pub const GX_TLUT9: u32 = 9;
pub const GX_TLUT10: u32 = 10;
pub const GX_TLUT11: u32 = 11;
pub const GX_TLUT12: u32 = 12;
pub const GX_TLUT13: u32 = 13;
pub const GX_TLUT14: u32 = 14;
pub const GX_TLUT15: u32 = 15;
pub const GX_BIGTLUT0: u32 = 16;
pub const GX_BIGTLUT1: u32 = 17;
pub const GX_BIGTLUT2: u32 = 18;
pub const GX_BIGTLUT3: u32 = 19;
pub const GX_MAX_VTXDESC: u32 = 26;
pub const GX_MAX_VTXDESC_LISTSIZE: u32 = 27;
pub const GX_MAX_VTXATTRFMT: u32 = 26;
pub const GX_MAX_VTXATTRFMT_LISTSIZE: u32 = 27;
pub const GX_MAX_Z24: u32 = 16777215;
pub const SI_CHAN0: u32 = 0;
pub const SI_CHAN1: u32 = 1;
pub const SI_CHAN2: u32 = 2;
pub const SI_CHAN3: u32 = 3;
pub const SI_MAX_CHAN: u32 = 4;
pub const SI_CHAN0_BIT: u32 = 2147483648;
pub const SI_CHAN1_BIT: u32 = 1073741824;
pub const SI_CHAN2_BIT: u32 = 536870912;
pub const SI_CHAN3_BIT: u32 = 268435456;
pub const SI_ERROR_UNDER_RUN: u32 = 1;
pub const SI_ERROR_OVER_RUN: u32 = 2;
pub const SI_ERROR_COLLISION: u32 = 4;
pub const SI_ERROR_NO_RESPONSE: u32 = 8;
pub const SI_ERROR_WRST: u32 = 16;
pub const SI_ERROR_RDST: u32 = 32;
pub const SI_ERROR_UNKNOWN: u32 = 64;
pub const SI_ERROR_BUSY: u32 = 128;
pub const SI_TYPE_MASK: u32 = 402653184;
pub const SI_TYPE_N64: u32 = 0;
pub const SI_TYPE_DOLPHIN: u32 = 134217728;
pub const SI_TYPE_GC: u32 = 134217728;
pub const SI_GC_WIRELESS: u32 = 2147483648;
pub const SI_GC_NOMOTOR: u32 = 536870912;
pub const SI_GC_STANDARD: u32 = 16777216;
pub const SI_WIRELESS_RECEIVED: u32 = 1073741824;
pub const SI_WIRELESS_IR: u32 = 67108864;
pub const SI_WIRELESS_STATE: u32 = 33554432;
pub const SI_WIRELESS_ORIGIN: u32 = 2097152;
pub const SI_WIRELESS_FIX_ID: u32 = 1048576;
pub const SI_WIRELESS_TYPE: u32 = 983040;
pub const SI_WIRELESS_LITE_MASK: u32 = 786432;
pub const SI_WIRELESS_LITE: u32 = 262144;
pub const SI_WIRELESS_CONT_MASK: u32 = 524288;
pub const SI_WIRELESS_CONT: u32 = 0;
pub const SI_WIRELESS_ID: u32 = 12648192;
pub const SI_WIRELESS_TYPE_ID: u32 = 13631232;
pub const SI_N64_CONTROLLER: u32 = 83886080;
pub const SI_N64_MIC: u32 = 65536;
pub const SI_N64_KEYBOARD: u32 = 131072;
pub const SI_N64_MOUSE: u32 = 33554432;
pub const SI_GBA: u32 = 262144;
pub const SI_GC_CONTROLLER: u32 = 150994944;
pub const SI_GC_RECEIVER: u32 = 2281701376;
pub const SI_GC_WAVEBIRD: u32 = 2333081600;
pub const SI_GC_KEYBOARD: u32 = 136314880;
pub const SI_GC_STEERING: u32 = 134217728;
pub const NUM_EXCEPTIONS: u32 = 15;
pub const EX_SYS_RESET: u32 = 0;
pub const EX_MACH_CHECK: u32 = 1;
pub const EX_DSI: u32 = 2;
pub const EX_ISI: u32 = 3;
pub const EX_INT: u32 = 4;
pub const EX_ALIGN: u32 = 5;
pub const EX_PRG: u32 = 6;
pub const EX_FP: u32 = 7;
pub const EX_DEC: u32 = 8;
pub const EX_SYS_CALL: u32 = 9;
pub const EX_TRACE: u32 = 10;
pub const EX_PERF: u32 = 11;
pub const EX_IABR: u32 = 12;
pub const EX_RESV: u32 = 13;
pub const EX_THERM: u32 = 14;
pub const IM_NONE: u32 = 4294967295;
pub const IRQ_MEM0: u32 = 0;
pub const IRQ_MEM1: u32 = 1;
pub const IRQ_MEM2: u32 = 2;
pub const IRQ_MEM3: u32 = 3;
pub const IRQ_MEMADDRESS: u32 = 4;
pub const IRQ_DSP_AI: u32 = 5;
pub const IRQ_DSP_ARAM: u32 = 6;
pub const IRQ_DSP_DSP: u32 = 7;
pub const IRQ_AI: u32 = 8;
pub const IRQ_EXI0_EXI: u32 = 9;
pub const IRQ_EXI0_TC: u32 = 10;
pub const IRQ_EXI0_EXT: u32 = 11;
pub const IRQ_EXI1_EXI: u32 = 12;
pub const IRQ_EXI1_TC: u32 = 13;
pub const IRQ_EXI1_EXT: u32 = 14;
pub const IRQ_EXI2_EXI: u32 = 15;
pub const IRQ_EXI2_TC: u32 = 16;
pub const IRQ_PI_CP: u32 = 17;
pub const IRQ_PI_PETOKEN: u32 = 18;
pub const IRQ_PI_PEFINISH: u32 = 19;
pub const IRQ_PI_SI: u32 = 20;
pub const IRQ_PI_DI: u32 = 21;
pub const IRQ_PI_RSW: u32 = 22;
pub const IRQ_PI_ERROR: u32 = 23;
pub const IRQ_PI_VI: u32 = 24;
pub const IRQ_PI_DEBUG: u32 = 25;
pub const IRQ_PI_HSP: u32 = 26;
pub const IRQ_PI_ACR: u32 = 27;
pub const IRQ_MAX: u32 = 32;
pub const LWP_MUTEX_NULL: u32 = 4294967295;
pub const MQ_BOX_NULL: u32 = 4294967295;
pub const MQ_ERROR_SUCCESSFUL: u32 = 0;
pub const MQ_ERROR_TOOMANY: i32 = -5;
pub const MQ_MSG_BLOCK: u32 = 0;
pub const MQ_MSG_NOBLOCK: u32 = 1;
pub const LWP_SEM_NULL: u32 = 4294967295;
pub const PAD_CHAN0: u32 = 0;
pub const PAD_CHAN1: u32 = 1;
pub const PAD_CHAN2: u32 = 2;
pub const PAD_CHAN3: u32 = 3;
pub const PAD_CHANMAX: u32 = 4;
pub const PAD_MOTOR_STOP: u32 = 0;
pub const PAD_MOTOR_RUMBLE: u32 = 1;
pub const PAD_MOTOR_STOP_HARD: u32 = 2;
pub const PAD_ERR_NONE: u32 = 0;
pub const PAD_ERR_NO_CONTROLLER: i32 = -1;
pub const PAD_ERR_NOT_READY: i32 = -2;
pub const PAD_ERR_TRANSFER: i32 = -3;
pub const PAD_BUTTON_LEFT: u32 = 1;
pub const PAD_BUTTON_RIGHT: u32 = 2;
pub const PAD_BUTTON_DOWN: u32 = 4;
pub const PAD_BUTTON_UP: u32 = 8;
pub const PAD_TRIGGER_Z: u32 = 16;
pub const PAD_TRIGGER_R: u32 = 32;
pub const PAD_TRIGGER_L: u32 = 64;
pub const PAD_BUTTON_A: u32 = 256;
pub const PAD_BUTTON_B: u32 = 512;
pub const PAD_BUTTON_X: u32 = 1024;
pub const PAD_BUTTON_Y: u32 = 2048;
pub const PAD_BUTTON_MENU: u32 = 4096;
pub const PAD_BUTTON_START: u32 = 4096;
pub const PAD_CHAN0_BIT: u32 = 2147483648;
pub const PAD_CHAN1_BIT: u32 = 1073741824;
pub const PAD_CHAN2_BIT: u32 = 536870912;
pub const PAD_CHAN3_BIT: u32 = 268435456;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 4321;
pub const _QUAD_HIGHWORD: u32 = 0;
pub const _QUAD_LOWWORD: u32 = 1;
pub const PDP_ENDIAN: u32 = 3412;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG2STR_MAX: u32 = 17;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SYS_BASE_CACHED: u32 = 2147483648;
pub const SYS_BASE_UNCACHED: u32 = 3221225472;
pub const SYS_WD_NULL: u32 = 4294967295;
pub const SYS_RESTART: u32 = 0;
pub const SYS_HOTRESET: u32 = 1;
pub const SYS_SHUTDOWN: u32 = 2;
pub const SYS_RETURNTOMENU: u32 = 3;
pub const SYS_POWEROFF: u32 = 4;
pub const SYS_POWEROFF_STANDBY: u32 = 5;
pub const SYS_POWEROFF_IDLE: u32 = 6;
pub const SYS_PROTECTCHAN0: u32 = 0;
pub const SYS_PROTECTCHAN1: u32 = 1;
pub const SYS_PROTECTCHAN2: u32 = 2;
pub const SYS_PROTECTCHAN3: u32 = 3;
pub const SYS_PROTECTCHANMAX: u32 = 4;
pub const SYS_PROTECTNONE: u32 = 0;
pub const SYS_PROTECTREAD: u32 = 1;
pub const SYS_PROTECTWRITE: u32 = 2;
pub const SYS_PROTECTRDWR: u32 = 3;
pub const SYS_LANG_ENGLISH: u32 = 0;
pub const SYS_LANG_GERMAN: u32 = 1;
pub const SYS_LANG_FRENCH: u32 = 2;
pub const SYS_LANG_SPANISH: u32 = 3;
pub const SYS_LANG_ITALIAN: u32 = 4;
pub const SYS_LANG_DUTCH: u32 = 5;
pub const SYS_VIDEO_NTSC: u32 = 0;
pub const SYS_VIDEO_PAL: u32 = 1;
pub const SYS_VIDEO_MPAL: u32 = 2;
pub const SYS_SOUND_MONO: u32 = 0;
pub const SYS_SOUND_STEREO: u32 = 1;
pub const SYS_FONTSIZE_ANSI: u32 = 131360;
pub const SYS_FONTSIZE_SJIS: u32 = 1183488;
pub const VI_DISPLAY_PIX_SZ: u32 = 2;
pub const VI_INTERLACE: u32 = 0;
pub const VI_NON_INTERLACE: u32 = 1;
pub const VI_PROGRESSIVE: u32 = 2;
pub const VI_NTSC: u32 = 0;
pub const VI_PAL: u32 = 1;
pub const VI_MPAL: u32 = 2;
pub const VI_DEBUG: u32 = 3;
pub const VI_DEBUG_PAL: u32 = 4;
pub const VI_EURGB60: u32 = 5;
pub const VI_XFBMODE_SF: u32 = 0;
pub const VI_XFBMODE_DF: u32 = 1;
pub const VI_FIELD_ABOVE: u32 = 1;
pub const VI_FIELD_BELOW: u32 = 0;
pub const VI_MAX_WIDTH_NTSC: u32 = 720;
pub const VI_MAX_HEIGHT_NTSC: u32 = 480;
pub const VI_MAX_WIDTH_PAL: u32 = 720;
pub const VI_MAX_HEIGHT_PAL: u32 = 576;
pub const VI_MAX_WIDTH_MPAL: u32 = 720;
pub const VI_MAX_HEIGHT_MPAL: u32 = 480;
pub const VI_MAX_WIDTH_EURGB60: u32 = 720;
pub const VI_MAX_HEIGHT_EURGB60: u32 = 480;
pub const IPC_HEAP: i32 = -1;
pub const IPC_OPEN_NONE: u32 = 0;
pub const IPC_OPEN_READ: u32 = 1;
pub const IPC_OPEN_WRITE: u32 = 2;
pub const IPC_OPEN_RW: u32 = 3;
pub const IPC_MAXPATH_LEN: u32 = 64;
pub const IPC_OK: u32 = 0;
pub const IPC_EINVAL: i32 = -4;
pub const IPC_ENOHEAP: i32 = -5;
pub const IPC_ENOENT: i32 = -6;
pub const IPC_EQUEUEFULL: i32 = -8;
pub const IPC_ENOMEM: i32 = -22;
pub const SHA_MSGBLOCK_SIZE: u32 = 65536;
pub const AES_BLOCK_SIZE: u32 = 65536;
pub const ES_EINVAL: i32 = -4100;
pub const ES_ENOMEM: i32 = -4108;
pub const ES_ENOTINIT: i32 = -4352;
pub const ES_EALIGN: i32 = -4353;
pub const ES_SIG_RSA4096: u32 = 65536;
pub const ES_SIG_RSA2048: u32 = 65537;
pub const ES_SIG_ECDSA: u32 = 65538;
pub const ES_CERT_RSA4096: u32 = 0;
pub const ES_CERT_RSA2048: u32 = 1;
pub const ES_CERT_ECDSA: u32 = 2;
pub const ES_KEY_COMMON: u32 = 4;
pub const ES_KEY_SDCARD: u32 = 6;
pub const MAX_NUM_TMD_CONTENTS: u32 = 512;
pub const STM_EVENT_RESET: u32 = 131072;
pub const STM_EVENT_POWER: u32 = 2048;
pub const STM_EINVAL: i32 = -8196;
pub const STM_ENOTINIT: i32 = -8448;
pub const STM_ENOHANDLER: i32 = -8449;
pub const IOS_EINVAL: i32 = -12292;
pub const IOS_EBADVERSION: i32 = -12544;
pub const IOS_ETOOMANYVIEWS: i32 = -12545;
pub const IOS_EMISMATCH: i32 = -12546;
pub const USB_MAXPATH: u32 = 64;
pub const USB_OK: u32 = 0;
pub const USB_FAILED: u32 = 1;
pub const USB_CLASS_HID: u32 = 3;
pub const USB_SUBCLASS_NONE: u32 = 0;
pub const USB_SUBCLASS_BOOT: u32 = 1;
pub const USB_PROTOCOL_NONE: u32 = 0;
pub const USB_PROTOCOL_KEYBOARD: u32 = 1;
pub const USB_PROTOCOL_MOUSE: u32 = 2;
pub const USB_REPTYPE_INPUT: u32 = 1;
pub const USB_REPTYPE_OUTPUT: u32 = 2;
pub const USB_REPTYPE_FEATURE: u32 = 3;
pub const USB_DT_DEVICE: u32 = 1;
pub const USB_DT_CONFIG: u32 = 2;
pub const USB_DT_STRING: u32 = 3;
pub const USB_DT_INTERFACE: u32 = 4;
pub const USB_DT_ENDPOINT: u32 = 5;
pub const USB_DT_DEVICE_QUALIFIER: u32 = 6;
pub const USB_DT_OTHER_SPEED_CONFIG: u32 = 7;
pub const USB_DT_INTERFACE_POWER: u32 = 8;
pub const USB_DT_OTG: u32 = 9;
pub const USB_DT_DEBUG: u32 = 16;
pub const USB_DT_INTERFACE_ASSOCIATION: u32 = 17;
pub const USB_DT_HID: u32 = 33;
pub const USB_DT_REPORT: u32 = 34;
pub const USB_DT_PHYSICAL: u32 = 35;
pub const USB_DT_CLASS_SPECIFIC_INTERFACE: u32 = 36;
pub const USB_DT_CLASS_SPECIFIC_ENDPOINT: u32 = 37;
pub const USB_DT_HUB: u32 = 41;
pub const USB_REQ_GETSTATUS: u32 = 0;
pub const USB_REQ_CLEARFEATURE: u32 = 1;
pub const USB_REQ_SETFEATURE: u32 = 3;
pub const USB_REQ_SETADDRESS: u32 = 5;
pub const USB_REQ_GETDESCRIPTOR: u32 = 6;
pub const USB_REQ_SETDESCRIPTOR: u32 = 7;
pub const USB_REQ_GETCONFIG: u32 = 8;
pub const USB_REQ_SETCONFIG: u32 = 9;
pub const USB_REQ_GETINTERFACE: u32 = 10;
pub const USB_REQ_SETINTERFACE: u32 = 11;
pub const USB_REQ_SYNCFRAME: u32 = 12;
pub const USB_REQ_GETREPORT: u32 = 1;
pub const USB_REQ_GETIDLE: u32 = 2;
pub const USB_REQ_GETPROTOCOL: u32 = 3;
pub const USB_REQ_SETREPORT: u32 = 9;
pub const USB_REQ_SETIDLE: u32 = 10;
pub const USB_REQ_SETPROTOCOL: u32 = 11;
pub const USB_DT_DEVICE_SIZE: u32 = 18;
pub const USB_DT_CONFIG_SIZE: u32 = 9;
pub const USB_DT_INTERFACE_SIZE: u32 = 9;
pub const USB_DT_ENDPOINT_SIZE: u32 = 7;
pub const USB_DT_ENDPOINT_AUDIO_SIZE: u32 = 9;
pub const USB_DT_HID_SIZE: u32 = 9;
pub const USB_DT_MINREPORT_SIZE: u32 = 8;
pub const USB_DT_HUB_NONVAR_SIZE: u32 = 7;
pub const USB_CTRLTYPE_DIR_HOST2DEVICE: u32 = 0;
pub const USB_CTRLTYPE_DIR_DEVICE2HOST: u32 = 128;
pub const USB_CTRLTYPE_TYPE_STANDARD: u32 = 0;
pub const USB_CTRLTYPE_TYPE_CLASS: u32 = 32;
pub const USB_CTRLTYPE_TYPE_VENDOR: u32 = 64;
pub const USB_CTRLTYPE_TYPE_RESERVED: u32 = 96;
pub const USB_CTRLTYPE_REC_DEVICE: u32 = 0;
pub const USB_CTRLTYPE_REC_INTERFACE: u32 = 1;
pub const USB_CTRLTYPE_REC_ENDPOINT: u32 = 2;
pub const USB_CTRLTYPE_REC_OTHER: u32 = 3;
pub const USB_REQTYPE_INTERFACE_GET: u32 = 161;
pub const USB_REQTYPE_INTERFACE_SET: u32 = 33;
pub const USB_REQTYPE_ENDPOINT_GET: u32 = 162;
pub const USB_REQTYPE_ENDPOINT_SET: u32 = 34;
pub const USB_FEATURE_ENDPOINT_HALT: u32 = 0;
pub const USB_ENDPOINT_INTERRUPT: u32 = 3;
pub const USB_ENDPOINT_IN: u32 = 128;
pub const USB_ENDPOINT_OUT: u32 = 0;
pub const USB_OH0_DEVICE_ID: u32 = 0;
pub const USB_OH1_DEVICE_ID: u32 = 2097152;
pub const ISFS_MAXPATH: u32 = 64;
pub const ISFS_OPEN_READ: u32 = 1;
pub const ISFS_OPEN_WRITE: u32 = 2;
pub const ISFS_OPEN_RW: u32 = 3;
pub const ISFS_OK: u32 = 0;
pub const ISFS_ENOMEM: i32 = -22;
pub const ISFS_EINVAL: i32 = -101;
pub const CONF_EBADFILE: i32 = -24577;
pub const CONF_ENOENT: i32 = -24578;
pub const CONF_ETOOBIG: i32 = -24579;
pub const CONF_ENOTINIT: i32 = -24580;
pub const CONF_ENOTIMPL: i32 = -24581;
pub const CONF_EBADVALUE: i32 = -24582;
pub const CONF_ENOMEM: i32 = -24583;
pub const CONF_ERR_OK: u32 = 0;
pub const CONF_PAD_MAX_REGISTERED: u32 = 10;
pub const CONF_PAD_MAX_ACTIVE: u32 = 4;
pub const USBSTORAGE_OK: u32 = 0;
pub const USBSTORAGE_ENOINTERFACE: i32 = -10000;
pub const USBSTORAGE_ESENSE: i32 = -10001;
pub const USBSTORAGE_ESHORTWRITE: i32 = -10002;
pub const USBSTORAGE_ESHORTREAD: i32 = -10003;
pub const USBSTORAGE_ESIGNATURE: i32 = -10004;
pub const USBSTORAGE_ETAG: i32 = -10005;
pub const USBSTORAGE_ESTATUS: i32 = -10006;
pub const USBSTORAGE_EDATARESIDUE: i32 = -10007;
pub const USBSTORAGE_ETIMEDOUT: i32 = -10008;
pub const USBSTORAGE_EINIT: i32 = -10009;
pub const USBSTORAGE_PROCESSING: i32 = -10010;
pub const B_RAW_DEVICE_DATA_IN: u32 = 1;
pub const B_RAW_DEVICE_COMMAND: u32 = 0;
pub const WII_ENOTINIT: i32 = -36865;
pub const WII_EINTERNAL: i32 = -36866;
pub const WII_ECHECKSUM: i32 = -36867;
pub const WII_EINSTALL: i32 = -36868;
pub const WII_E2BIG: i32 = -36869;
pub const SETTINGS_CALENDAR: &[u8; 29] = b"Calendar/Calendar_index.html\0";
pub const SETTINGS_DISPLAY: &[u8; 27] = b"Display/Display_index.html\0";
pub const SETTINGS_SOUND: &[u8; 23] = b"Sound/Sound_index.html\0";
pub const SETTINGS_PARENTAL: &[u8; 45] = b"Parental_Control/Parental_Control_index.html\0";
pub const SETTINGS_INTERNET: &[u8; 29] = b"Internet/Internet_index.html\0";
pub const SETTINGS_WC24: &[u8; 37] = b"WiiConnect24/Wiiconnect24_index.html\0";
pub const SETTINGS_UPDATE: &[u8; 25] = b"Update/Update_index.html\0";
pub const RNC_FILE_IS_NOT_RNC: i32 = -1;
pub const RNC_HUF_DECODE_ERROR: i32 = -2;
pub const RNC_FILE_SIZE_MISMATCH: i32 = -3;
pub const RNC_PACKED_CRC_ERROR: i32 = -4;
pub const RNC_UNPACKED_CRC_ERROR: i32 = -5;
pub const TB_BUS_CLOCK: u32 = 243000000;
pub const TB_CORE_CLOCK: u32 = 729000000;
pub const TB_TIMER_CLOCK: u32 = 60750;
pub const TB_MSPERSEC: u32 = 1000;
pub const TB_USPERSEC: u32 = 1000000;
pub const TB_NSPERSEC: u32 = 1000000000;
pub const TB_NSPERMS: u32 = 1000000;
pub const TB_NSPERUS: u32 = 1000;
pub const TB_USPERTICK: u32 = 10000;
pub const TB_SECSPERMIN: u32 = 60;
pub const TB_MINSPERHR: u32 = 60;
pub const TB_MONSPERYR: u32 = 12;
pub const TB_DAYSPERYR: u32 = 365;
pub const TB_HRSPERDAY: u32 = 24;
pub const TB_SECSPERDAY: u32 = 86400;
pub const TB_SECSPERNYR: u32 = 31536000;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const INVALID_SOCKET: i32 = -1;
pub const SOCKET_ERROR: i32 = -1;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const PF_INET: u32 = 2;
pub const PF_UNSPEC: u32 = 0;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const MSG_DONTWAIT: u32 = 64;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const O_NONBLOCK: u32 = 2048;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_KEEPALIVE: u32 = 2;
pub const POLLRDNORM: u32 = 1;
pub const POLLRDBAND: u32 = 2;
pub const POLLPRI: u32 = 4;
pub const POLLWRNORM: u32 = 8;
pub const POLLWRBAND: u32 = 16;
pub const POLLERR: u32 = 32;
pub const POLLHUP: u32 = 64;
pub const POLLNVAL: u32 = 128;
pub const POLLIN: u32 = 3;
pub const POLLOUT: u32 = 8;
pub const GDBSTUB_DEVICE_USB: u32 = 0;
pub const GDBSTUB_DEVICE_TCP: u32 = 1;
pub const GDBSTUB_DEF_CHANNEL: u32 = 0;
pub const GDBSTUB_DEF_TCPPORT: u32 = 2828;
pub const ASND_LIB: u32 = 256;
pub const SND_LIB: u32 = 258;
pub const MAX_SND_VOICES: u32 = 16;
pub const SND_OK: u32 = 0;
pub const SND_INVALID: i32 = -1;
pub const SND_ISNOTASONGVOICE: i32 = -2;
pub const SND_BUSY: u32 = 1;
pub const SND_UNUSED: u32 = 0;
pub const SND_WORKING: u32 = 1;
pub const SND_WAITING: u32 = 2;
pub const VOICE_MONO_8BIT: u32 = 0;
pub const VOICE_MONO_16BIT: u32 = 1;
pub const VOICE_MONO_16BIT_BE: u32 = 1;
pub const VOICE_STEREO_8BIT: u32 = 2;
pub const VOICE_STEREO_16BIT: u32 = 3;
pub const VOICE_STEREO_16BIT_BE: u32 = 3;
pub const VOICE_MONO_8BIT_U: u32 = 4;
pub const VOICE_MONO_16BIT_LE: u32 = 5;
pub const VOICE_STEREO_8BIT_U: u32 = 6;
pub const VOICE_STEREO_16BIT_LE: u32 = 7;
pub const MIN_VOLUME: u32 = 0;
pub const MID_VOLUME: u32 = 127;
pub const MAX_VOLUME: u32 = 255;
pub const MIN_PITCH: u32 = 1;
pub const F44100HZ_PITCH: u32 = 44100;
pub const MAX_PITCH: u32 = 144000;
pub const MAX_VOICES: u32 = 32;
pub const SND_BUFFERSIZE: u32 = 384;
pub const DSP_STREAMBUFFER_SIZE: u32 = 1152;
pub const DSP_DEFAULT_FREQ: u32 = 48000;
pub const VOICE_STATE_STOPPED: u32 = 0;
pub const VOICE_STATE_RUNNING: u32 = 1;
pub const VOICE_STATE_STREAM: u32 = 2;
pub const VOICE_MONO8: u32 = 0;
pub const VOICE_STEREO8: u32 = 1;
pub const VOICE_MONO16: u32 = 2;
pub const VOICE_STEREO16: u32 = 3;
pub const VOICE_MONO8_UNSIGNED: u32 = 4;
pub const VOICE_STEREO8_UNSIGNED: u32 = 5;
pub const VOICE_MONO16_UNSIGNED: u32 = 6;
pub const VOICE_STEREO16_UNSIGNED: u32 = 7;
pub const VOICE_FREQ32KHZ: u32 = 32000;
pub const VOICE_FREQ48KHZ: u32 = 48000;
pub const SIZEOF_INT: u32 = 4;
pub const SIZEOF_LONG: u32 = 4;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const MAD_VERSION_MAJOR: u32 = 0;
pub const MAD_VERSION_MINOR: u32 = 15;
pub const MAD_VERSION_PATCH: u32 = 0;
pub const MAD_VERSION_EXTRA: &[u8; 8] = b" (beta)\0";
pub const MAD_PUBLISHYEAR: &[u8; 10] = b"2000-2003\0";
pub const MAD_AUTHOR: &[u8; 28] = b"Underbit Technologies, Inc.\0";
pub const MAD_EMAIL: &[u8; 18] = b"info@underbit.com\0";
pub const MAD_F_FRACBITS: u32 = 28;
pub const MAD_F_SCALEBITS: u32 = 28;
pub const MAD_TIMER_RESOLUTION: u32 = 352800000;
pub const MAD_BUFFER_GUARD: u32 = 8;
pub const MAD_BUFFER_MDLEN: u32 = 2567;
pub const WIIMOTE_LED_NONE: u32 = 0;
pub const WIIMOTE_LED_1: u32 = 16;
pub const WIIMOTE_LED_2: u32 = 32;
pub const WIIMOTE_LED_3: u32 = 64;
pub const WIIMOTE_LED_4: u32 = 128;
pub const WIIMOTE_BUTTON_TWO: u32 = 1;
pub const WIIMOTE_BUTTON_ONE: u32 = 2;
pub const WIIMOTE_BUTTON_B: u32 = 4;
pub const WIIMOTE_BUTTON_A: u32 = 8;
pub const WIIMOTE_BUTTON_MINUS: u32 = 16;
pub const WIIMOTE_BUTTON_ZACCEL_BIT6: u32 = 32;
pub const WIIMOTE_BUTTON_ZACCEL_BIT7: u32 = 64;
pub const WIIMOTE_BUTTON_HOME: u32 = 128;
pub const WIIMOTE_BUTTON_LEFT: u32 = 256;
pub const WIIMOTE_BUTTON_RIGHT: u32 = 512;
pub const WIIMOTE_BUTTON_DOWN: u32 = 1024;
pub const WIIMOTE_BUTTON_UP: u32 = 2048;
pub const WIIMOTE_BUTTON_PLUS: u32 = 4096;
pub const WIIMOTE_BUTTON_ZACCEL_BIT4: u32 = 8192;
pub const WIIMOTE_BUTTON_ZACCEL_BIT5: u32 = 16384;
pub const WIIMOTE_BUTTON_UNKNOWN: u32 = 32768;
pub const WIIMOTE_BUTTON_ALL: u32 = 8095;
pub const NUNCHUK_BUTTON_Z: u32 = 1;
pub const NUNCHUK_BUTTON_C: u32 = 2;
pub const NUNCHUK_BUTTON_ALL: u32 = 3;
pub const CLASSIC_CTRL_BUTTON_UP: u32 = 1;
pub const CLASSIC_CTRL_BUTTON_LEFT: u32 = 2;
pub const CLASSIC_CTRL_BUTTON_ZR: u32 = 4;
pub const CLASSIC_CTRL_BUTTON_X: u32 = 8;
pub const CLASSIC_CTRL_BUTTON_A: u32 = 16;
pub const CLASSIC_CTRL_BUTTON_Y: u32 = 32;
pub const CLASSIC_CTRL_BUTTON_B: u32 = 64;
pub const CLASSIC_CTRL_BUTTON_ZL: u32 = 128;
pub const CLASSIC_CTRL_BUTTON_FULL_R: u32 = 512;
pub const CLASSIC_CTRL_BUTTON_PLUS: u32 = 1024;
pub const CLASSIC_CTRL_BUTTON_HOME: u32 = 2048;
pub const CLASSIC_CTRL_BUTTON_MINUS: u32 = 4096;
pub const CLASSIC_CTRL_BUTTON_FULL_L: u32 = 8192;
pub const CLASSIC_CTRL_BUTTON_DOWN: u32 = 16384;
pub const CLASSIC_CTRL_BUTTON_RIGHT: u32 = 32768;
pub const CLASSIC_CTRL_BUTTON_ALL: u32 = 65279;
pub const GUITAR_HERO_3_BUTTON_STRUM_UP: u32 = 1;
pub const GUITAR_HERO_3_BUTTON_YELLOW: u32 = 8;
pub const GUITAR_HERO_3_BUTTON_GREEN: u32 = 16;
pub const GUITAR_HERO_3_BUTTON_BLUE: u32 = 32;
pub const GUITAR_HERO_3_BUTTON_RED: u32 = 64;
pub const GUITAR_HERO_3_BUTTON_ORANGE: u32 = 128;
pub const GUITAR_HERO_3_BUTTON_PLUS: u32 = 1024;
pub const GUITAR_HERO_3_BUTTON_MINUS: u32 = 4096;
pub const GUITAR_HERO_3_BUTTON_STRUM_DOWN: u32 = 16384;
pub const GUITAR_HERO_3_BUTTON_ALL: u32 = 65279;
pub const GUITAR_HERO_3_TOUCH_AVAILABLE: u32 = 4096;
pub const GUITAR_HERO_3_TOUCH_GREEN: u32 = 4097;
pub const GUITAR_HERO_3_TOUCH_RED: u32 = 4098;
pub const GUITAR_HERO_3_TOUCH_YELLOW: u32 = 4100;
pub const GUITAR_HERO_3_TOUCH_BLUE: u32 = 4104;
pub const GUITAR_HERO_3_TOUCH_ORANGE: u32 = 4112;
pub const WIIUSE_SMOOTHING: u32 = 1;
pub const WIIUSE_CONTINUOUS: u32 = 2;
pub const WIIUSE_ACCEL_THRESH: u32 = 4;
pub const WIIUSE_IR_THRESH: u32 = 8;
pub const WIIUSE_JS_THRESH: u32 = 16;
pub const WIIUSE_INIT_FLAGS: u32 = 1;
pub const WIIUSE_ORIENT_PRECISION: f64 = 100.0;
pub const EXP_NONE: u32 = 0;
pub const EXP_NUNCHUK: u32 = 1;
pub const EXP_CLASSIC: u32 = 2;
pub const EXP_GUITAR_HERO_3: u32 = 3;
pub const EXP_WII_BOARD: u32 = 4;
pub const EXP_MOTION_PLUS: u32 = 5;
pub const MAX_PAYLOAD: u32 = 32;
pub const WPAD_MAX_IR_DOTS: u32 = 4;
pub const WPAD_BUTTON_2: u32 = 1;
pub const WPAD_BUTTON_1: u32 = 2;
pub const WPAD_BUTTON_B: u32 = 4;
pub const WPAD_BUTTON_A: u32 = 8;
pub const WPAD_BUTTON_MINUS: u32 = 16;
pub const WPAD_BUTTON_HOME: u32 = 128;
pub const WPAD_BUTTON_LEFT: u32 = 256;
pub const WPAD_BUTTON_RIGHT: u32 = 512;
pub const WPAD_BUTTON_DOWN: u32 = 1024;
pub const WPAD_BUTTON_UP: u32 = 2048;
pub const WPAD_BUTTON_PLUS: u32 = 4096;
pub const WPAD_NUNCHUK_BUTTON_Z: u32 = 65536;
pub const WPAD_NUNCHUK_BUTTON_C: u32 = 131072;
pub const WPAD_CLASSIC_BUTTON_UP: u32 = 65536;
pub const WPAD_CLASSIC_BUTTON_LEFT: u32 = 131072;
pub const WPAD_CLASSIC_BUTTON_ZR: u32 = 262144;
pub const WPAD_CLASSIC_BUTTON_X: u32 = 524288;
pub const WPAD_CLASSIC_BUTTON_A: u32 = 1048576;
pub const WPAD_CLASSIC_BUTTON_Y: u32 = 2097152;
pub const WPAD_CLASSIC_BUTTON_B: u32 = 4194304;
pub const WPAD_CLASSIC_BUTTON_ZL: u32 = 8388608;
pub const WPAD_CLASSIC_BUTTON_FULL_R: u32 = 33554432;
pub const WPAD_CLASSIC_BUTTON_PLUS: u32 = 67108864;
pub const WPAD_CLASSIC_BUTTON_HOME: u32 = 134217728;
pub const WPAD_CLASSIC_BUTTON_MINUS: u32 = 268435456;
pub const WPAD_CLASSIC_BUTTON_FULL_L: u32 = 536870912;
pub const WPAD_CLASSIC_BUTTON_DOWN: u32 = 1073741824;
pub const WPAD_CLASSIC_BUTTON_RIGHT: u32 = 2147483648;
pub const WPAD_GUITAR_HERO_3_BUTTON_STRUM_UP: u32 = 65536;
pub const WPAD_GUITAR_HERO_3_BUTTON_YELLOW: u32 = 524288;
pub const WPAD_GUITAR_HERO_3_BUTTON_GREEN: u32 = 1048576;
pub const WPAD_GUITAR_HERO_3_BUTTON_BLUE: u32 = 2097152;
pub const WPAD_GUITAR_HERO_3_BUTTON_RED: u32 = 4194304;
pub const WPAD_GUITAR_HERO_3_BUTTON_ORANGE: u32 = 8388608;
pub const WPAD_GUITAR_HERO_3_BUTTON_PLUS: u32 = 67108864;
pub const WPAD_GUITAR_HERO_3_BUTTON_MINUS: u32 = 268435456;
pub const WPAD_GUITAR_HERO_3_BUTTON_STRUM_DOWN: u32 = 1073741824;
pub const WPAD_ERR_NONE: u32 = 0;
pub const WPAD_ERR_NO_CONTROLLER: i32 = -1;
pub const WPAD_ERR_NOT_READY: i32 = -2;
pub const WPAD_ERR_TRANSFER: i32 = -3;
pub const WPAD_ERR_NONEREGISTERED: i32 = -4;
pub const WPAD_ERR_UNKNOWN: i32 = -5;
pub const WPAD_ERR_BAD_CHANNEL: i32 = -6;
pub const WPAD_ERR_QUEUE_EMPTY: i32 = -7;
pub const WPAD_ERR_BADVALUE: i32 = -8;
pub const WPAD_ERR_BADCONF: i32 = -9;
pub const WPAD_DATA_BUTTONS: u32 = 1;
pub const WPAD_DATA_ACCEL: u32 = 2;
pub const WPAD_DATA_EXPANSION: u32 = 4;
pub const WPAD_DATA_IR: u32 = 8;
pub const WPAD_ENC_FIRST: u32 = 0;
pub const WPAD_ENC_CONT: u32 = 1;
pub const WPAD_THRESH_IGNORE: i32 = -1;
pub const WPAD_THRESH_ANY: u32 = 0;
pub const WPAD_THRESH_DEFAULT_BUTTONS: u32 = 0;
pub const WPAD_THRESH_DEFAULT_IR: i32 = -1;
pub const WPAD_THRESH_DEFAULT_ACCEL: u32 = 20;
pub const WPAD_THRESH_DEFAULT_JOYSTICK: u32 = 2;
pub const WPAD_THRESH_DEFAULT_BALANCEBOARD: u32 = 60;
pub const WPAD_THRESH_DEFAULT_MOTION_PLUS: u32 = 100;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type sfp16 = s16;
pub type sfp32 = s32;
pub type ufp16 = u16_;
pub type ufp32 = u32_;
pub type f32_ = f32;
pub type f64_ = f64;
pub type vf32 = f32;
pub type vf64 = f64;
#[doc = "!\targv structure\n*!\t\\struct __argv\n\nstructure used to set up argc/argv\n\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __argv {
    #[doc = "!< argv magic number, set to 0x5f617267 ('_arg') if valid"]
    pub argvMagic: ::libc::c_int,
    #[doc = "!< base address of command line, set of null terminated strings"]
    pub commandLine: *mut ::libc::c_char,
    #[doc = "!< total length of command line"]
    pub length: ::libc::c_int,
    pub argc: ::libc::c_int,
    pub argv: *mut *mut ::libc::c_char,
    pub endARGV: *mut *mut ::libc::c_char,
}
extern "C" {
    #[doc = "!\tDefault location for the system argv structure."]
    pub static mut __system_argv: *mut __argv;
}
#[doc = "\\typedef struct _dsp_task dsptask_t\n\\brief forward typdef to struct _dsp_task. This struture holds certain DSP task information for execution."]
pub type dsptask_t = _dsp_task;
#[doc = " \\typedef void (*DSPTaskCallback)(dsptask_t *task)\n\\brief function pointer typedef for the user's DSP task callbacks\n\\param[in] task pointer to the dsp_task structure."]
pub type DSPTaskCallback = ::core::option::Option<unsafe extern "C" fn(task: *mut dsptask_t)>;
#[doc = " \\typedef void (*DSPCallback)(void)\n\\brief function pointer typedef for the user's DSP interrupt callback"]
pub type DSPCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " \\typedef struct _dsp_task dsptask_t\n\\param state current task \\ref dsp_taskstate \"state\" set\n\\param prio priority of the task\n\\param flags currnet task \\ref dsp_taskflag \"flag(s)\" set.\n\\param init_vec initialization vector. depends on the DSP code to execute.\n\\param resume_vec resume vector. depends on the DSP code to execute.\n\\param iram_maddr main memory address of i-ram image. NOTE: Has to be aligned on a 32byte boundery!\n\\param iram_len size of i-ram image. NOTE: Should be a multiple of 32\n\\param iram_addr DSP i-ram address to load the image to.\n\\param dram_maddr main memory address of d-ram image. NOTE: Has to be aligned on a 32byte boundery!\n\\param dram_len size of d-ram image. NOTE: Should be a multiple of 32\n\\param dram_addr DSP d-ram address to load the image to.\n\\param init_cb pointer to the user's init callback function. Called durring task initialization.\n\\param res_cb pointer to the user's resume callback function. Called when the task should resume.\n\\param done_cb pointer to the user's done callback function. Called when the task has finished.\n\\param req_cb pointer to the user's request callback function. Used to retrieve data from main application durring execution.\n\\param next pointer to the next task in the doubly linked list.\n\\param prev pointer to the previous task in the doubly linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dsp_task {
    pub state: vu32,
    pub prio: vu32,
    pub flags: vu32,
    pub iram_maddr: *mut ::libc::c_void,
    pub iram_len: u32_,
    pub iram_addr: u32_,
    pub dram_maddr: *mut ::libc::c_void,
    pub dram_len: u32_,
    pub dram_addr: u32_,
    pub init_vec: u16_,
    pub resume_vec: u16_,
    pub init_cb: DSPTaskCallback,
    pub res_cb: DSPTaskCallback,
    pub done_cb: DSPTaskCallback,
    pub req_cb: DSPTaskCallback,
    pub next: *mut _dsp_task,
    pub prev: *mut _dsp_task,
}
extern "C" {
    #[doc = " \\fn void DSP_Init(void)\n\\brief Initialize DSP subsystem.\n\n\\return none"]
    pub fn DSP_Init();
}
extern "C" {
    #[doc = " \\fn u32 DSP_CheckMailTo(void)\n\\brief Check if mail was sent to DSP\n\n\\return 1: mail sent, 0: mail on route"]
    pub fn DSP_CheckMailTo() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 DSP_CheckMailFrom(void)\n\\brief Check for mail from DSP\n\n\\return 1: has mail, 0: no mail"]
    pub fn DSP_CheckMailFrom() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 DSP_ReadMailFrom(void)\n\\brief Read mail from DSP\n\n\\return mail value received"]
    pub fn DSP_ReadMailFrom() -> u32_;
}
extern "C" {
    #[doc = " \\fn void DSP_AssertInt(void)\n\\brief Asserts the processor interface interrupt\n\n\\return none"]
    pub fn DSP_AssertInt();
}
extern "C" {
    #[doc = " \\fn void DSP_SendMailTo(u32 mail)\n\\brief Send mail to DSP\n\\param[in] mail value to send\n\n\\return none"]
    pub fn DSP_SendMailTo(mail: u32_);
}
extern "C" {
    #[doc = " \\fn u32 DSP_ReadCPUtoDSP(void)\n\\brief Read back CPU->DSP mailbox\n\n\\return mail value received"]
    pub fn DSP_ReadCPUtoDSP() -> u32_;
}
extern "C" {
    #[doc = " \\fn dsptask_t* DSP_AddTask(dsptask_t *task)\n\\brief Add a DSP task to the tasklist and start executing if necessary.\n\\param[in] task pointer to a dsptask_t structure which holds all necessary values for DSP task execution.\n\n\\return current task"]
    pub fn DSP_AddTask(task: *mut dsptask_t) -> *mut dsptask_t;
}
extern "C" {
    pub fn DSP_AssertTask(task: *mut dsptask_t) -> *mut dsptask_t;
}
extern "C" {
    pub fn DSP_CancelTask(task: *mut dsptask_t);
}
extern "C" {
    pub fn DSP_Reset();
}
extern "C" {
    pub fn DSP_Halt();
}
extern "C" {
    pub fn DSP_Unhalt();
}
extern "C" {
    pub fn DSP_GetDMAStatus() -> u32_;
}
extern "C" {
    #[doc = " \\fn DSPCallback DSP_RegisterCallback(DSPCallback usr_cb)\n\\brief Register an user's interrupt callback. This may be used to handle DSP interrupts on its own. By default a system default callback is installed on DSP_Init().\n\\param[in] user_cb pointer to the user's interrupt callback function.\n\\\n\\return pointer to old interrupt callback function."]
    pub fn DSP_RegisterCallback(usr_cb: DSPCallback) -> DSPCallback;
}
pub type BOOL = ::libc::c_uint;
#[doc = " \\typedef void (*ARCallback)(void)\n \\brief function pointer typedef for the user's ARAM interrupt callback\n\n \\param none"]
pub type ARCallback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\fn ARCallback AR_RegisterCallback(ARCallback callback)\n \\brief Register the given function as a DMA callback\n\n        Any existing callback is replaced unconditionally\n\n \\param[in] callback to be invoked upon completion of DMA transaction\n\n \\return pointer to the previously registered callback and NULL respectively"]
    pub fn AR_RegisterCallback(callback: ARCallback) -> ARCallback;
}
extern "C" {
    #[doc = " \\fn u32 AR_GetDMAStatus(void)\n \\brief Get current status of DMA\n\n \\return zero if DMA is idle, non-zero if a DMA is in progress"]
    pub fn AR_GetDMAStatus() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 AR_Init(u32 *stack_idx_array,u32 num_entries)\n \\brief Initializes ARAM subsystem.\n\n        Following tasks are performed:\n\n      - Disables ARAM DMA\n      - Sets DMA callback to NULL\n      - Initializes ARAM controller\n      - Determines size of ARAM memory\n      - Initializes the ARAM stack based memory allocation system<br>\n\n        The parameter u32 *stack_idx_array points to an array of u32 integers. The parameter u32 num_entries specifies the number of entries in this array.<br>\n        The user application is responsible for determining how many ARAM blocks the device driver can allocate.<br>\n\n        As an example, consider:\n \\code\n        #define MAX_NUM_BLOCKS 10\n\n        u32 aram_blocks[MAX_NUM_BLOCKS];\n        ...\n        void func(void)\n        {\n           AR_Init(aram_blocks, MAX_NUM_BLOCKS);\n        }\n \\endcode\n\n        Here, we are telling AR that the application will allocate, at most, 10 blocks (of arbitrary size), and that AR should store addresses for those blocks in the array aram_blocks. Note that the array is simply storage supplied by the application so that AR can track the number and size of memory blocks allocated by AR_Alloc().\n        AR_Free()also uses this array to release blocks.<br>\n        If you do not wish to use AR_Alloc() and AR_Free() and would rather manage ARAM usage within your application, then call AR_Init() like so:<br>\n\n               AR_Init(NULL, 0);<br>\n\n        The AR_Init() function also calculates the total size of the ARAM aggregate. Note that this procedure is <b><i>destructive</i></b> - i.e., any data stored in ARAM will be corrupted.<br>\n        AR_Init()may be invoked multiple times. This function checks the state of an initialization flag; if asserted, this function will simply exit on subsequent calls. To perform another initialization of the ARAM driver, call AR_Reset() before invoking AR_Init() again.\n\n \\param[in] stack_idx_array pointer to an array of u32 integer\n \\param[in] num_entries number of entries in the specified array\n\n \\return base address of the \"user\" ARAM area. As of this writing, the operating system reserves the bottom 16 KB of ARAM. Therefore, AR_Init() returns 0x04000 to indicate the starting location of the ARAM user area."]
    pub fn AR_Init(stack_idx_array: *mut u32_, num_entries: u32_) -> u32_;
}
extern "C" {
    #[doc = " \\fn void AR_StartDMA(u32 dir,u32 memaddr,u32 aramaddr,u32 len)\n \\brief Initiates a DMA between main memory and ARAM.\n\n        This function:\n\n      - Does <b><i>not</i></b> perform boundery-checking on addresses and lengths.\n      - Will assert failure if a DMA is allready in progress.\n      - Is provided for debugging purpose. Application programmers must use the ARQ API in order to access ARAM.\n\n \\param[in] dir specifies the \\ref dmamode \"direction\" of transfer.\n \\param[in] memaddr specifies main memory address for the transfer\n \\param[in] aramaddr specifies the ARAM address for the transfer. <b><i>NOTE:</i></b> Addresses are 27bits wide and refer to bytes\n \\param[in] len specifies the length of the block to transfer. <b><i>NOTE:</i></b> Must be in bytes and a multiple of 32\n\n \\return none"]
    pub fn AR_StartDMA(dir: u32_, memaddr: u32_, aramaddr: u32_, len: u32_);
}
extern "C" {
    #[doc = " \\fn u32 AR_Alloc(u32 len)\n \\brief Allocate a block of memory from ARAM having <i>len</i> bytes.\n\n        The <i>len</i> parameter <b><i>must</i></b> be a multiple of 32\n\n \\param[in] len length of the specified block of memory in ARAM\n\n \\return address of the block if successful, otherwise NULL"]
    pub fn AR_Alloc(len: u32_) -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 AR_Free(u32 *len)\n \\brief Free a block from ARAM\n\n \\param[out] len pointer to receive the length of the free'd ARAM block. This is optional and can be NULL.\n\n \\return ARAM current baseaddress after free'ing the block"]
    pub fn AR_Free(len: *mut u32_) -> u32_;
}
extern "C" {
    #[doc = " \\fn void AR_Clear(u32 flag)\n \\brief Clear ARAM memory\n\n \\param[in] flag specifies the region of ARAM to clear\n\n \\return none"]
    pub fn AR_Clear(flag: u32_);
}
extern "C" {
    #[doc = " \\fn BOOL AR_CheckInit(void)\n \\brief Get the ARAM subsystem initialization flag\n\n \\return TRUE if the ARAM subsystem has been initialized(via AR_Init())<br>\n         FALSE if the ARAM subsystem has not been initialized, or has been reset(via AR_Reset())"]
    pub fn AR_CheckInit() -> BOOL;
}
extern "C" {
    #[doc = " \\fn void AR_Reset(void)\n \\brief Clears the ARAM subsystem initialization flag.\n\n        Calling AR_Init() after this function will cause a \"real\" initialization of ARAM\n\n \\return none"]
    pub fn AR_Reset();
}
extern "C" {
    #[doc = " \\fn u32 AR_GetSize(void)\n \\brief Get the total size - in bytes - of ARAM as calculated during AR_Init()\n\n \\return size of the specified ARAM block"]
    pub fn AR_GetSize() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 AR_GetBaseAddress(void)\n \\brief Get the baseaddress of ARAM memory\n\n \\return ARAM memory baseaddress"]
    pub fn AR_GetBaseAddress() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 AR_GetInternalSize(void)\n \\brief Get the size of the internal ARAM memory\n\n \\return ARAM internal memory size"]
    pub fn AR_GetInternalSize() -> u32_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwpnode {
    pub next: *mut _lwpnode,
    pub prev: *mut _lwpnode,
}
pub type lwp_node = _lwpnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwpqueue {
    pub first: *mut lwp_node,
    pub perm_null: *mut lwp_node,
    pub last: *mut lwp_node,
}
pub type lwp_queue = _lwpqueue;
extern "C" {
    pub fn __lwp_queue_initialize(
        arg1: *mut lwp_queue,
        arg2: *mut ::libc::c_void,
        arg3: u32_,
        arg4: u32_,
    );
}
extern "C" {
    pub fn __lwp_queue_get(arg1: *mut lwp_queue) -> *mut lwp_node;
}
extern "C" {
    pub fn __lwp_queue_append(arg1: *mut lwp_queue, arg2: *mut lwp_node);
}
extern "C" {
    pub fn __lwp_queue_extract(arg1: *mut lwp_node);
}
extern "C" {
    pub fn __lwp_queue_insert(arg1: *mut lwp_node, arg2: *mut lwp_node);
}
pub const ARQ_TASK_READY: _bindgen_ty_1 = 0;
pub const ARQ_TASK_RUNNING: _bindgen_ty_1 = 1;
pub const ARQ_TASK_FINISHED: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::libc::c_uint;
pub type ARQRequest = _arq_request;
pub type ARQCallback = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ARQRequest)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _arq_request {
    pub node: lwp_node,
    pub owner: u32_,
    pub dir: u32_,
    pub prio: u32_,
    pub state: u32_,
    pub aram_addr: u32_,
    pub mram_addr: u32_,
    pub len: u32_,
    pub callback: ARQCallback,
}
extern "C" {
    pub fn ARQ_Init();
}
extern "C" {
    pub fn ARQ_Reset();
}
extern "C" {
    #[doc = " \\fn void ARQ_PostRequest(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len)\n \\brief Enqueue a ARAM DMA transfer request.\n\n \\param[in] req structure to hold ARAM DMA request informations.\n \\param[in] owner unique owner id.\n \\param[in] dir direction of ARAM DMA transfer.\n \\param[in] prio priority of request.\n \\param[in] aram_addr startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n \\param[in] mram_addr length of data to be pushed onto the queue.\n \\param[in] len startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n \\param[in] cb length of data to be pushed onto the queue.\n\n \\return none"]
    pub fn ARQ_PostRequest(
        req: *mut ARQRequest,
        owner: u32_,
        dir: u32_,
        prio: u32_,
        aram_addr: u32_,
        mram_addr: u32_,
        len: u32_,
    );
}
extern "C" {
    #[doc = " \\fn void ARQ_PostRequestAsync(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len,ARQCallback cb)\n \\brief Enqueue a ARAM DMA transfer request.\n\n \\param[in] req structure to hold ARAM DMA request informations.\n \\param[in] owner unique owner id.\n \\param[in] dir direction of ARAM DMA transfer.\n \\param[in] prio priority of request.\n \\param[in] aram_addr startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n \\param[in] mram_addr length of data to be pushed onto the queue.\n \\param[in] len startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n \\param[in] cb length of data to be pushed onto the queue.\n\n \\return none"]
    pub fn ARQ_PostRequestAsync(
        req: *mut ARQRequest,
        owner: u32_,
        dir: u32_,
        prio: u32_,
        aram_addr: u32_,
        mram_addr: u32_,
        len: u32_,
        cb: ARQCallback,
    );
}
extern "C" {
    pub fn ARQ_RemoveRequest(req: *mut ARQRequest);
}
extern "C" {
    pub fn ARQ_SetChunkSize(size: u32_);
}
extern "C" {
    pub fn ARQ_GetChunkSize() -> u32_;
}
extern "C" {
    pub fn ARQ_FlushQueue();
}
extern "C" {
    pub fn ARQ_RemoveOwnerRequest(owner: u32_) -> u32_;
}
#[doc = " \\typedef void (*ARQMCallback)(s32 result)\n \\brief function pointer typedef for the user's callback when an ARAM operation has completed\n \\param[in] result The result of the ARAM operation."]
pub type ARQMCallback = ::core::option::Option<unsafe extern "C" fn(result: s32)>;
extern "C" {
    #[doc = " \\fn void ARQM_Init(u32 arambase,s32 len)\n \\brief Initialize the ARAM queue management system\n\n \\param[in] arambase ARAM startaddress to take for the queue stack\n \\param[in] len maximum amount of memory to be reserved from the ARAM for the queue management\n\n \\return none"]
    pub fn ARQM_Init(arambase: u32_, len: s32);
}
extern "C" {
    #[doc = " \\fn u32 ARQM_PushData(void *buffer,s32 len)\n \\brief Push the data onto the ARAM queue\n\n \\param[in] buffer starting address of a buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32 byte aligned.\n \\param[in] len length of data to be pushed onto the queue.\n\n \\return The ARAM starting address for the pushed data."]
    pub fn ARQM_PushData(buffer: *mut ::libc::c_void, len: s32) -> u32_;
}
extern "C" {
    pub fn ARQM_Pop();
}
extern "C" {
    #[doc = " \\fn u32 ARQM_GetZeroBuffer(void)\n \\brief Returns ARAM address of 'zero buffer'\n\n \\return See description"]
    pub fn ARQM_GetZeroBuffer() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 ARQM_GetStackPointer(void)\n \\brief Return the ARAM address of the next free stack pointer\n\n \\return See description"]
    pub fn ARQM_GetStackPointer() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 ARQM_GetFreeSize(void)\n \\brief Return Returns remaining number of bytes on stack\n\n \\return See description"]
    pub fn ARQM_GetFreeSize() -> u32_;
}
#[doc = " \\typedef void (*AIDCallback)(void)\n \\brief function pointer typedef for the user's Audio DMA interrupt callback\n\n \\param none"]
pub type AIDCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " \\typedef void (*AISCallback)(u32 smp_cnt)\n \\brief function pointer typedef for the user's Audio Streaming interrupt callback\n\n \\param smp_cnt AI sample count"]
pub type AISCallback = ::core::option::Option<unsafe extern "C" fn(smp_cnt: u32_)>;
extern "C" {
    #[doc = " \\fn AISCallback AUDIO_RegisterStreamCallback(AISCallback callback)\n \\brief Register a user callback function for the AUDIO streaming interface\n\n \\param[in] callback pointer to the function which to call when AIS interrupt has triggered.\n\n \\return pointer to old callback function or NULL respectively."]
    pub fn AUDIO_RegisterStreamCallback(callback: AISCallback) -> AISCallback;
}
extern "C" {
    #[doc = " \\fn void AUDIO_Init(u8 *stack)\n \\brief Initialize the AUDIO subsystem\n\n \\param[in] stack pointer to a memory area to work as stack when calling the callbacks. May be NULL\n\n \\return none"]
    pub fn AUDIO_Init(stack: *mut u8_);
}
extern "C" {
    #[doc = " \\fn void AUDIO_SetStreamVolLeft(u8 vol)\n \\brief Set streaming volume on the left channel.\n\n \\param[in] vol level of volume 0<= vol <=255\n\n \\return none"]
    pub fn AUDIO_SetStreamVolLeft(vol: u8_);
}
extern "C" {
    #[doc = " \\fn u8 AUDIO_GetStreamVolLeft(void)\n \\brief Get streaming volume of the left channel.\n\n \\return level of volume."]
    pub fn AUDIO_GetStreamVolLeft() -> u8_;
}
extern "C" {
    #[doc = " \\fn void AUDIO_SetStreamVolRight(u8 vol)\n \\brief set streaming volume of the right channel.\n\n \\param[in] vol level of volume 0<= vol <=255\n\n \\return none"]
    pub fn AUDIO_SetStreamVolRight(vol: u8_);
}
extern "C" {
    #[doc = " \\fn u8 AUDIO_GetStreamVolRight(void)\n \\brief Get streaming volume of the right channel.\n\n \\return level of volume."]
    pub fn AUDIO_GetStreamVolRight() -> u8_;
}
extern "C" {
    #[doc = " \\fn void AUDIO_SetStreamSampleRate(u32 rate)\n \\brief Set streaming sample rate\n\n \\param[in] rate streaming \\ref ai_sample_rates \"sample rate\"\n\n \\return none"]
    pub fn AUDIO_SetStreamSampleRate(rate: u32_);
}
extern "C" {
    #[doc = " \\fn u32 AUDIO_GetStreamSampleRate(void)\n \\brief Get streaming sample rate\n\n \\return \\ref ai_sample_rates \"sample rate\""]
    pub fn AUDIO_GetStreamSampleRate() -> u32_;
}
extern "C" {
    #[doc = " \\fn AIDCallback AUDIO_RegisterDMACallback(AIDCallback callback)\n \\brief Register a user callback function for the audio DMA interface.\n\n        This callback will be called whenever the audio DMA requests new data.<br>\n        Internally the DMA buffers are double buffered.\n\n \\param[in] callback pointer to the function which to call when AID interrupt has triggered.\n\n \\return pointer to old callback function or NULL respectively."]
    pub fn AUDIO_RegisterDMACallback(callback: AIDCallback) -> AIDCallback;
}
extern "C" {
    #[doc = " \\fn void AUDIO_InitDMA(u32 startaddr,u32 len)\n \\brief Initialize an audio DMA transfer\n\n \\param[in] startaddr start address of the memory region to load into the audio DMA. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery!\n \\param[in] len lenght of data to load into the audio DMA. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn AUDIO_InitDMA(startaddr: u32_, len: u32_);
}
extern "C" {
    #[doc = " \\fn u16 AUDIO_GetDMAEnableFlag(void)\n \\brief Get the audio DMA flag\n\n \\return state of the current DMA operation."]
    pub fn AUDIO_GetDMAEnableFlag() -> u16_;
}
extern "C" {
    #[doc = " \\fn void AUDIO_StartDMA(void)\n \\brief Start the audio DMA operation.\n\n        Starts to transfer the data from main memory to the audio interface thru DMA.<br>\n        This call should follow the call to AUDIO_InitDMA() which is used to initialize DMA transfers.\n\n \\return none"]
    pub fn AUDIO_StartDMA();
}
extern "C" {
    #[doc = " \\fn void AUDIO_StopDMA(void)\n \\brief Stop the previously started audio DMA operation.\n\n \\return none"]
    pub fn AUDIO_StopDMA();
}
extern "C" {
    #[doc = " \\fn u32 AUDIO_GetDMABytesLeft(void)\n \\brief Get the count of bytes, left to play, from the audio DMA interface\n\n \\return count of bytes left to play."]
    pub fn AUDIO_GetDMABytesLeft() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 AUDIO_GetDMALength(void)\n \\brief Get the DMA transfer length configured in the audio DMA interface.\n\n \\return length of data loaded into the audio DMA interface."]
    pub fn AUDIO_GetDMALength() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 AUDIO_GetDMAStartAddr(void)\n \\brief Get the main memory address for the DMA operation.\n\n \\return start address of mainmemory loaded into the audio DMA interface."]
    pub fn AUDIO_GetDMAStartAddr() -> u32_;
}
extern "C" {
    #[doc = " \\fn void AUDIO_SetStreamTrigger(u32 cnt)\n \\brief Set the sample count for the stream trigger\n\n \\param[in] cnt count of samples when to trigger the audio stream.\n\n \\return none"]
    pub fn AUDIO_SetStreamTrigger(cnt: u32_);
}
extern "C" {
    #[doc = " \\fn void AUDIO_ResetStreamSampleCnt(void)\n \\brief Reset the stream sample count register.\n\n \\return none"]
    pub fn AUDIO_ResetStreamSampleCnt();
}
extern "C" {
    #[doc = " \\fn void AUDIO_SetDSPSampleRate(u8 rate)\n \\brief Set the sampling rate for the DSP interface\n\n \\param[in] rate sampling rate to set for the DSP (AI_SAMPLERATE_32KHZ,AI_SAMPLERATE_48KHZ)\n\n \\return none"]
    pub fn AUDIO_SetDSPSampleRate(rate: u8_);
}
extern "C" {
    #[doc = " \\fn u32 AUDIO_GetDSPSampleRate(void)\n \\brief Get the sampling rate for the DSP interface\n\n \\return DSP sampling rate (AI_SAMPLERATE_32KHZ,AI_SAMPLERATE_48KHZ)"]
    pub fn AUDIO_GetDSPSampleRate() -> u32_;
}
extern "C" {
    #[doc = " \\fn void AUDIO_SetStreamPlayState(u32 state)\n \\brief Set the play state for the streaming audio interface\n\n \\param[in] state playstate of the streaming audio interface (AI_STREAM_STOP,AI_STREAM_START)\n\n \\return none"]
    pub fn AUDIO_SetStreamPlayState(state: u32_);
}
extern "C" {
    #[doc = " \\fn u32 AUDIO_GetStreamPlayState(void)\n \\brief Get the play state from the streaming audio interface\n\n \\return playstate (AI_STREAM_STOP,AI_STREAM_START)"]
    pub fn AUDIO_GetStreamPlayState() -> u32_;
}
extern "C" {
    #[doc = " \\fn void DCEnable(void)\n \\brief Enable L1 d-cache\n\n \\return none"]
    pub fn DCEnable();
}
extern "C" {
    #[doc = " \\fn void DCDisable(void)\n \\brief Disable L1 d-cache\n\n \\return none"]
    pub fn DCDisable();
}
extern "C" {
    #[doc = " \\fn void DCFreeze(void)\n \\brief Current contents of the L1 d-cache are locked down and will not be cast out.\n\n        Hits are still serviced, but misses go straight to L2 or 60x bus.  Most cache operations, such as DCFlushRange(), will still execute regardless of whether the cache is frozen.<br>\n\t      <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache.  We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n \\return none"]
    pub fn DCFreeze();
}
extern "C" {
    #[doc = " \\fn void DCUnfreeze(void)\n \\brief Undoes actions of DCFreeze().\n\n        Old cache blocks will now be cast out on subsequent L1 misses.<br>\n \t      <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache.  We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n \\return none"]
    pub fn DCUnfreeze();
}
extern "C" {
    #[doc = " \\fn void DCFlashInvalidate(void)\n \\brief Invalidate L1 d-cache.\n\n        An invalidate operation is issued that marks the state of each data cache block as invalid without writing back modified cache blocks to memory.<br>\n        Cache access is blocked during this time.Bus accesses to the cache are signaled as a miss during invalidate-all operations.\n\n \\return none"]
    pub fn DCFlashInvalidate();
}
extern "C" {
    #[doc = " \\fn void DCInvalidateRange(void *startaddress,u32 len)\n \\brief Invalidates a given range of the d-cache.\n\n        If any part of the range hits in the d-cache, the corresponding block will be invalidated.\n\n \\param[in] startaddress pointer to the startaddress of the memory range to invalidate. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of the range to invalidate. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn DCInvalidateRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void DCFlushRange(void *startaddress,u32 len)\n \\brief Flushes a given range.\n\n        If any part of the range hits in the d-cache the corresponding block will be flushed to main memory and invalidated.<br>\n        <b><i>NOTE:</i></b> This function invokes a \"sync\" after flushing the range. This means the function will stall until the CPU knows that the data has been writen to main memory\n\n \\param[in] startaddress pointer to the startaddress of the memory range to flush. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of range to be flushed. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n\\return none"]
    pub fn DCFlushRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void DCStoreRange(void *startaddress,u32 len)\n \\brief Ensures a range of memory is updated with any modified data in the cache.\n\n        <b><i>NOTE:</i></b> This function invokes a \"sync\" after storing the range. This means the function will stall until the CPU knows that the data has been writen to main memory\n\n \\param[in] startaddress pointer to the startaddress of the memory range to store. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of the range to store. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn DCStoreRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void DCFlushRangeNoSync(void *startaddress,u32 len)\n \\brief Flushes a given range.\n\n        If any part of the range hits in the d-cache the corresponding block will be flushed to main memory and invalidated.<br>\n        <b><i>NOTE:</i></b> This routine does not perform a \"sync\" to ensure that the range has been flushed to memory.  That is, the cache blocks are sent to the bus interface unit for storage to main memory, but by the time this function returns, you are not guaranteed that the blocks have been written to memory.\n\n \\param[in] startaddress pointer to the startaddress of the memory range to flush. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of range to be flushed. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn DCFlushRangeNoSync(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void DCStoreRangeNoSync(void *startaddress,u32 len)\n \\brief Ensures a range of memory is updated with any modified data in the cache.\n\n        <b><i>NOTE:</i></b> This routine does not perform a \"sync\" to ensure that the range has been flushed to memory.  That is, the cache blocks are sent to the bus interface unit for storage to main memory, but by the time this function returns, you are not guaranteed that the blocks have been written to memory\n\n \\param[in] startaddress pointer to the startaddress of the memory range to store. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of the range to store. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn DCStoreRangeNoSync(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void DCZeroRange(void *startaddress,u32 len)\n \\brief Loads a range of memory into cache and zeroes all the cache lines.\n\n \\param[in] startaddress pointer to the startaddress of the memory range to load/zero. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of the range to load/zero. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn DCZeroRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void DCTouchRange(void *startaddress,u32 len)\n \\brief Loads a range of memory into cache.\n\n \\param[in] startaddress pointer to the startaddress of the memory range to load. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of the range to load. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn DCTouchRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = " \\fn void ICSync(void)\n \\brief Performs an instruction cache synchronization.\n\n        This ensures that all instructions preceding this instruction have completed before this instruction completes.\n\n \\return none"]
    pub fn ICSync();
}
extern "C" {
    #[doc = " \\fn void ICFlashInvalidate(void)\n \\brief Invalidate the L1 i-cache.\n\n        An invalidate operation is issued that marks the state of each instruction cache block as invalid without writing back modified cache blocks to memory.<br>\n        Cache access is blocked during this time. Bus accesses to the cache are signaled as a miss during invalidate-all operations.\n\n \\return none"]
    pub fn ICFlashInvalidate();
}
extern "C" {
    #[doc = " \\fn void ICEnable(void)\n \\brief Enable L1 i-cache\n\n \\return none"]
    pub fn ICEnable();
}
extern "C" {
    #[doc = " \\fn void ICDisable(void)\n \\brief Disable L1 i-cache\n\n \\return none"]
    pub fn ICDisable();
}
extern "C" {
    #[doc = " \\fn void ICFreeze(void)\n \\brief Current contents of the L1 i-cache are locked down and will not be cast out.\n\n        Hits are still serviced, but misses go straight to L2 or 60x bus.<br>\n\t      <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache.  We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n \\return none"]
    pub fn ICFreeze();
}
extern "C" {
    #[doc = " \\fn void ICUnfreeze(void)\n \\brief Undoes actions of ICFreeze().\n\n        Old cache blocks will now be cast out on subsequent L1 misses.<br>\n\t      <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache.  We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n \\return none"]
    pub fn ICUnfreeze();
}
extern "C" {
    #[doc = " \\fn void ICBlockInvalidate(void *startaddress)\n \\brief Invalidates a block in the i-cache.\n\n        If the block hits in the i-cache, the corresponding block will be invalidated.\n\n \\param[in] startaddress pointer to the startaddress of the memory block to invalidate. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n\n\\return none"]
    pub fn ICBlockInvalidate(startaddress: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " \\fn void ICInvalidateRange(void *startaddress,u32 len)\n \\brief Invalidate a range in the L1 i-cache.\n\n        If any part of the range hits in the i-cache, the corresponding block will be invalidated.\n\n \\param[in] startaddress pointer to the startaddress of the memory range to invalidate. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n \\param[in] len length of the range to invalidate. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n \\return none"]
    pub fn ICInvalidateRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    pub fn L2Enhance();
}
extern "C" {
    pub fn LCEnable();
}
extern "C" {
    pub fn LCDisable();
}
extern "C" {
    pub fn LCLoadBlocks(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_);
}
extern "C" {
    pub fn LCStoreBlocks(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_);
}
extern "C" {
    pub fn LCLoadData(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_) -> u32_;
}
extern "C" {
    pub fn LCStoreData(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_) -> u32_;
}
extern "C" {
    pub fn LCQueueLength() -> u32_;
}
extern "C" {
    pub fn LCQueueWait(arg1: u32_) -> u32_;
}
extern "C" {
    pub fn LCFlushQueue();
}
extern "C" {
    pub fn LCAlloc(arg1: *mut ::libc::c_void, arg2: u32_);
}
extern "C" {
    pub fn LCAllocNoInvalidate(arg1: *mut ::libc::c_void, arg2: u32_);
}
extern "C" {
    pub fn LCAllocOneTag(arg1: BOOL, arg2: *mut ::libc::c_void);
}
extern "C" {
    pub fn LCAllocTags(arg1: BOOL, arg2: *mut ::libc::c_void, arg3: u32_);
}
#[doc = " \\typedef struct _card_file card_file\n\\brief structure to hold the fileinformations upon open and for later use.\n\\param chn CARD slot.\n\\param filenum file index in the card directory structure.\n\\param offset offset into the file.\n\\param len length of file.\n\\param iblock block index on memory card."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_file {
    pub chn: s32,
    pub filenum: s32,
    pub offset: s32,
    pub len: s32,
    pub iblock: u16_,
}
#[doc = " \\typedef struct _card_file card_file\n\\brief structure to hold the fileinformations upon open and for later use.\n\\param chn CARD slot.\n\\param filenum file index in the card directory structure.\n\\param offset offset into the file.\n\\param len length of file.\n\\param iblock block index on memory card."]
pub type card_file = _card_file;
#[doc = " \\typedef struct card_dir\n\\brief structure to hold the information of a directory entry\n\\param chn CARD slot.\n\\param fileno file index in the card directory structure.\n\\param filelen length of file.\n\\param filename[CARD_FILENAMELEN] name of the file on card.\n\\param gamecode[4] string identifier <=4.\n\\param company[2] string identifier <=2.\n\\param showall boolean flag whether to showall entries or ony those identified by card_gamecode and card_company, previously set within the call to CARD_Init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_dir {
    pub chn: s32,
    pub fileno: u32_,
    pub filelen: u32_,
    pub permissions: u8_,
    pub filename: [::libc::c_char; 32usize],
    pub gamecode: [u8_; 4usize],
    pub company: [u8_; 2usize],
    pub showall: bool,
}
#[doc = " \\typedef struct card_dir\n\\brief structure to hold the information of a directory entry\n\\param chn CARD slot.\n\\param fileno file index in the card directory structure.\n\\param filelen length of file.\n\\param filename[CARD_FILENAMELEN] name of the file on card.\n\\param gamecode[4] string identifier <=4.\n\\param company[2] string identifier <=2.\n\\param showall boolean flag whether to showall entries or ony those identified by card_gamecode and card_company, previously set within the call to CARD_Init()"]
pub type card_dir = _card_dir;
#[doc = " \\typedef struct card_direntry\n\\brief structure to hold the information of the save file entry ( aka GCI )\n\\param gamecode[4] string identifier <=4.\n\\param company[2] string identifier <=2.\n\\param padding always 0xFF.\n\\param banner_fmt format of banner.\n\\param filename[CARD_FILENAMELEN] name of the file on card.\n\\param last_modified last time it was modified,in seconds since 1970 in seconds.\n\\param icon_addr icon image address in file.\n\\param icon_fmt icon image format.\n\\param icon_speed speed of an animated icon.\n\\param permission permissions of the save file.\n\\param copy_times how many times the save file has been copied.\n\\param block starting block of the save file.\n\\param length size of the save file..\n\\param padding always 0xFFFF.\n\\param comment_addr address in file of the comment block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_direntry {
    pub gamecode: [u8_; 4usize],
    pub company: [u8_; 2usize],
    pub pad_00: u8_,
    pub banner_fmt: u8_,
    pub filename: [u8_; 32usize],
    pub last_modified: u32_,
    pub icon_addr: u32_,
    pub icon_fmt: u16_,
    pub icon_speed: u16_,
    pub permission: u8_,
    pub copy_times: u8_,
    pub block: u16_,
    pub length: u16_,
    pub pad_01: u16_,
    pub comment_addr: u32_,
}
#[doc = " \\typedef struct card_direntry\n\\brief structure to hold the information of the save file entry ( aka GCI )\n\\param gamecode[4] string identifier <=4.\n\\param company[2] string identifier <=2.\n\\param padding always 0xFF.\n\\param banner_fmt format of banner.\n\\param filename[CARD_FILENAMELEN] name of the file on card.\n\\param last_modified last time it was modified,in seconds since 1970 in seconds.\n\\param icon_addr icon image address in file.\n\\param icon_fmt icon image format.\n\\param icon_speed speed of an animated icon.\n\\param permission permissions of the save file.\n\\param copy_times how many times the save file has been copied.\n\\param block starting block of the save file.\n\\param length size of the save file..\n\\param padding always 0xFFFF.\n\\param comment_addr address in file of the comment block."]
pub type card_direntry = _card_direntry;
#[doc = " \\typedef struct card_stat\n\\brief structure to hold the additional statistical informations.\n\\param filename[CARD_FILENAMELEN] name of the file on card.\n\\param len length of file.\n\\param gamecode[4] string identifier <=4.\n\\param company[2] string identifier <=2.\n\\param banner_fmt format of banner.\n\\param icon_addr icon image address in file.\n\\param icon_fmt icon image format.\n\\param icon_speed speed of an animated icon.\n\\param comment_addr address in file of the comment block.\n\\param offset_banner offset in file to the banner's image data.\n\\param offset_banner_tlut offset in file to the banner's texture lookup table.\n\\param offset_icon[CARD_MAXICONS] array of offsets in file to the icon's image data <CARD_MAXICONS.\n\\param offset_icon_tlut offset in file to the icons's texture lookup table.\n\\param offset_data offset to additional data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_stat {
    pub filename: [::libc::c_char; 32usize],
    pub len: u32_,
    pub time: u32_,
    pub gamecode: [u8_; 4usize],
    pub company: [u8_; 2usize],
    pub banner_fmt: u8_,
    pub icon_addr: u32_,
    pub icon_fmt: u16_,
    pub iconfmt: [u16_; 8usize],
    pub icon_speed: u16_,
    pub iconspeed: [u16_; 8usize],
    pub comment_addr: u32_,
    pub offset_banner: u32_,
    pub offset_banner_tlut: u32_,
    pub offset_icon: [u32_; 8usize],
    pub offset_icon_tlut: [u32_; 8usize],
    pub offset_data: u32_,
}
#[doc = " \\typedef struct card_stat\n\\brief structure to hold the additional statistical informations.\n\\param filename[CARD_FILENAMELEN] name of the file on card.\n\\param len length of file.\n\\param gamecode[4] string identifier <=4.\n\\param company[2] string identifier <=2.\n\\param banner_fmt format of banner.\n\\param icon_addr icon image address in file.\n\\param icon_fmt icon image format.\n\\param icon_speed speed of an animated icon.\n\\param comment_addr address in file of the comment block.\n\\param offset_banner offset in file to the banner's image data.\n\\param offset_banner_tlut offset in file to the banner's texture lookup table.\n\\param offset_icon[CARD_MAXICONS] array of offsets in file to the icon's image data <CARD_MAXICONS.\n\\param offset_icon_tlut offset in file to the icons's texture lookup table.\n\\param offset_data offset to additional data."]
pub type card_stat = _card_stat;
#[doc = " \\typedef void (*cardcallback)(s32 chan,s32 result)\n\\brief function pointer typedef for the user's operation callback\n\\param chan CARD slot\n\\param result result of operation upon call of callback."]
pub type cardcallback = ::core::option::Option<unsafe extern "C" fn(chan: s32, result: s32)>;
extern "C" {
    #[doc = " \\fn s32 CARD_Init(const char *gamecode,const char *company)\n\\brief Performs the initialization of the memory card subsystem\n\\param[in] gamecode pointer to a 4byte long string to specify the vendors game code. May be NULL\n\\param[in] company pointer to a 2byte long string to specify the vendors company code. May be NULL\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Init(gamecode: *const ::libc::c_char, company: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Probe(s32 chn)\n\\brief Performs a check against the desired EXI channel if a device is inserted\n\\param[in] chn CARD slot\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Probe(chn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_ProbeEx(s32 chn,s32 *mem_size,s32 *sect_size)\n\\brief Performs a check against the desired EXI channel if a memory card is inserted or mounted\n\\param[in] chn CARD slot\n\\param[out] mem_size pointer to a integer variable, ready to take the resulting value (this param is optional and can be NULL)\n\\param[out] sect_size pointer to a integer variable, ready to take the resulting value (this param is optional and can be NULL)\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_ProbeEx(chn: s32, mem_size: *mut s32, sect_size: *mut s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Mount(s32 chn,void *workarea,cardcallback detach_cb)\n\\brief Mounts the memory card in the slot CHN. Synchronous version.\n\\param[in] chn CARD slot\n\\param[in] workarea pointer to memory area to hold the cards system area. The startaddress of the workdarea should be aligned on a 32byte boundery\n\\param[in] detach_cb pointer to a callback function. This callback function will be called when the card is removed from the slot.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Mount(chn: s32, workarea: *mut ::libc::c_void, detach_cb: cardcallback) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_MountAsync(s32 chn,void *workarea,cardcallback detach_cb,cardcallback attach_cb)\n\\brief Mounts the memory card in the slot CHN. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot\n\\param[in] workarea pointer to memory area to hold the cards system area. The startaddress of the workdarea should be aligned on a 32byte boundery\n\\param[in] detach_cb pointer to a callback function. This callback function will be called when the card is removed from the slot.\n\\param[in] attach_cb pointer to a callback function. This callback function will be called when the mount process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_MountAsync(
        chn: s32,
        workarea: *mut ::libc::c_void,
        detach_cb: cardcallback,
        attach_cb: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Unmount(s32 chn)\n\\brief Unmounts the memory card in the slot CHN and releases the EXI bus.\n\\param[in] chn CARD slot\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Unmount(chn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Read(card_file *file,void *buffer,u32 len,u32 offset)\n\\brief Reads the data from the file into the buffer from the given offset with the given length. Synchronous version\n\\param[in] file pointer to the card_file structure. It holds the fileinformations to read from.\n\\param[out] buffer pointer to memory area read-in the data. The startaddress of the buffer should be aligned to a 32byte boundery.\n\\param[in] len length of data to read.\n\\param[in] offset offset into the file to read from.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Read(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_ReadAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback)\n\\brief Reads the data from the file into the buffer from the given offset with the given length. This function returns immediately. Asynchronous version\n\\param[in] file pointer to the card_file structure. It holds the fileinformations to read from.\n\\param[out] buffer pointer to memory area read-in the data. The startaddress of the buffer should be aligned to a 32byte boundery.\n\\param[in] len length of data to read.\n\\param[in] offset offset into the file to read from.\n\\param[in] callback pointer to a callback function. This callback will be called when the read process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_ReadAsync(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Open(s32 chn,const char *filename,card_file *file)\n\\brief Opens the file with the given filename and fills in the fileinformations.\n\\param[in] chn CARD slot\n\\param[in] filename name of the file to open.\n\\param[out] file pointer to the card_file structure. It receives the fileinformations for later usage.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Open(chn: s32, filename: *const ::libc::c_char, file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_OpenEntry(s32 chn,card_dir *entry,card_file *file)\n\\brief Opens the file with the given filename and fills in the fileinformations.\n\\param[in] chn CARD slot\n\\param[in] entry pointer to the directory entry to open.\n\\param[out] file pointer to the card_file structure. It receives the fileinformations for later usage.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_OpenEntry(chn: s32, entry: *mut card_dir, file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Close(card_file *file)\n\\brief Closes the file with the given card_file structure and releases the handle.\n\\param[in] file pointer to the card_file structure to close.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Close(file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Create(s32 chn,const char *filename,u32 size,card_file *file)\n\\brief Creates a new file with the given filename and fills in the fileinformations. Synchronous version.\n\\param[in] chn CARD slot\n\\param[in] filename name of the file to create.\n\\param[in] size size of the newly created file. This must be a multiple of the memory card's sector size.\n\\param[out] file pointer to the card_file structure. It receives the fileinformations for later usage.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Create(
        chn: s32,
        filename: *const ::libc::c_char,
        size: u32_,
        file: *mut card_file,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_CreateAsync(s32 chn,const char *filename,u32 size,card_file *file,cardcallback callback)\n\\brief Creates a new file with the given filename and fills in the fileinformations. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot\n\\param[in] filename name of the file to create.\n\\param[in] size size of the newly created file. This must be a multiple of the memory card's sector size.\n\\param[out] file pointer to the card_file structure. It receives the fileinformations for later usage.\n\\param[in] callback pointer to a callback function. This callback will be called when the create process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_CreateAsync(
        chn: s32,
        filename: *const ::libc::c_char,
        size: u32_,
        file: *mut card_file,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_CreateEntry(s32 chn,card_dir *entry,card_file *file)\n\\brief Creates a new file with the given filename and fills in the fileinformations. Synchronous version.\n\\param[in] chn CARD slot\n\\param[in] entry pointer to the directory entry to create.\n\\param[out] file pointer to the card_file structure. It receives the fileinformations for later usage.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_CreateEntry(chn: s32, direntry: *mut card_dir, file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_CreateEntryAsync(s32 chn,card_dir *entry,card_file *file,cardcallback callback)\n\\brief Creates a new file with the given filename and fills in the fileinformations. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot\n\\param[in] entry pointer to the directory entry to create\n\\param[out] file pointer to the card_file structure. It receives the fileinformations for later usage.\n\\param[in] callback pointer to a callback function. This callback will be called when the create process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_CreateEntryAsync(
        chn: s32,
        direntry: *mut card_dir,
        file: *mut card_file,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Delete(s32 chn,const char *filename)\n\\brief Deletes a file with the given filename. Synchronous version.\n\\param[in] chn CARD slot\n\\param[in] filename name of the file to delete.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Delete(chn: s32, filename: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_DeleteAsync(s32 chn,const char *filename,cardcallback callback)\n\\brief Deletes a file with the given filename. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot\n\\param[in] filename name of the file to delete.\n\\param[in] callback pointer to a callback function. This callback will be called when the delete process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_DeleteAsync(
        chn: s32,
        filename: *const ::libc::c_char,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_DeleteEntry(s32 chn,card_dir *dir_entry)\n\\brief Deletes a file with the given directory entry informations.\n\\param[in] chn CARD slot\n\\param[in] dir_entry pointer to the card_dir structure which holds the informations for the delete operation.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_DeleteEntry(chn: s32, dir_entry: *mut card_dir) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_DeleteEntryAsync(s32 chn,card_dir *dir_entry,cardcallback callback)\n\\brief Deletes a file with the given directory entry informations. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot\n\\param[in] dir_entry pointer to the card_dir structure which holds the informations for the delete operation.\n\\param[in] callback pointer to a callback function. This callback will be called when the delete process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_DeleteEntryAsync(chn: s32, dir_entry: *mut card_dir, callback: cardcallback)
        -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_Write(card_file *file,void *buffer,u32 len,u32 offset)\n\\brief Writes the data to the file from the buffer to the given offset with the given length. Synchronous version\n\\param[in] file pointer to the card_file structure which holds the fileinformations.\n\\param[in] buffer pointer to the memory area to read from. The startaddress of the buffer should be aligned on a 32byte boundery.\n\\param[in] len length of data to write.\n\\param[in] offset starting point in the file to start writing.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_Write(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_WriteAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback)\n\\brief Writes the data to the file from the buffer to the given offset with the given length. This function returns immediately. Asynchronous version\n\\param[in] file pointer to the card_file structure which holds the fileinformations.\n\\param[in] buffer pointer to the memory area to read from. The startaddress of the buffer should be aligned on a 32byte boundery.\n\\param[in] len length of data to write.\n\\param[in] offset starting point in the file to start writing.\n\\param[in] callback pointer to a callback function. This callback will be called when the write process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_WriteAsync(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetErrorCode(s32 chn)\n\\brief Returns the result code from the last operation.\n\\param[in] chn CARD slot\n\n\\return \\ref card_errors \"card error codes\" of last operation"]
    pub fn CARD_GetErrorCode(chn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_FindFirst(s32 chn, card_dir *dir, bool showall)\n\\brief Start to iterate thru the memory card's directory structure and returns the first directory entry.\n\\param[in] chn CARD slot\n\\param[out] dir pointer to card_dir structure to receive the result set.\n\\param[in] showall Whether to show all files of the memory card or only those which are identified by the company and gamecode string.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_FindFirst(chn: s32, dir: *mut card_dir, showall: bool) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_FindNext(card_dir *dir)\n\\brief Returns the next directory entry from the memory cards directory structure.\n\\param[out] dir pointer to card_dir structure to receive the result set.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_FindNext(dir: *mut card_dir) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetDirectory(s32 chn, card_dir *dir_entries, s32 *count, bool showall)\n\\brief Returns the directory entries. size of entries is max. 128.\n\\param[in] chn CARD slot\n\\param[out] dir_entries pointer to card_dir structure to receive the result set.\n\\param[out] count pointer to an integer to receive the counted entries.\n\\param[in] showall Whether to show all files of the memory card or only those which are identified by the company and gamecode string.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_GetDirectory(
        chn: s32,
        dir_entries: *mut card_dir,
        count: *mut s32,
        showall: bool,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetSectorSize(s32 chn,u32 *sector_size)\n\\brief Returns the next directory entry from the memory cards directory structure.\n\\param[in] chn CARD slot.\n\\param[out] sector_size pointer to receive the result.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_GetSectorSize(chn: s32, sector_size: *mut u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetBlockCount(s32 chn,u32 *block_count)\n\\brief Returns the next directory entry from the memory cards directory structure.\n\\param[in] chn CARD slot.\n\\param[out] sector_size pointer to receive the result.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_GetBlockCount(chn: s32, block_count: *mut u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetStatus(s32 chn,s32 fileno,card_stat *stats)\n\\brief Get additional file statistic informations.\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[out] stats pointer to receive the result set.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_GetStatus(chn: s32, fileno: s32, stats: *mut card_stat) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetStatusEx(s32 chn, s32 fileno, card_direntry *entry)\n\\brief Get the directory entry (GCI header)\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[out] entry pointer to receive the directory entry.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_GetStatusEx(chn: s32, fileno: s32, entry: *mut card_direntry) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetStatus(s32 chn,s32 fileno,card_stat *stats)\n\\brief Set additional file statistic informations. Synchronous version.\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[out] stats pointer which holds the informations to set.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetStatus(chn: s32, fileno: s32, stats: *mut card_stat) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetStatusAsync(s32 chn,s32 fileno,card_stat *stats,cardcallback callback)\n\\brief Set additional file statistic informations. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[out] stats pointer which holds the informations to set.\n\\param[in] callback pointer to a callback function. This callback will be called when the setstatus process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetStatusAsync(
        chn: s32,
        fileno: s32,
        stats: *mut card_stat,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetStatusEx(s32 chn, s32 fileno, card_direntry *entry)\n\\brief Set the directory entry (preferably from a GCI header), except block index and lenght\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[out] entry pointer to a directory entry structure (or GCI header).\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetStatusEx(chn: s32, fileno: s32, entry: *mut card_direntry) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetAttributes(s32 chn,s32 fileno,u8 *attr)\n\\brief Get additional file attributes. Synchronous version.\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[out] attr pointer to receive attribute value.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_GetAttributes(chn: s32, fileno: s32, attr: *mut u8_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetAttributes(s32 chn,s32 fileno,u8 attr)\n\\brief Set additional file attributes. Synchronous version.\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[in] attr attribute value to set.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetAttributes(chn: s32, fileno: s32, attr: u8_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetAttributesAsync(s32 chn,s32 fileno,u8 attr,cardcallback callback)\n\\brief Set additional file attributes. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot.\n\\param[in] fileno file index. returned by a previous call to CARD_Open().\n\\param[in] attr attribute value to set.\n\\param[in] callback pointer to a callback function. This callback will be called when the setattributes process has finished.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetAttributesAsync(chn: s32, fileno: s32, attr: u8_, callback: cardcallback)
        -> s32;
}
extern "C" {
    #[doc = " Not finished function"]
    pub fn CARD_Format(chn: s32) -> s32;
}
extern "C" {
    #[doc = " Not finished function"]
    pub fn CARD_FormatAsync(chn: s32, callback: cardcallback) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetCompany(const char *company)\n\\brief Set additional file attributes. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetCompany(company: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_SetGamecode(const char *gamecode)\n\\brief Set additional file attributes. This function returns immediately. Asynchronous version.\n\\param[in] chn CARD slot.\n\n\\return \\ref card_errors \"card error codes\""]
    pub fn CARD_SetGamecode(gamecode: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetSerialNo(s32 chn, u32 *serial1, u32 *serial2)\n\\brief Get the encrypted serial numbers of the memory card\n\\param[in] chn CARD slot.\n\\param[in] serial1 & serial2 CARD slot.\n\\return \\ref card_errors \"card error codes\" or free blocks"]
    pub fn CARD_GetSerialNo(chn: s32, serial1: *mut u32_, serial2: *mut u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 CARD_GetFreeBlocks(s32 chn, u16* freeblocks)\n\\brief Get the free blocks in memory card\n\\param[in] chn CARD slot.\n\\param[in] freeblocks pointer to receive freeblocks value.\n\\return \\ref card_errors \"card error codes\" or free blocks"]
    pub fn CARD_GetFreeBlocks(chn: s32, freeblocks: *mut u16_) -> s32;
}
#[doc = "\\typedef struct _gx_rmodeobj GXRModeObj\n\\brief structure to hold the selected video and render settings\n\\param viTVMode mode and type of TV\n\\param fbWidth width of external framebuffer\n\\param efbHeight height of embedded framebuffer\n\\param xfbHeight height of external framebuffer\n\\param viXOrigin x starting point of first pixel to draw on VI\n\\param viYOrigin y starting point of first pixel to draw on VI\n\\param viWidth width of configured VI\n\\param viHeight height of configured VI"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_rmodeobj {
    pub viTVMode: u32_,
    pub fbWidth: u16_,
    pub efbHeight: u16_,
    pub xfbHeight: u16_,
    pub viXOrigin: u16_,
    pub viYOrigin: u16_,
    pub viWidth: u16_,
    pub viHeight: u16_,
    pub xfbMode: u32_,
    pub field_rendering: u8_,
    pub aa: u8_,
    pub sample_pattern: [[u8_; 2usize]; 12usize],
    pub vfilter: [u8_; 7usize],
}
#[doc = "\\typedef struct _gx_rmodeobj GXRModeObj\n\\brief structure to hold the selected video and render settings\n\\param viTVMode mode and type of TV\n\\param fbWidth width of external framebuffer\n\\param efbHeight height of embedded framebuffer\n\\param xfbHeight height of external framebuffer\n\\param viXOrigin x starting point of first pixel to draw on VI\n\\param viYOrigin y starting point of first pixel to draw on VI\n\\param viWidth width of configured VI\n\\param viHeight height of configured VI"]
pub type GXRModeObj = _gx_rmodeobj;
extern "C" {
    #[doc = " \\fn CON_Init(void *framebuffer,int xstart,int ystart,int xres,int yres,int stride)\n \\brief Initializes the console subsystem with given parameters\n\n \\param[in] framebuffer pointer to the framebuffer used for drawing the characters\n \\param[in] xstart,ystart start position of the console output in pixel\n \\param[in] xres,yres size of the console in pixel\n \\param[in] stride size of one line of the framebuffer in bytes\n\n \\return none"]
    pub fn CON_Init(
        framebuffer: *mut ::libc::c_void,
        xstart: ::libc::c_int,
        ystart: ::libc::c_int,
        xres: ::libc::c_int,
        yres: ::libc::c_int,
        stride: ::libc::c_int,
    );
}
extern "C" {
    #[doc = " \\fn s32 CON_InitEx(GXRModeObj *rmode, s32 conXOrigin,s32 conYOrigin,s32 conWidth,s32 conHeight)\n \\brief Initialize stdout console\n \\param[in] rmode pointer to the video/render mode configuration\n \\param[in] conXOrigin starting pixel in X direction of the console output on the external framebuffer\n \\param[in] conYOrigin starting pixel in Y direction of the console output on the external framebuffer\n \\param[in] conWidth width of the console output 'window' to be drawn\n \\param[in] conHeight height of the console output 'window' to be drawn\n\n \\return 0 on success, <0 on error"]
    pub fn CON_InitEx(
        rmode: *mut GXRModeObj,
        conXOrigin: s32,
        conYOrigin: s32,
        conWidth: s32,
        conHeight: s32,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn CON_GetMetrics(int *cols, int *rows)\n \\brief retrieve the columns and rows of the current console\n\n \\param[out] cols,rows number of columns and rows of the current console\n\n \\return none"]
    pub fn CON_GetMetrics(cols: *mut ::libc::c_int, rows: *mut ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn CON_GetPosition(int *col, int *row)\n \\brief retrieve the current cursor position of the current console\n\n \\param[out] col,row current cursor position\n\n \\return none"]
    pub fn CON_GetPosition(cols: *mut ::libc::c_int, rows: *mut ::libc::c_int);
}
extern "C" {
    #[doc = " \\fn CON_EnableGecko(int channel, int safe)\n \\brief Enable or disable the USB gecko console.\n\n \\param[in] channel EXI channel, or -1 to disable the gecko console\n \\param[in] safe If true, use safe mode (wait for peer)\n\n \\return none"]
    pub fn CON_EnableGecko(channel: ::libc::c_int, safe: ::libc::c_int);
}
pub type sec_t = u32;
pub type FN_MEDIUM_STARTUP = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type FN_MEDIUM_ISINSERTED = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type FN_MEDIUM_READSECTORS = ::core::option::Option<
    unsafe extern "C" fn(sector: sec_t, numSectors: sec_t, buffer: *mut ::libc::c_void) -> bool,
>;
pub type FN_MEDIUM_WRITESECTORS = ::core::option::Option<
    unsafe extern "C" fn(sector: sec_t, numSectors: sec_t, buffer: *const ::libc::c_void) -> bool,
>;
pub type FN_MEDIUM_CLEARSTATUS = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type FN_MEDIUM_SHUTDOWN = ::core::option::Option<unsafe extern "C" fn() -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISC_INTERFACE_STRUCT {
    pub ioType: ::libc::c_ulong,
    pub features: ::libc::c_ulong,
    pub startup: FN_MEDIUM_STARTUP,
    pub isInserted: FN_MEDIUM_ISINSERTED,
    pub readSectors: FN_MEDIUM_READSECTORS,
    pub writeSectors: FN_MEDIUM_WRITESECTORS,
    pub clearStatus: FN_MEDIUM_CLEARSTATUS,
    pub shutdown: FN_MEDIUM_SHUTDOWN,
}
pub type DISC_INTERFACE = DISC_INTERFACE_STRUCT;
#[doc = " \\typedef struct _dvddiskid dvddiskid\n \\brief forward typedef for struct _dvddiskid"]
pub type dvddiskid = _dvddiskid;
#[doc = " \\typedef struct _dvddiskid dvddiskid\n\n        This structure holds the game vendors copyright informations.<br>\n        Additionally it holds certain parameters for audiocontrol and<br>\n        multidisc support.\n\n \\param gamename[4] vendors game key\n \\param company[2] vendors company key\n \\param disknum number of disc when multidisc support is used.\n \\param gamever version of game\n \\param streaming flag to control audio streaming\n \\param streambufsize size of buffer used for audio streaming\n \\param pad[22] padding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvddiskid {
    pub gamename: [s8; 4usize],
    pub company: [s8; 2usize],
    pub disknum: u8_,
    pub gamever: u8_,
    pub streaming: u8_,
    pub streambufsize: u8_,
    pub pad: [u8_; 22usize],
}
#[doc = " \\typedef struct _dvdcmdblk dvdcmdblk\n \\brief forward typedef for struct _dvdcmdblk"]
pub type dvdcmdblk = _dvdcmdblk;
#[doc = " \\typedef void (*dvdcbcallback)(s32 result,dvdcmdblk *block)\n \\brief function pointer typedef for the user's operations callback"]
pub type dvdcbcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, block: *mut dvdcmdblk)>;
#[doc = " \\typedef struct _dvdcmdblk dvdcmdblk\n\n        This structure is used internally to control the requested operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvdcmdblk {
    pub node: lwp_node,
    pub cmd: u32_,
    pub state: s32,
    pub offset: s64,
    pub len: u32_,
    pub buf: *mut ::libc::c_void,
    pub currtxsize: u32_,
    pub txdsize: u32_,
    pub id: *mut dvddiskid,
    pub cb: dvdcbcallback,
    pub usrdata: *mut ::libc::c_void,
}
#[doc = " \\typedef struct _dvddrvinfo dvddrvinfo\n \\brief forward typedef for struct _dvddrvinfo"]
pub type dvddrvinfo = _dvddrvinfo;
#[doc = " \\typedef struct _dvddrvinfo dvddrvinfo\n\n        This structure structure holds the drive version infromation.<br>\n\t\t  Use DVD_Inquiry() to retrieve this information.\n\n \\param rev_leve revision level\n \\param dev_code device code\n \\param rel_date release date\n \\param pad[24] padding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvddrvinfo {
    pub rev_level: u16_,
    pub dev_code: u16_,
    pub rel_date: u32_,
    pub pad: [u8_; 24usize],
}
#[doc = " \\typedef struct _dvdfileinfo dvdfileinfo\n \\brief forward typedef for struct _dvdfileinfo"]
pub type dvdfileinfo = _dvdfileinfo;
#[doc = " \\typedef void (*dvdcallback)(s32 result,dvdfileinfo *info)\n \\brief function pointer typedef for the user's DVD operation callback\n\n \\param[in] result error code of last operation\n \\param[in] info pointer to user's file info strucutre"]
pub type dvdcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, info: *mut dvdfileinfo)>;
#[doc = " \\typedef struct _dvdfileinfo dvdfileinfo\n\n        This structure is used internally to control the requested file operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvdfileinfo {
    pub block: dvdcmdblk,
    pub addr: u32_,
    pub len: u32_,
    pub cb: dvdcallback,
}
extern "C" {
    #[doc = " \\fn void DVD_Init(void)\n \\brief Initializes the DVD subsystem\n\n        You must call this function before calling any other DVD function\n\n \\return none"]
    pub fn DVD_Init();
}
extern "C" {
    pub fn DVD_Pause();
}
extern "C" {
    #[doc = " \\fn void DVD_Reset(u32 reset_mode)\n \\brief Performs a reset of the drive and FW respectively.\n\n \\param[in] reset_mode \\ref dvd_resetmode \"type\" of reset\n\n \\return none"]
    pub fn DVD_Reset(reset_mode: u32_);
}
extern "C" {
    #[doc = " \\fn s32 DVD_Mount(void)\n \\brief Mounts the DVD drive.\n\n        This is a synchronous version of DVD_MountAsync().\n\n \\return none"]
    pub fn DVD_Mount() -> s32;
}
extern "C" {
    pub fn DVD_GetDriveStatus() -> s32;
}
extern "C" {
    #[doc = " \\fn s32 DVD_MountAsync(dvdcmdblk *block,dvdcbcallback cb)\n \\brief Mounts the DVD drive.\n\n        You <b>must</b> call this function in order to access the DVD.\n\n        Following tasks are performed:\n      - Issue a hard reset to the drive.\n      - Turn on drive's debug mode.\n      - Patch drive's FW.\n      - Enable extensions.\n      - Read disc ID\n\n        The patch code and procedure was taken from the gc-linux DVD device driver.\n\n \\param[in] block pointer to a dvdcmdblk structure used to process the operation\n \\param[in] cb callback to be invoked upon completion of operation\n\n \\return none"]
    pub fn DVD_MountAsync(block: *mut dvdcmdblk, cb: dvdcbcallback) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 DVD_ControlDrive(dvdcmdblk *block,u32 cmd)\n \\brief Controls the drive's motor and behavior.\n\n        This is a synchronous version of DVD_ControlDriveAsync().\n\n \\param[in] block pointer to a dvdcmdblk structure used to process the operation\n \\param[in] cmd \\ref dvd_motorctrlmode \"command\" to control the drive.\n\n \\return none"]
    pub fn DVD_ControlDrive(block: *mut dvdcmdblk, cmd: u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 DVD_ControlDriveAsync(dvdcmdblk *block,u32 cmd,dvdcbcallback cb)\n \\brief Controls the drive's motor and behavior.\n\n \\param[in] block pointer to a dvdcmdblk structure used to process the operation\n \\param[in] cmd \\ref dvd_motorctrlmode \"command\" to control the drive.\n \\param[in] cb callback to be invoked upon completion of operation.\n\n \\return none"]
    pub fn DVD_ControlDriveAsync(block: *mut dvdcmdblk, cmd: u32_, cb: dvdcbcallback) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 DVD_SetGCMOffset(dvdcmdblk *block,u32 offset)\n \\brief Sets the offset to the GCM. Used for multigame discs.\n\n        This is a synchronous version of DVD_SetGCMOffsetAsync().\n\n \\param[in] block pointer to a dvdcmdblk structure used to process the operation\n \\param[in] offset offset to the GCM on disc.\n\n \\return \\ref dvd_errorcodes \"dvd error code\""]
    pub fn DVD_SetGCMOffset(block: *mut dvdcmdblk, offset: s64) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 DVD_SetGCMOffsetAsync(dvdcmdblk *block,u32 offset,dvdcbcallback cb)\n \\brief Sets the offset to the GCM. Used for multigame discs.\n\n        This is a synchronous version of DVD_SetGCMOffsetAsync().\n\n \\param[in] block pointer to a dvdcmdblk structure used to process the operation\n \\param[in] offset offset to the GCM on disc.\n \\param[in] cb callback to be invoked upon completion of operation.\n\n \\return \\ref dvd_errorcodes \"dvd error code\""]
    pub fn DVD_SetGCMOffsetAsync(block: *mut dvdcmdblk, offset: s64, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_GetCmdBlockStatus(block: *mut dvdcmdblk) -> s32;
}
extern "C" {
    pub fn DVD_SpinUpDrive(block: *mut dvdcmdblk) -> s32;
}
extern "C" {
    pub fn DVD_SpinUpDriveAsync(block: *mut dvdcmdblk, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_Inquiry(block: *mut dvdcmdblk, info: *mut dvddrvinfo) -> s32;
}
extern "C" {
    pub fn DVD_InquiryAsync(block: *mut dvdcmdblk, info: *mut dvddrvinfo, cb: dvdcbcallback)
        -> s32;
}
extern "C" {
    pub fn DVD_ReadPrio(
        block: *mut dvdcmdblk,
        buf: *mut ::libc::c_void,
        len: u32_,
        offset: s64,
        prio: s32,
    ) -> s32;
}
extern "C" {
    pub fn DVD_ReadAbsAsyncPrio(
        block: *mut dvdcmdblk,
        buf: *mut ::libc::c_void,
        len: u32_,
        offset: s64,
        cb: dvdcbcallback,
        prio: s32,
    ) -> s32;
}
extern "C" {
    pub fn DVD_ReadAbsAsyncForBS(
        block: *mut dvdcmdblk,
        buf: *mut ::libc::c_void,
        len: u32_,
        offset: s64,
        cb: dvdcbcallback,
    ) -> s32;
}
extern "C" {
    pub fn DVD_SeekPrio(block: *mut dvdcmdblk, offset: s64, prio: s32) -> s32;
}
extern "C" {
    pub fn DVD_SeekAbsAsyncPrio(
        block: *mut dvdcmdblk,
        offset: s64,
        cb: dvdcbcallback,
        prio: s32,
    ) -> s32;
}
extern "C" {
    pub fn DVD_CancelAllAsync(cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_StopStreamAtEndAsync(block: *mut dvdcmdblk, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_StopStreamAtEnd(block: *mut dvdcmdblk) -> s32;
}
extern "C" {
    pub fn DVD_ReadDiskID(block: *mut dvdcmdblk, id: *mut dvddiskid, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_SetAutoInvalidation(auto_inv: u32_) -> u32_;
}
extern "C" {
    pub fn DVD_GetCurrentDiskID() -> *mut dvddiskid;
}
extern "C" {
    pub fn DVD_GetDriveInfo() -> *mut dvddrvinfo;
}
extern "C" {
    pub static __io_gcdvd: DISC_INTERFACE;
}
#[doc = " \\typedef s32 (*EXICallback)(s32 chn,s32 dev)\n\\brief function pointer typedef for the user's EXI callback\n\\param chn EXI channel\n\\param dev EXI device"]
pub type EXICallback = ::core::option::Option<unsafe extern "C" fn(chn: s32, dev: s32) -> s32>;
extern "C" {
    #[doc = " \\fn s32 EXI_ProbeEx(s32 nChn)\n\\brief Performs an extended probe of the EXI channel\n\\param[in] nChn EXI channel to probe\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_ProbeEx(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Probe(s32 nChn)\n\\brief Probes the EXI channel\n\\param[in] nChn EXI channel to probe\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Probe(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Lock(s32 nChn,s32 nDev,EXICallback unlockCB)\n\\brief Try to lock the desired EXI channel on the given device.\n\\param[in] nChn EXI channel to lock\n\\param[in] nDev EXI device to lock\n\\param[in] unlockCB pointer to callback to call when EXI_Unlock() is called. Thus allowing us a small way of mutual exclusion.\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Lock(nChn: s32, nDev: s32, unlockCB: EXICallback) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Unlock(s32 nChn)\n\\brief Unlock the desired EXI channel.\n\\param[in] nChn EXI channel to unlock\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Unlock(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Select(s32 nChn,s32 nDev,s32 nFrq)\n\\brief Selects the spedified EXI channel on the given device with the given frequency\n\\param[in] nChn EXI channel to select\n\\param[in] nDev EXI device to select\n\\param[in] nFrq EXI frequency to select\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Select(nChn: s32, nDev: s32, nFrq: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_SelectSD(s32 nChn,s32 nDev,s32 nFrq)\n\\brief Performs a special select, for SD cards or adapters respectively, on the given device with the given frequence\n\\param[in] nChn EXI channel to select\n\\param[in] nDev EXI device to select\n\\param[in] nFrq EXI frequency to select\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_SelectSD(nChn: s32, nDev: s32, nFrq: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Deselect(s32 nChn)\n\\brief Deselects the EXI channel.\n\\param[in] nChn EXI channel to deselect\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Deselect(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Sync(s32 nChn)\n\\brief Synchronize or finish respectively the last EXI transfer.\n\\param[in] nChn EXI channel to select\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Sync(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Imm(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb)\n\\brief Initializes an immediate mode EXI transfer.\n\\param[in] nChn EXI channel to select\n\\param[in,out] pData pointer to a buffer to read/copy from/to data.\n\\param[in] nLen lenght of data to transfer <=4.\n\\param[in] nMode direction of transferoperation(EXI_READ,EXI_WRITE,EXI_READWRITE)\n\\param[in] tc_cb pointer to a callback to call when transfer has completed. May be NULL.\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Imm(
        nChn: s32,
        pData: *mut ::libc::c_void,
        nLen: u32_,
        nMode: u32_,
        tc_cb: EXICallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_ImmEx(s32 nChn,void *pData,u32 nLen,u32 nMode)\n\\brief Initializes an extended immediate mode EXI transfer.\n\\param[in] nChn EXI channel to select\n\\param[in,out] pData pointer to a buffer to read/copy from/to data.\n\\param[in] nLen lenght of data to transfer.\n\\param[in] nMode direction of transferoperation(EXI_READ,EXI_WRITE,EXI_READWRITE)\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_ImmEx(nChn: s32, pData: *mut ::libc::c_void, nLen: u32_, nMode: u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Dma(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb)\n\\brief Initializes a DMA mode EXI transfer.\n\\param[in] nChn EXI channel to select\n\\param[in,out] pData pointer to a buffer to read/copy from/to data.\n\\param[in] nLen lenght of data to transfer.\n\\param[in] nMode direction of transferoperation(EXI_READ,EXI_WRITE,EXI_READWRITE)\n\\param[in] tc_cb pointer to a callback to call when transfer has completed. May be NULL.\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Dma(
        nChn: s32,
        pData: *mut ::libc::c_void,
        nLen: u32_,
        nMode: u32_,
        tc_cb: EXICallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_GetState(s32 nChn)\n\\brief Get the EXI state\n\\param[in] nChn EXI channel to select\n\n\\return EXI channels state flag."]
    pub fn EXI_GetState(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_GetID(s32 nChn,s32 nDev,u32 *nId)\n\\brief Get the ID of the connected EXI device on the given channel\n\\param[in] nChn EXI channel to select\n\\param[in] nDev EXI device to select\n\\param[out] nId EXI device ID to return.\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_GetID(nChn: s32, nDev: s32, nId: *mut u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Attach(s32 nChn,EXICallback ext_cb)\n\\brief Attach the device on the given channel\n\\param[in] nChn EXI channel to select\n\\param[in] ext_cb pointer to callback to call when device is physically removed.\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Attach(nChn: s32, ext_cb: EXICallback) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 EXI_Detach(s32 nChn)\n\\brief Detach the device on the given channel\n\\param[in] nChn EXI channel to select\n\n\\return 1 on success, <=0 on error"]
    pub fn EXI_Detach(nChn: s32) -> s32;
}
extern "C" {
    #[doc = " \\fn void EXI_ProbeReset(void)\n\\brief Resets certain internal flags and counters and performs a probe on all 3 channels.\n\n\\return nothing"]
    pub fn EXI_ProbeReset();
}
extern "C" {
    #[doc = " \\fn EXICallback EXI_RegisterEXICallback(s32 nChn,EXICallback exi_cb)\n\\brief Register a callback function in the EXI driver for the EXI interrupt.\n\\param[in] nChn EXI channel to select\n\\param[in] exi_cb pointer to the function which to call when EXI interrupt has triggered.\n\n\\return old callback function pointer or NULL"]
    pub fn EXI_RegisterEXICallback(nChn: s32, exi_cb: EXICallback) -> EXICallback;
}
#[doc = " \\struct guVector\n \\brief 3-element vector with x, y and z components.\n\n \\details When used in 3D transformations, it is treated as a column vector with an implied fourth 'w' coordinate of 1.\n For example, to multiply a vector <i>vOld</i> by a matrix <i>m</i>: <i>vNew</i> = <i>m</i> x <i>vOld</i>. In code:\n\n \\code guVecMultiply( m, &vOld, &vNew ); \\endcode\n\n \\note This is a generic structure which can be used in any situation or function that accepts an array or struct with\n three f32 values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vecf {
    pub x: f32_,
    pub y: f32_,
    pub z: f32_,
}
#[doc = " \\struct guVector\n \\brief 3-element vector with x, y and z components.\n\n \\details When used in 3D transformations, it is treated as a column vector with an implied fourth 'w' coordinate of 1.\n For example, to multiply a vector <i>vOld</i> by a matrix <i>m</i>: <i>vNew</i> = <i>m</i> x <i>vOld</i>. In code:\n\n \\code guVecMultiply( m, &vOld, &vNew ); \\endcode\n\n \\note This is a generic structure which can be used in any situation or function that accepts an array or struct with\n three f32 values."]
pub type guVector = _vecf;
#[doc = " \\struct guQuaternion\n \\brief Quaternion type consisting of an (x,y,z) vector component and a (w) scalar component.\n\n \\details This struct is used by gu library function such as guQuatMtx(), which generates a rotation matrix from a\n quaternion.\n\n \\note This is a generic structure which can be used in any situation or function that accepts an array or struct with\n four f32 values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _qrtn {
    pub x: f32_,
    pub y: f32_,
    pub z: f32_,
    pub w: f32_,
}
#[doc = " \\struct guQuaternion\n \\brief Quaternion type consisting of an (x,y,z) vector component and a (w) scalar component.\n\n \\details This struct is used by gu library function such as guQuatMtx(), which generates a rotation matrix from a\n quaternion.\n\n \\note This is a generic structure which can be used in any situation or function that accepts an array or struct with\n four f32 values."]
pub type guQuaternion = _qrtn;
#[doc = " \\typedef f32 Mtx[3][4]\n \\brief Standard 3x4 matrix.\n \\warning Some functions take the 4x4 matrix type rather than this one, so make sure you don't mix up the two."]
pub type Mtx = [[f32_; 4usize]; 3usize];
pub type MtxP = *mut [f32_; 4usize];
#[doc = " \\typedef f32 ROMtx[4][3]\n \\brief Column-major representation of the standard Mtx structure.\n\n \\details It is not a true transpose, as it is a 4x3 matrix. These structures are only accepted by functions that explicitly\n require reordered matrices."]
pub type ROMtx = [[f32_; 3usize]; 4usize];
pub type ROMtxP = *mut [f32_; 3usize];
#[doc = " \\typedef f32 Mtx33[3][3]\n \\brief 3x3 matrix."]
pub type Mtx33 = [[f32_; 3usize]; 3usize];
pub type Mtx33P = *mut [f32_; 3usize];
#[doc = " \\typedef f32 Mtx44[4][4]\n \\brief 4x4 matrix.\n \\warning Some functions take this instead of the 3x4 matrix, so make sure you don't mix up the two."]
pub type Mtx44 = [[f32_; 4usize]; 4usize];
pub type Mtx44P = *mut [f32_; 4usize];
extern "C" {
    #[doc = " \\fn void guFrustum(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f)\n \\brief Sets a 4x4 perspective projection matrix from viewing volume dimensions.\n\n \\details This matrix is used by the GX API to transform points to screen space.\n\n For normal perspective projection, the axis of projection is the -z axis, so \\a t = positive, \\a b = -\\a t, \\a r  =\n positive, \\a l = -\\a r. \\a n and \\a f must both be given as positive distances.\n\n \\note \\a m negates a point's 'z' values, so pre-transformed points should have negative 'z' values in eye space in\n order to be visible after projection.\n\n \\param[out] mt New projection matrix.\n \\param[in] t Top edge of view volume at the near clipping plane.\n \\param[in] b Bottom edge of view volume at the near clipping plane.\n \\param[in] l Left edge of view volume at the near clipping plane.\n \\param[in] r Right edge of view volume at the near clipping plane.\n \\param[in] n Positive distance to the near clipping plane.\n \\param[in] f Positive distance to the far clipping plane.\n\n \\return none"]
    pub fn guFrustum(mt: *mut [f32_; 4usize], t: f32_, b: f32_, l: f32_, r: f32_, n: f32_, f: f32_);
}
extern "C" {
    #[doc = " \\fn void guPerspective(Mtx44 mt,f32 fovy,f32 aspect,f32 n,f32 f)\n \\brief Sets a 4x4 perspective projection matrix from field of view and aspect ratio parameters.\n\n \\details This matrix is used by the GX API to transform points to screen space.\n\n This function generates a projection matrix equivalent to that created by guFrustum() with the axis of projection\n centered around Z. It is included to provide an alternative method of specifying view volume dimensions.\n\n The field of view (\\a fovy) is the total field of view in degrees in the Y-Z plane. \\a aspect is the ratio\n (width/height) of the view window in screen space. \\a n and \\a f must both be given as positive distances.\n\n \\note \\a m negates a point's 'z' values, so pre-transformed points should have negative 'z' values in eye space in order to\n be visible after projection.\n\n \\param[out] mt New perspective projection matrix.\n \\param[in] fovy Total field of view in the Y-Z plane measured in degrees.\n \\param[in] aspect View window aspect ratio (width/height)\n \\param[in] n Positive distance to near clipping plane.\n \\param[in] f Positive distance to far clipping plane.\n\n \\return none"]
    pub fn guPerspective(mt: *mut [f32_; 4usize], fovy: f32_, aspect: f32_, n: f32_, f: f32_);
}
extern "C" {
    #[doc = " \\fn void guOrtho(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f)\n \\brief Sets a 4x4 matrix for orthographic projection.\n\n \\details This matrix is used by the GX API to transform points from eye space to screen space.\n\n For normal parallel projections, the axis of projection is the -z axis, so \\a t = positive, \\a b = -\\a t, \\a r =\n positive, \\a l = -\\a r. \\a n and \\a f must both be given as positive distances.\n\n \\note \\a m negates \\a a point's 'z' values, so pre-transformed points should have negative 'z' values in eye space in order\n to be visible after projection.\n\n \\param[out] mt New parallel projection matrix.\n \\param[in] t Top edge of view volume.\n \\param[in] b Bottom edge of view volume.\n \\param[in] l Left edge of view volume.\n \\param[in] r Right edge of view volume.\n \\param[in] n Positive distance to the near clipping plane.\n \\param[in] f Positive distance to the far clipping plane.\n\n \\return none"]
    pub fn guOrtho(mt: *mut [f32_; 4usize], t: f32_, b: f32_, l: f32_, r: f32_, n: f32_, f: f32_);
}
extern "C" {
    #[doc = " \\fn void guLightPerspective(Mtx mt,f32 fovY,f32 aspect,f32 scaleS,f32 scaleT,f32 transS,f32 transT)\n \\brief Sets a 3x4 perspective projection matrix from field of view and aspect ratio parameters, two scale values, and two\n translation values.\n\n \\details This matrix is used to project points into texture space and yield texture coordinates.\n\n This function generates a projection matrix, equivalent to that created by guLightFrustum(), with the axis of projection\n centered around Z. This function is included to provide an alternative method of specifying texture projection volume\n dimensions.\n\n The field of view (\\a fovy) is the total field of view in degrees in the YZ plane. \\a aspect is the ratio (width / height)\n of the view window in screen space.\n\n Standard projection yields values ranging from -1.0 to 1.0 in both dimensions of the front clipping plane. Since texture\n coordinates should usually be within the range of 0.0 to 1.0, we have added a scale and translation value for both S and T.\n The most common way to use these values is to set all of them to 0.5 (so that points in the range of -1.0 to 1.0 are first\n scaled by 0.5) to be in the range of -0.5 to 0.5. Then they are translated by 0.5 to be in the range of 0.0 to 1.0. Other\n values can be used for translation and scale to yield different effects.\n\n \\param[out] mt New projection matrix.\n \\param[in] fovy Total field of view in the YZ plane measured in degrees.\n \\param[in] aspect View window aspect ratio (width / height)\n \\param[in] scaleS Scale in the S direction for projected coordinates (usually 0.5).\n \\param[in] scaleT Scale in the T direction for projected coordinates (usually 0.5).\n \\param[in] transS Translate in the S direction for projected coordinates (usually 0.5).\n \\param[in] transT Translate in the T direction for projected coordinates (usually 0.5).\n\n \\return none"]
    pub fn guLightPerspective(
        mt: *mut [f32_; 4usize],
        fovY: f32_,
        aspect: f32_,
        scaleS: f32_,
        scaleT: f32_,
        transS: f32_,
        transT: f32_,
    );
}
extern "C" {
    #[doc = " \\fn void guLightOrtho(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 scaleS,f32 scaleT,f32 transS,f32 transT)\n \\brief Sets a 3x4 matrix for orthographic projection.\n\n \\details Use this matrix to project points into texture space and yield texture coordinates.\n\n For normal parallel projections, the axis of projection is the -z axis, so \\a t = positive, \\a b = -\\a t, \\a r = positive,\n \\a l = -\\a r.\n\n Standard projection yields values ranging from -1.0 to 1.0 in both dimensions of the front clipping plane. Since texture\n coordinates should usually be within the range of 0.0 to 1.0, we have added a scale and translation value for both S and T.\n The most common way to use these values is to set all of them to 0.5 so that points in the range of -1.0 to 1.0 are first\n scaled by 0.5 (to be in the range of -0.5 to 0.5). Then they are translated by 0.5 to be in the range of 0.0 to 1.0. Other\n values can be used for translation and scale to yield different effects.\n\n \\param[out] mt New parallel projection matrix.\n \\param[in] t Top edge of view volume.\n \\param[in] b Bottom edge of view volume.\n \\param[in] l Left edge of view volume.\n \\param[in] r Right edge of view volume.\n \\param[in] scaleS Scale in the S direction for projected coordinates (usually 0.5).\n \\param[in] scaleT Scale in the T direction for projected coordinates (usually 0.5).\n \\param[in] transS Translate in the S direction for projected coordinates (usually 0.5).\n \\param[in] transT Translate in the T direction for projected coordinates (usually 0.5).\n\n \\return none"]
    pub fn guLightOrtho(
        mt: *mut [f32_; 4usize],
        t: f32_,
        b: f32_,
        l: f32_,
        r: f32_,
        scaleS: f32_,
        scaleT: f32_,
        transS: f32_,
        transT: f32_,
    );
}
extern "C" {
    #[doc = " \\fn void guLightFrustum(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 scaleS,f32 scaleT,f32 transS,f32 transT)\n \\brief Sets a 3x4 perspective projection matrix from viewing volume dimensions, two scale values, and two translation values.\n\n \\details This matrix is used to project points into texture space and yield texture coordinates.\n\n For normal perspective projection, the axis of projection is the -z axis, so \\a t = positive, \\a b = -\\a t, \\a r = positive,\n \\a l = -\\a r. \\a n must be given as a positive distance.\n\n Standard projection yields values ranging from -1.0 to 1.0 in both dimensions of the front clipping plane.  Since texture\n coordinates usually should be within the range of 0.0 to 1.0, we have added a scale and translation value for both S and T.\n The most common usage of these values is to set all of them to 0.5 so that points in the range of -1.0 to 1.0 are first\n scaled by 0.5 to be in the range of -0.5 to 0.5, and are then translated by 0.5 to be in the range of 0.0 to 1.0.  Other\n values can be used for translation and scale to yield different effects.\n\n \\param[out] mt New projection matrix.\n \\param[in] t Top edge of view volume at the near clipping plane.\n \\param[in] b Bottom edge of view volume at the near clipping plane.\n \\param[in] l Left edge of view volume at the near clipping plane.\n \\param[in] r Right edge of view volume at the near clipping plane.\n \\param[in] n Positive distance to the near clipping plane.\n \\param[in] scaleS Scale in the S direction for projected coordinates (usually 0.5).\n \\param[in] scaleT Scale in the T direction for projected coordinates (usually 0.5).\n \\param[in] transS Translate in the S direction for projected coordinates (usually 0.5).\n \\param[in] transT Translate in the T direction for projected coordinates (usually 0.5).\n\n \\return none"]
    pub fn guLightFrustum(
        mt: *mut [f32_; 4usize],
        t: f32_,
        b: f32_,
        l: f32_,
        r: f32_,
        n: f32_,
        scaleS: f32_,
        scaleT: f32_,
        transS: f32_,
        transT: f32_,
    );
}
extern "C" {
    #[doc = " \\fn void guLookAt(Mtx mt,guVector *camPos,guVector *camUp,guVector *target)\n \\brief Sets a world-space to camera-space transformation matrix.\n\n \\details Create the matrix \\a m by specifying a camera position (\\a camPos), a camera \"up\" direction (\\a camUp), and a target\n position (\\a target).\n\n The camera's reference viewing direction is the -z axis. The camera's reference 'up' direction is the +y axis.\n\n This function is especially convenient for creating a tethered camera, aiming at an object, panning, or specifying an\n arbitrary view.\n\n \\param[out] mt New viewing matrix.\n \\param[in] camPos Vector giving 3D camera position in world space.\n \\param[in] camUp Vector containing camera \"up\" vector; does not have to be a unit vector.\n \\param[in] target Vector giving 3D target position in world space.\n\n \\return none"]
    pub fn guLookAt(
        mt: *mut [f32_; 4usize],
        camPos: *const guVector,
        camUp: *const guVector,
        target: *const guVector,
    );
}
extern "C" {
    #[doc = " \\fn void guVecHalfAngle(guVector *a,guVector *b,guVector *half)\n \\brief Computes a vector that lies halfway between \\a a and \\a b.\n\n \\details The halfway vector is useful in specular reflection calculations. It is interpreted as pointing from the reflecting\n surface to the general viewing direction.\n\n \\a a and \\a b do not have to be unit vectors. Both of these vectors are assumed to be pointing towards the surface from the\n light or viewer, respectively. Local copies of these vectors are negated, normalized and added head to tail.\n\n \\a half is computed as a unit vector that points from the surface to halfway between the light and the viewing direction.\n\n \\param[in] a Pointer to incident vector. Must point from the light source to the surface.\n \\param[in] b Pointer to viewing vector. Must point from the viewer to the surface.\n \\param[out] half Pointer to resultant half-angle unit vector; points from the surface to halfway between the light and the viewing direction.\n\n \\return none"]
    pub fn guVecHalfAngle(a: *const guVector, b: *const guVector, half: *mut guVector);
}
extern "C" {
    pub fn c_guVecAdd(a: *const guVector, b: *const guVector, ab: *mut guVector);
}
extern "C" {
    pub fn c_guVecSub(a: *const guVector, b: *const guVector, ab: *mut guVector);
}
extern "C" {
    pub fn c_guVecScale(src: *const guVector, dst: *mut guVector, scale: f32_);
}
extern "C" {
    pub fn c_guVecNormalize(v: *mut guVector);
}
extern "C" {
    pub fn c_guVecMultiply(mt: *mut [f32_; 4usize], src: *const guVector, dst: *mut guVector);
}
extern "C" {
    pub fn c_guVecCross(a: *const guVector, b: *const guVector, axb: *mut guVector);
}
extern "C" {
    pub fn c_guVecMultiplySR(mt: *mut [f32_; 4usize], src: *const guVector, dst: *mut guVector);
}
extern "C" {
    pub fn c_guVecDotProduct(a: *const guVector, b: *const guVector) -> f32_;
}
extern "C" {
    pub fn c_guQuatAdd(a: *const guQuaternion, b: *const guQuaternion, ab: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatSub(a: *const guQuaternion, b: *const guQuaternion, ab: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatMultiply(a: *const guQuaternion, b: *const guQuaternion, ab: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatNormalize(a: *const guQuaternion, d: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatInverse(a: *const guQuaternion, d: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatMtx(a: *mut guQuaternion, m: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxIdentity(mt: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxCopy(src: *mut [f32_; 4usize], dst: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxConcat(a: *mut [f32_; 4usize], b: *mut [f32_; 4usize], ab: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxScale(mt: *mut [f32_; 4usize], xS: f32_, yS: f32_, zS: f32_);
}
extern "C" {
    pub fn c_guMtxScaleApply(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xS: f32_,
        yS: f32_,
        zS: f32_,
    );
}
extern "C" {
    pub fn c_guMtxApplyScale(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xS: f32_,
        yS: f32_,
        zS: f32_,
    );
}
extern "C" {
    pub fn c_guMtxTrans(mt: *mut [f32_; 4usize], xT: f32_, yT: f32_, zT: f32_);
}
extern "C" {
    pub fn c_guMtxTransApply(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xT: f32_,
        yT: f32_,
        zT: f32_,
    );
}
extern "C" {
    pub fn c_guMtxApplyTrans(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xT: f32_,
        yT: f32_,
        zT: f32_,
    );
}
extern "C" {
    pub fn c_guMtxInverse(src: *mut [f32_; 4usize], inv: *mut [f32_; 4usize]) -> u32_;
}
extern "C" {
    pub fn c_guMtxInvXpose(src: *mut [f32_; 4usize], xPose: *mut [f32_; 4usize]) -> u32_;
}
extern "C" {
    pub fn c_guMtxTranspose(src: *mut [f32_; 4usize], xPose: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxRotRad(mt: *mut [f32_; 4usize], axis: ::libc::c_char, rad: f32_);
}
extern "C" {
    pub fn c_guMtxRotTrig(mt: *mut [f32_; 4usize], axis: ::libc::c_char, sinA: f32_, cosA: f32_);
}
extern "C" {
    pub fn c_guMtxRotAxisRad(mt: *mut [f32_; 4usize], axis: *mut guVector, rad: f32_);
}
extern "C" {
    pub fn c_guMtxReflect(m: *mut [f32_; 4usize], p: *const guVector, n: *const guVector);
}
extern "C" {
    pub fn c_guMtxQuat(m: *mut [f32_; 4usize], a: *const guQuaternion);
}
extern "C" {
    pub fn guMtx44Identity(mt: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn guMtx44Copy(src: *mut [f32_; 4usize], dst: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn guMtx44Inverse(src: *mut [f32_; 4usize], inv: *mut [f32_; 4usize]) -> u32_;
}
#[doc = " \\typedef u32 lwp_t\n\\brief typedef for the thread context handle"]
pub type lwp_t = u32_;
#[doc = " \\typedef u32 lwpq_t\n\\brief typedef for the thread queue's context handle"]
pub type lwpq_t = u32_;
extern "C" {
    #[doc = " \\fn s32 LWP_CreateThread(lwp_t *thethread,void* (*entry)(void *),void *arg,void *stackbase,u32 stack_size,u8 prio)\n\\brief Spawn a new thread with the given parameters\n\\param[out] thethread pointer to a lwp_t handle\n\\param[in] entry pointer to the thread's entry function.\n\\param[in] arg pointer to an argument for the thread's entry function.\n\\param[in] stackbase pointer to the threads stackbase address. If NULL, the stack is allocated by the thread system.\n\\param[in] stack_size size of the provided stack. If 0, the default STACKSIZE of 8Kb is taken.\n\\param[in] prio priority on which the newly created thread runs.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_CreateThread(
        thethread: *mut lwp_t,
        entry: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> *mut ::libc::c_void,
        >,
        arg: *mut ::libc::c_void,
        stackbase: *mut ::libc::c_void,
        stack_size: u32_,
        prio: u8_,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_SuspendThread(lwp_t thethread)\n\\brief Suspend the given thread.\n\\param[in] thethread handle to the thread context which should be suspended.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_SuspendThread(thethread: lwp_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_ResumeThread(lwp_t thethread)\n\\brief Resume the given thread.\n\\param[in] thethread handle to the thread context which should be resumed.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_ResumeThread(thethread: lwp_t) -> s32;
}
extern "C" {
    #[doc = " \\fn BOOL LWP_ThreadIsSuspended(lwp_t thethread)\n\\brief Test whether the given thread is suspended or not\n\\param[in] thethread handle to the thread context which should be tested.\n\n\\return TRUE or FALSE"]
    pub fn LWP_ThreadIsSuspended(thethread: lwp_t) -> BOOL;
}
extern "C" {
    #[doc = " \\fn lwp_t LWP_GetSelf(void)\n\\brief Return the handle to the current thread.\n\n\\return thread context handle"]
    pub fn LWP_GetSelf() -> lwp_t;
}
extern "C" {
    #[doc = " \\fn void LWP_SetThreadPriority(lwp_t thethread,u32 prio)\n\\brief Set the priority of the given thread.\n\\param[in] thethread handle to the thread context whos priority should be changed. If NULL, the current thread will be taken.\n\\param[in] prio new priority to set\n\n\\return none"]
    pub fn LWP_SetThreadPriority(thethread: lwp_t, prio: u32_);
}
extern "C" {
    #[doc = " \\fn void LWP_YieldThread(void)\n\\brief Yield the current thread to another one with higher priority or if not running at the same priority which state is runnable.\n\n\\return none"]
    pub fn LWP_YieldThread();
}
extern "C" {
    #[doc = " \\fn void LWP_Reschedule(u32 prio)\n\\brief Reschedule all threads running at the given priority\n\\param[in] prio priority level to reschedule\n\n\\return none"]
    pub fn LWP_Reschedule(prio: u32_);
}
extern "C" {
    #[doc = " \\fn s32 LWP_JoinThread(lwp_t thethread,void **value_ptr)\n\\brief Join the given thread.\n\\param[in] thethread handle to the thread's context which should be joined to wait on termination.\n\\param[in] value_ptr pointer-pointer to a variable to receive the return code of the terminated thread.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_JoinThread(thethread: lwp_t, value_ptr: *mut *mut ::libc::c_void) -> s32;
}
extern "C" {
    #[doc = " \\fn void LWP_InitQueue(lwpq_t *thequeue)\n\\brief Initialize the thread synchronization queue\n\\param[in] thequeue pointer to a lwpq_t handle.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_InitQueue(thequeue: *mut lwpq_t) -> s32;
}
extern "C" {
    #[doc = " \\fn void LWP_CloseQueue(lwpq_t thequeue)\n\\brief Close the thread synchronization queue and releas the handle\n\\param[in] thequeue handle to the thread's synchronization queue\n\n\\return none"]
    pub fn LWP_CloseQueue(thequeue: lwpq_t);
}
extern "C" {
    #[doc = " \\fn s32 LWP_ThreadSleep(lwpq_t thequeue)\n\\brief Pushes the current thread onto the given thread synchronization queue and sets the thread state to blocked.\n\\param[in] thequeue handle to the thread's synchronization queue to push the thread on\n\n\\return none"]
    pub fn LWP_ThreadSleep(thequeue: lwpq_t) -> s32;
}
extern "C" {
    #[doc = " \\fn void LWP_ThreadSignal(lwpq_t thequeue)\n\\brief Signals one thread to be revmoved from the thread synchronization queue and sets it back to running state.\n\\param[in] thequeue handle to the thread's synchronization queue to pop the blocked thread off\n\n\\return none"]
    pub fn LWP_ThreadSignal(thequeue: lwpq_t);
}
extern "C" {
    #[doc = " \\fn void LWP_ThreadBroadcast(lwpq_t thequeue)\n\\brief Removes all blocked threads from the thread synchronization queue and sets them back to running state.\n\\param[in] thequeue handle to the thread's synchronization queue to pop the blocked threads off\n\n\\return none"]
    pub fn LWP_ThreadBroadcast(thequeue: lwpq_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wgpipe {
    pub U8: __BindgenUnionField<vu8>,
    pub S8: __BindgenUnionField<vs8>,
    pub U16: __BindgenUnionField<vu16>,
    pub S16: __BindgenUnionField<vs16>,
    pub U32: __BindgenUnionField<vu32>,
    pub S32: __BindgenUnionField<vs32>,
    pub F32: __BindgenUnionField<vf32>,
    pub bindgen_union_field: u32,
}
pub type WGPipe = _wgpipe;
#[doc = " \\typedef struct _gx_color GXColor\n \\brief Structure used to pass colors to some GX functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_color {
    #[doc = "< Red color component."]
    pub r: u8_,
    #[doc = "< Green color component."]
    pub g: u8_,
    #[doc = "< Blue alpha component."]
    pub b: u8_,
    #[doc = "< Alpha component. If a function does not use the alpha value, it is safely ignored."]
    pub a: u8_,
}
#[doc = " \\typedef struct _gx_color GXColor\n \\brief Structure used to pass colors to some GX functions."]
pub type GXColor = _gx_color;
#[doc = " \\typedef struct _gx_colors10 GXColorS10\n \\brief Structure used to pass signed 10-bit colors to some GX functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_colors10 {
    #[doc = "< Red color component."]
    pub r: s16,
    #[doc = "< Green color component."]
    pub g: s16,
    #[doc = "< Blue color component."]
    pub b: s16,
    #[doc = "< Alpha component. If a function does not use the alpha value, it is safely ignored."]
    pub a: s16,
}
#[doc = " \\typedef struct _gx_colors10 GXColorS10\n \\brief Structure used to pass signed 10-bit colors to some GX functions."]
pub type GXColorS10 = _gx_colors10;
#[doc = " \\typedef struct _gx_texobj GXTexObj\n \\brief Object containing information about a texture.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitTexObj*()\n function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTexObj) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_texobj {
    pub val: [u32_; 8usize],
}
#[doc = " \\typedef struct _gx_texobj GXTexObj\n \\brief Object containing information about a texture.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitTexObj*()\n function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTexObj) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
pub type GXTexObj = _gx_texobj;
#[doc = " \\typedef struct _gx_tlutobj GXTlutObj\n \\brief Object containing information on a TLUT.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutObj()\n function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTlutObj) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_tlutobj {
    pub val: [u32_; 3usize],
}
#[doc = " \\typedef struct _gx_tlutobj GXTlutObj\n \\brief Object containing information on a TLUT.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutObj()\n function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTlutObj) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
pub type GXTlutObj = _gx_tlutobj;
#[doc = " \\typedef struct _gx_texreg GXTexRegion\n \\brief Object containing information on a texture cache region.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the\n GX_InitTexCacheRegion() function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTexRegion) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_texreg {
    pub val: [u32_; 4usize],
}
#[doc = " \\typedef struct _gx_texreg GXTexRegion\n \\brief Object containing information on a texture cache region.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the\n GX_InitTexCacheRegion() function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTexRegion) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
pub type GXTexRegion = _gx_texreg;
#[doc = " \\typedef struct _gx_tlutreg GXTlutRegion\n \\brief Object containing information on a TLUT cache region.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutRegion()\n function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTlutRegion) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_tlutreg {
    pub val: [u32_; 4usize],
}
#[doc = " \\typedef struct _gx_tlutreg GXTlutRegion\n \\brief Object containing information on a TLUT cache region.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutRegion()\n function to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXTlutRegion) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
pub type GXTlutRegion = _gx_tlutreg;
#[doc = " \\typedef _gx_litobj GXLightObj\n \\brief Object containing information on a light.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitLight*() functions\n to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXLightObj) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_litobj {
    pub val: [u32_; 16usize],
}
#[doc = " \\typedef _gx_litobj GXLightObj\n \\brief Object containing information on a light.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitLight*() functions\n to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXLightObj) \\endcode\n\n \\details but the internal data representation is not visible to the application."]
pub type GXLightObj = _gx_litobj;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vtx {
    pub x: f32_,
    pub y: f32_,
    pub z: f32_,
    pub s: u16_,
    pub t: u16_,
    pub rgba: u32_,
}
pub type Vtx = _vtx;
#[doc = " \\struct GXVtxDesc\n \\brief Structure describing how a single vertex attribute will be referenced.\n\n \\details An array of these structures can be used to describe all the attributes in a vertex. The attribute <tt>GX_VA_NULL</tt> should be\n used to mark the end of the array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXVtxDesc {
    #[doc = "< \\ref vtxattr for this element."]
    pub attr: u8_,
    #[doc = "< \\ref vtxattrin for this element."]
    pub type_: u8_,
}
#[doc = " \\struct GXVtxAttrFmt\n \\brief Structure describing the attribute format for one attribute.\n\n \\details An array of these structures can be used to describe the format of all attributes in a vertex. The attribute <tt>GX_VA_NULL</tt>\n should be used to mark the end of the array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXVtxAttrFmt {
    #[doc = "< \\ref vtxattr for this element."]
    pub vtxattr: u32_,
    #[doc = "< \\ref comptype for this element."]
    pub comptype: u32_,
    #[doc = "< \\ref compsize for this element."]
    pub compsize: u32_,
    #[doc = "< Number of fractional bits for a fixed-point number."]
    pub frac: u32_,
}
#[doc = " \\struct GXFifoObj\n \\brief Object describing a graphics FIFO.\n\n \\details This structure contains precompiled register state setting commands and data. The application must use the GX_InitFifo*() functions\n to initialize or change this object. The proper size of the object is returned by\n\n \\code sizeof(GXFifoObj) \\endcode\n\n but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXFifoObj {
    pub pad: [u8_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXTexReg {
    pub dummy: [u8_; 4usize],
}
#[doc = " \\struct GXFogAdjTbl\n \\brief Fog range adjustment parameter table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXFogAdjTbl {
    #[doc = "< u4.8 format range parameter."]
    pub r: [u16_; 10usize],
}
#[doc = " \\typedef void (*GXBreakPtCallback)(void)\n \\brief function pointer typedef for the GP breakpoint-token callback"]
pub type GXBreakPtCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " \\typedef void (*GXDrawDoneCallback)(void)\n \\brief function pointer typedef for the GP drawdone-token callback"]
pub type GXDrawDoneCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " \\typedef void (*GXDrawSyncCallback)(u16 token)\n \\brief function pointer typedef for the drawsync-token callback\n \\param[out] token tokenvalue most recently encountered."]
pub type GXDrawSyncCallback = ::core::option::Option<unsafe extern "C" fn(token: u16_)>;
#[doc = " \\typedef GXTexRegion* (*GXTexRegionCallback)(GXTexObj *obj,u8 mapid)\n \\brief function pointer typedef for the texture region callback\n \\param[out] token tokenvalue most recently encountered."]
pub type GXTexRegionCallback = ::core::option::Option<
    unsafe extern "C" fn(obj: *mut GXTexObj, mapid: u8_) -> *mut GXTexRegion,
>;
#[doc = " \\typedef GXTlutRegion* (*GXTlutRegionCallback)(u32 tlut_name)\n \\brief function pointer typedef for the TLUT region callback\n \\param[out] token tokenvalue most recently encountered."]
pub type GXTlutRegionCallback =
    ::core::option::Option<unsafe extern "C" fn(tlut_name: u32_) -> *mut GXTlutRegion>;
extern "C" {
    pub static wgPipe: *mut WGPipe;
}
extern "C" {
    #[doc = " \\fn GXFifoObj* GX_Init(void *base,u32 size)\n \\brief Initializes the graphics processor to its initial state.\n\n \\details This function sets the default state of the graphics processor and should be called before any other GX functions.\n This function sets up an immediate-mode method of communicating graphics commands from the CPU to the Graphics Processor\n (GP). This function will initialize a FIFO and attach it to both the CPU and GP. The CPU will write commands to the FIFO\n and the GP will read the commands. This function returns a pointer to the initialized FIFO. The application must allocate\n the memory for the FIFO. The parameter \\a base is a pointer to the allocated main memory and must be aligned to 32B. \\a size\n is the size of the FIFO in bytes and must be a multiple of 32B. Refer to additional notes in GX_InitFifoBase() concerning\n the FIFO memory.\n\n \\note It is also possible to override the default immediate-mode style and instead buffer the graphics for frame <i>n+1</i>\n while the GP is reading the graphics for frame <i>n</i>. See GX_SetCPUFifo() and GX_SetGPFifo() for further information.<br><br>\n\n \\note This function also designates the calling thread as the default GX thread; i.e., it assumes the calling thread is the\n one responsible for generating graphics data. This thread will be the thread to be suspended when the FIFO gets too full.\n The current GX thread can be changed by calling GX_SetCurrentGXThread().\n\n \\param[in] base pointer to the GX FIFO buffer base address. Must be aligned on a 32 Byte boundery.\n \\param[in] size size of buffer. Must be a multiple of 32.\n\n \\return pointer to the intialized GXFifoObj object."]
    pub fn GX_Init(base: *mut ::libc::c_void, size: u32_) -> *mut GXFifoObj;
}
extern "C" {
    #[doc = " \\fn void GX_InitFifoBase(GXFifoObj *fifo,void *base,u32 size)\n \\brief Describes the area of main memory that will be used for this \\a fifo.\n\n The Graphics FIFO is the mechanism used to communicate graphics commands from the CPU to the Graphics Processor (GP). The FIFO\n base pointer should be 32-byte aligned. memalign() can return 32-byte aligned pointers. The size should also be a multiple of\n 32B.\n\n The CPU's write-gather pipe is used to write data to the FIFO. Therefore, the FIFO memory area must be forced out of the CPU\n cache prior to being used. DCInvalidateRange() may be used for this purpose. Due to the mechanics of flushing the write-gather\n pipe, the FIFO memory area should be at least 32 bytes larger than the maximum expected amount of data stored. Up to 32 NOPs\n may be written at the end during flushing.\n\n \\note GX_Init() also takes the arguments \\a base and \\a size and initializes a FIFO using these values and attaches the FIFO\n to both the CPU and GP. The application must allocate the memory for the graphics FIFO before calling GX_Init(). Therefore, it\n is not necessary to call this function unless you want to resize the default FIFO sometime after GX_Init() has been called or\n you are creating a new FIFO. The minimum size is 64kB defined by <tt>GX_FIFO_MINSIZE</tt>.<br><br>\n\n \\note This function will also set the read and write pointers for the FIFO to the base address, so ordinarily it is not\n necessary to call GX_InitFifoPtrs() when initializing the FIFO. In addition, This function sets the FIFO's high water mark to\n (size-16kB) and the low water mark to (size/2), so it is also not necessary to call GX_InitFifoLimits().\n\n \\param[in] fifo the fifo struct to use\n \\param[in] base ptr to the base of allocation; must be 32-byte aligned\n \\param[in] size size of the FIFO in bytes; must be multiple of 32; size must be <tt>GX_FIFO_MINSIZE</tt> or larger\n\n \\return none"]
    pub fn GX_InitFifoBase(fifo: *mut GXFifoObj, base: *mut ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitFifoLimits(GXFifoObj *fifo,u32 hiwatermark,u32 lowatermark)\n \\brief Sets the high and low water mark for the \\a fifo.\n\n \\details The high and low water marks are used in <i>immediate-mode</i>, i.e. when the \\a fifo is attached to both the CPU and\n Graphics Processor (GP) (see GX_SetCPUFifo() and GX_SetGPFifo()).\n\n The hardware keeps track of the number of bytes between the read and write pointers. This number represents how full the FIFO is,\n and when it is greater than or equal to the \\a hiwatermark, the hardware issues an interrupt. The GX API will suspend sending\n graphics to the Graphics FIFO until it has emptied to a certain point. The \\a lowatermark is used to set the point at which the\n FIFO is empty enough to resume sending graphics commands to the  FIFO. Both \\a hiwatermark and \\a lowatermark should be in\n multiples of 32B. The count for \\a lowatermark should be less than \\a hiwatermark. Of course, \\a hiwatermark and \\a lowatermark\n must be less than the size of the FIFO.\n\n \\note When the FIFO is only attached to the CPU or only attached to the GP, the high and low water mark interrupts are disabled.\n\n \\param[in] fifo the fifo struct to use\n \\param[in] hiwatermark number of bytes to be queued before libogc stops writing commands to the FIFO\n \\param[in] lowatermark number of bytes to be queued before libogc resumes writing commands to the FIFO\n\n \\return none"]
    pub fn GX_InitFifoLimits(fifo: *mut GXFifoObj, hiwatermark: u32_, lowatermark: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitFifoPtrs(GXFifoObj *fifo,void *rd_ptr,void *wt_ptr)\n \\brief Sets the \\a fifo read and write pointers.\n\n \\note This is normally done only during initialization of the FIFO. After that, the graphics hardware manages the FIFO pointers.\n\n \\param[in] fifo the fifo struct to use\n \\param[in] rd_ptr the pointer to use for the FIFO read pointer; must be 32-byte aligned\n \\param[in] wt_ptr the pointer to use for the FIFO write pointer; must be 32-byte aligned\n\n \\return none"]
    pub fn GX_InitFifoPtrs(
        fifo: *mut GXFifoObj,
        rd_ptr: *mut ::libc::c_void,
        wt_ptr: *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = " \\fn void GX_GetFifoPtrs(const GXFifoObj *fifo,void **rd_ptr,void **wt_ptr)\n \\brief Returns the current value of the Graphics FIFO read and write pointers.\n\n \\note See GX_EnableBreakPt() for an example of why you would do this.\n\n \\param[in] fifo pointer to a FIFO struct\n \\param[out] rd_ptr address of the FIFO read pointer\n \\param[out] wt_ptr address of the FIFO write pointer\n\n \\return none"]
    pub fn GX_GetFifoPtrs(
        fifo: *const GXFifoObj,
        rd_ptr: *mut *mut ::libc::c_void,
        wt_ptr: *mut *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetCPUFifo(GXFifoObj *fifo)\n \\brief Attaches a FIFO to the CPU.\n\n \\note If the FIFO being attached is one already attached to the GP, the FIFO can be considered to be in immediate mode. If not,\n the CPU can write commands, and the GP will execute them when the GP attaches to this FIFO (multi-buffered mode).\n\n \\param[in] fifo fifo struct containing info on the FIFO to attach\n\n \\return none"]
    pub fn GX_SetCPUFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = " \\fn void GX_SetGPFifo(GXFifoObj *fifo)\n \\brief Attaches \\a fifo to the GP.\n\n \\note If the FIFO is also attached to the CPU, the system is in immediate-mode, and the fifo acts like a true FIFO. In immediate-mode,\n graphics commands are fed directly from the CPU to the GP. In immediate-mode the FIFO's high and low water marks are active. The high\n and low water marks implement the flow-control mechanism between the CPU and GP. When the FIFO becomes more full than the high water\n mark, the CPU will stop writing graphics commands into the FIFO.  When the FIFO empties to a point lower than the low water mark, the\n CPU will resume writing graphics commands into the FIFO. The high and low water marks are set when intializing the FIFO using\n GX_InitFifoLimits().<br><br>\n\n \\note If the FIFO is only attached to the GP, the FIFO acts like a buffer. In this case, high and low water marks are disabled, and\n the GP reads the FIFO until it is empty. Before attaching a new FIFO to the GP, you should make sure the previous FIFO is empty, using\n the \\a cmdIdle status returned by GX_GetGPStatus().<br><br>\n\n \\note The break point mechanism can be used to force the FIFO to stop reading commands at a certain point; see GX_EnableBreakPt().\n\n \\param[in] fifo struct containing info on the FIFO to attach\n\n \\return none"]
    pub fn GX_SetGPFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = " \\fn void GX_GetCPUFifo(GXFifoObj *fifo)\n \\brief Copies the information from the currently attached CPU FIFO into \\a fifo.\n\n \\param[out] fifo the object to copy the current CPU FIFO object data into\n\n \\return none"]
    pub fn GX_GetCPUFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = " \\fn void GX_GetGPFifo(GXFifoObj *fifo)\n \\brief Copies the information from the currently attached GP FIFO info \\a fifo.\n\n \\param[out] fifo the object to copy the current GP FIFO object data into\n\n \\return none"]
    pub fn GX_GetGPFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = " \\fn void* GX_GetFifoBase(const GXFifoObj *fifo)\n \\brief Get the base address for a given \\a fifo.\n\n \\param[in] fifo the object to get the address from\n\n \\return pointer to the base address of the FIFO in main memory."]
    pub fn GX_GetFifoBase(fifo: *const GXFifoObj) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\fn u32 GX_GetFifoCount(const GXFifoObj *fifo)\n \\brief Returns number of cache lines in the FIFO.\n\n \\note The count is incorrect if an overflow has occurred (i.e. you have written more data than the size of the fifo), as the\n hardware cannot detect an overflow in general.\n\n \\param[in] fifo the FIFO to get the count from\n\n \\return number of cache lines in the FIFO"]
    pub fn GX_GetFifoCount(fifo: *const GXFifoObj) -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 GX_GetFifoSize(const GXFifoObj *fifo)\n \\brief Get the size of a given \\a fifo.\n\n \\param[in] fifo the object to get the size from\n\n \\return size of the FIFO, in bytes"]
    pub fn GX_GetFifoSize(fifo: *const GXFifoObj) -> u32_;
}
extern "C" {
    #[doc = " \\fn u8 GX_GetFifoWrap(const GXFifoObj *fifo)\n \\brief Returns a non-zero value if the write pointer has passed the TOP of the FIFO.\n\n \\details Returns true only if the FIFO is attached to the CPU and the FIFO write pointer has passed the top of the FIFO. Use the\n return value to detect whether or not an overflow has occured by initializing the FIFO's write pointer to the base of the FIFO\n before sending any commands to the FIFO.\n\n \\note If the FIFO write pointer is not explicitly set to the base of the FIFO, you cannot rely on this function to detect overflows.\n\n \\param[in] fifo the object to get the wrap status from\n\n \\return wrap value"]
    pub fn GX_GetFifoWrap(fifo: *const GXFifoObj) -> u8_;
}
extern "C" {
    #[doc = " \\fn GXDrawDoneCallback GX_SetDrawDoneCallback(GXDrawDoneCallback cb)\n \\brief Installs a callback that is invoked whenever a DrawDone command is encountered by the GP.\n\n \\details The DrawDone command is sent by GX_SetDrawDone().\n\n \\note By the time the callback is invoked, the GP will already have resumed reading from the FIFO, if there are any commands in it.\n\n \\param[in] cb callback to be invoked when DrawDone is encountered\n\n \\return pointer to the previous callback"]
    pub fn GX_SetDrawDoneCallback(cb: GXDrawDoneCallback) -> GXDrawDoneCallback;
}
extern "C" {
    #[doc = " \\fn GXBreakPtCallback GX_SetBreakPtCallback(GXBreakPtCallback cb)\n \\brief Registers \\a cb as a function to be invoked when a break point is encountered.\n\n \\warning The callback will run with interrupts disabled, so it should terminate as quickly as possible.\n\n \\param[in] cb function to be invoked when the breakpoint is encountered; NULL means no function will run\n\n \\return pointer to the previous callback function"]
    pub fn GX_SetBreakPtCallback(cb: GXBreakPtCallback) -> GXBreakPtCallback;
}
extern "C" {
    #[doc = " \\fn void GX_AbortFrame(void)\n \\brief Aborts the current frame.\n\n \\details This command will reset the entire graphics pipeline, including any commands in the graphics FIFO.\n\n \\note Texture memory will not be reset, so currently loaded textures will still be valid; however, when loading texture using\n GX_PreloadEntireTexture() or TLUTs using GX_LoadTlut(), you must make sure the command completed. You can use the draw sync mechanism to\n do this; see GX_SetDrawSync() and GX_GetDrawSync().\n\n \\return none"]
    pub fn GX_AbortFrame();
}
extern "C" {
    #[doc = " \\fn void GX_Flush(void)\n \\brief Flushes all commands to the GP.\n\n \\details Specifically, it flushes the write-gather FIFO in the CPU to make sure that all commands are sent to the GP.\n\n \\return none"]
    pub fn GX_Flush();
}
extern "C" {
    #[doc = " \\fn void GX_SetMisc(u32 token,u32 value)\n \\brief Sets miscellanous settings in the GP.\n\n \\param[in] token setting to change\n \\param[in] value value to change the setting to\n\n \\return none"]
    pub fn GX_SetMisc(token: u32_, value: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetDrawDone(void)\n \\brief Sends a DrawDone command to the GP.\n\n \\details When all previous commands have been processed and the pipeline is empty, a <i>DrawDone</i> status bit will be set,\n and an interrupt will occur. You can receive notification of this event by installing a callback on the interrupt with\n GX_SetDrawDoneCallback(), or you can poll the status bit with GX_WaitDrawDone(). This function also flushes the write-gather\n FIFO in the CPU to make sure that all commands are sent to the graphics processor.\n\n \\note This function is normally used in multibuffer mode (see GX_SetCPUFifo()). In immediate mode, the GX_DrawDone() command\n can be used, which both sends the command and stalls until the DrawDone status is true.\n\n \\return none"]
    pub fn GX_SetDrawDone();
}
extern "C" {
    #[doc = " \\fn void GX_WaitDrawDone(void)\n \\brief Stalls until <i>DrawDone</i> is encountered by the GP.\n\n \\details It means all graphics commands sent before this DrawDone command have executed and the last pixel has been written to\n the frame buffer. You may want to execute some non-graphics operations between executing GX_SetDrawDone() and this function, but\n if you simply want to wait and have nothing to execute, you can use GX_DrawDone().\n\n \\note This function is normally used in immediate mode (see GX_SetCPUFifo()). In multibuffer mode, sending the '<i>done</i>' command is\n separated from polling the '<i>done</i>' status (see GX_SetDrawDone() and GX_WaitDrawDone()).\n\n \\return none"]
    pub fn GX_WaitDrawDone();
}
extern "C" {
    #[doc = " \\fn u16 GX_GetDrawSync(void)\n \\brief Returns the value of the token register, which is written using the GX_SetDrawSync() function.\n\n \\return the value of the token register."]
    pub fn GX_GetDrawSync() -> u16_;
}
extern "C" {
    #[doc = " \\fn void GX_SetDrawSync(u16 token)\n \\brief This function sends a token into the command stream.\n\n \\details When the token register is set, an interrupt will also be received by the CPU. You can install a callback on this interrupt\n          with GX_SetDrawSyncCallback(). Draw syncs can be used to notify the CPU that the graphics processor is finished using a shared\n          resource (a vertex array for instance).\n\n \\param[in] token 16-bit value to write to the token register.\n\n \\return none"]
    pub fn GX_SetDrawSync(token: u16_);
}
extern "C" {
    #[doc = " \\fn GXDrawSyncCallback GX_SetDrawSyncCallback(GXDrawSyncCallback cb)\n \\brief Installs a callback that is invoked whenever a DrawSync token is encountered by the graphics pipeline.\n\n \\details The callback's argument is the value of the token most recently encountered. Since it is possible to\n          miss tokens (graphics processing does not stop while the callback is running), your code should be\n          capable of deducing if any tokens have been missed.\n\n \\param[in] cb callback to be invoked when the DrawSync tokens are encountered in the graphics pipeline.\n\n \\return pointer to the previously set callback function."]
    pub fn GX_SetDrawSyncCallback(cb: GXDrawSyncCallback) -> GXDrawSyncCallback;
}
extern "C" {
    #[doc = " \\fn void GX_DisableBreakPt(void)\n \\brief Allows reads from the FIFO currently attached to the Graphics Processor (GP) to resume.\n\n \\details See GX_EnableBreakPt() for an explanation of the FIFO break point feature.\n\n \\note The breakpoint applies to the FIFO currently attached to the Graphics Processor (GP) (see GX_SetGPFifo()).\n\n \\return none"]
    pub fn GX_DisableBreakPt();
}
extern "C" {
    #[doc = " \\fn void GX_EnableBreakPt(void *break_pt)\n \\brief Sets a breakpoint that causes the GP to halt when encountered.\n\n \\note The break point feature allows the application to have two frames of graphics in the FIFO at the same time, overlapping\n one frame's processing by the graphics processor with another frame's processing by the CPU. For example, suppose you finish\n writing the graphics commands for one frame and are ready to start on the next. First, execute a GX_Flush() command to make\n sure all the data in the CPU write gatherer is flushed into the FIFO. This will also align the FIFO write pointer to a 32B\n boundary. Next, read the value of the current write pointer using GX_GetFifoPtrs(). Write the value of the write pointer as\n the break point address using GX_EnableBreakPt(). When the FIFO read pointer reaches the break point address the hardware\n will disable reads from the FIFO.  The status \\a brkpt, returned by GX_GetGPStatus(), can be polled to detect when the break point\n is reached. The application can then decide when to disable the break point, using GX_DisableBreakPt(), which will allow the FIFO\n to resume reading graphics commands.<br><br>\n\n \\note FIFO reads will stall when the GP FIFO read pointer is equal to the break point address \\a break_pt. To re-enable reads of\n the GP FIFO, use GX_DisableBreakPt().<br><br>\n\n \\note Use GX_SetBreakPtCallback() to set what function runs when the breakpoint is encountered.\n\n \\param[in] break_pt address for GP to break on when read.\n\n \\return none"]
    pub fn GX_EnableBreakPt(break_pt: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " \\fn void GX_DrawDone(void)\n \\brief Sends a DrawDone command to the GP and stalls until its subsequent execution.\n\n \\note This function is equivalent to calling GX_SetDrawDone() then GX_WaitDrawDone().\n\n \\return none"]
    pub fn GX_DrawDone();
}
extern "C" {
    #[doc = " \\fn void GX_TexModeSync(void)\n \\brief Inserts a synchronization command into the graphics FIFO. When the Graphics Processor sees this command, it will\n allow the texture pipeline to flush before continuing.\n\n \\details This command is necessary when changing the usage of regions of texture memory from preloaded or TLUT to cached areas.\n It makes sure that the texture pipeline is finished with that area of the texture memory prior to changing its usage.\n This function should be called prior to drawing any primitives that uses the texture memory region in its new mode. It is not\n necessary to call this command when changing texture memory regions from cached to preloaded (or TLUT), since the commands to\n load the regions with data will cause the necessary synchronization to happen automatically.\n\n \\return none"]
    pub fn GX_TexModeSync();
}
extern "C" {
    #[doc = " \\fn void GX_InvVtxCache(void)\n \\brief Invalidates the vertex cache.\n\n \\details Specifically, this functions invalidates the vertex cache tags. This function should be used whenever you relocate or modify\n data that is read by, or may be cached by, the vertex cache. The invalidate is very fast, taking only two Graphics Processor (GP) clock\n cycles to complete.\n\n \\note The vertex cache is used to cache indexed attribute data. Any attribute that is set to <tt>GX_INDEX8</tt> or <tt>GX_INDEX16</tt> in the current\n vertex descriptor (see GX_SetVtxDesc()) is indexed. Direct data bypasses the vertex cache. Direct data is any attribute that is set to\n <tt>GX_DIRECT</tt> in the current vertex descriptor.\n\n \\return none"]
    pub fn GX_InvVtxCache();
}
extern "C" {
    #[doc = " \\fn void GX_ClearVtxDesc(void)\n \\brief Clears all vertex attributes of the current vertex descriptor to GX_NONE.\n\n \\note The same functionality can be obtained using GX_SetVtxDescv(), however using GX_ClearVtxDesc() is much more efficient.\n\n \\return none"]
    pub fn GX_ClearVtxDesc();
}
extern "C" {
    #[doc = " \\fn void GX_LoadProjectionMtx(Mtx44 mt,u8 type)\n \\brief Sets the projection matrix.\n\n \\note Only two types of projection matrices are supported: <tt>GX_PERSPECTIVE</tt> or <tt>GX_ORTHOGRAPHIC</tt>.\n\n \\param[in] mt matrix to use for the perspective\n \\param[in] type which perspective type to use\n\n \\return none"]
    pub fn GX_LoadProjectionMtx(mt: *mut [f32_; 4usize], type_: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetViewport(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ)\n \\brief Sets the viewport rectangle in screen coordinates.\n\n \\details The screen origin (\\a xOrig = 0.0f, \\a yOrig = 0.0f) is at the top left corner of the display. Floating point arguments allow the\n viewport to be adjusted by 1/2 line for interlaced field rendering modes; see GX_SetViewportJitter(). The viewport depth parameters are normalized coordinates\n from 0.0f - 1.0f. The GX API will convert the depth range values to proper scale values depending on the type and format of the Z-buffer.\n\n \\note You should avoid using negative values for \\a xOrig or \\a yOrig. While this may work, it may cause problems with points and lines being clipped incorrectly. If\n you need to shift the viewport up or left, consider using GX_SetScissorBoxOffset() instead.\n\n \\param[in] xOrig left-most X coordinate on the screen\n \\param[in] yOrig top-most Y coordinate on the screen\n \\param[in] wd width of the viewport\n \\param[in] ht height of the viewport\n \\param[in] nearZ value to use for near depth scale\n \\param[in] farZ value to use for far depth scale\n\n \\return none"]
    pub fn GX_SetViewport(xOrig: f32_, yOrig: f32_, wd: f32_, ht: f32_, nearZ: f32_, farZ: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetViewportJitter(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ,u32 field)\n \\brief Sets the viewport and adjusts the viewport's line offset for interlaced field rendering.\n\n \\details Depending on whether the viewport starts on an even or odd line, and whether the next \\a field to be rendered is\n even or odd, the viewport may be adjusted by half a line. This has the same effect as slightly tilting the camera down and is necessary\n for interlaced rendering. No other camera adjustment (i.e. don't change the projection matrix) is needed for interlaced field rendering.\n\n \\note To set a viewport <i>without</i> jitter, use GX_SetViewport().\n\n \\param[in] xOrig left-most X coordinate on the screen\n \\param[in] yOrig top-most Y coordinate on the screen\n \\param[in] wd width of the viewport\n \\param[in] ht height of the viewport\n \\param[in] nearZ value to use for near depth scale\n \\param[in] farZ value to use for far depth scale\n \\param[in] field whether the next field is even (0) or odd (1)\n\n \\return none"]
    pub fn GX_SetViewportJitter(
        xOrig: f32_,
        yOrig: f32_,
        wd: f32_,
        ht: f32_,
        nearZ: f32_,
        farZ: f32_,
        field: u32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetChanCtrl(s32 channel,u8 enable,u8 ambsrc,u8 matsrc,u8 litmask,u8 diff_fn,u8 attn_fn)\n \\brief Sets the lighting controls for a particular color channel.\n\n \\details The color channel can have one or more (up to 8) lights associated with it, set using \\a litmask. The \\a diff_fn and \\a attn_fn parameters\n control the lighting equation for all lights associated with this channel; the \\a ambsrc and \\a matsrc can be used to select whether the input\n source colors come from register colors or vertex colors. When the channel \\a enable is set to <tt>GX_FALSE</tt>, the material color source (set by \\a matsrc)\n is passed through as the channel's output color. When the channel \\a enable is <tt>GX_TRUE</tt>, the output color depends on the settings of the other\n controls (i.e., the lighting equation). GX_Init() sets the \\a enable for all channels to <tt>GX_FALSE</tt>. This function only configures the lighting\n channel; to output the result of the channel computation, use GX_SetNumChans().\n\n \\note Even though channels <tt>GX_COLOR0</tt> and <tt>GX_ALPHA0</tt> are controlled separately for lighting, they are rasterized together as one RGBA color, effectively\n <tt>GX_COLOR0A0</tt>. The same is true for <tt>GX_COLOR1</tt> and <tt>GX_ALPHA1</tt>-- effectively, they are rasterized as <tt>GX_COLOR1A1</tt>. Since there is only one rasterizer for\n color in the graphics hardware, you must choose which color to rasterize for each stage in the Texture Environment (TEV) unit. This is accomplished\n using GX_SetTevOrder().<br><br>\n\n \\note In order to use a vertex color in channel <tt>GX_COLOR1A1</tt>, two colors per vertex must be supplied, i.e. both <tt>GX_VA_CLR0</tt> and <tt>GX_VA_CLR1</tt> must be\n enabled in the current vertex descriptor. If only <tt>GX_VA_CLR0</tt> <b>or</b> <tt>GX_VA_CLR1</tt> is enabled in the current vertex descriptor, the vertex color is\n directed to the channel <tt>GX_VA_COLOR0A0</tt>.<br><br>\n\n \\note When \\a ambsrc is set to <tt>GX_SRC_REG</tt>, the color set by GX_SetChanAmbColor() is used as the ambient color. When \\a matsrc is <tt>GX_SRC_REG</tt>, the color set\n by GX_SetChanMatColor() is used as the material color.\n\n \\param[in] channel color channel to use\n \\param[in] enable whether or not to enable lighting for this channel\n \\param[in] ambsrc source for the ambient color\n \\param[in] matsrc source for the material color\n \\param[in] litmask \\ref lightid or IDs to associate with this channel\n \\param[in] diff_fn \\ref difffn to use\n \\param[in] attn_fn \\ref attenfunc to use\n\n \\return none"]
    pub fn GX_SetChanCtrl(
        channel: s32,
        enable: u8_,
        ambsrc: u8_,
        matsrc: u8_,
        litmask: u8_,
        diff_fn: u8_,
        attn_fn: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetChanAmbColor(s32 channel,GXColor color)\n \\brief Sets the ambient color register for color channel \\a chan.\n\n \\details This color will be used by the channel as the ambient color if the ambient source, set by GX_SetChanCtrl(), is <tt>GX_SRC_REG</tt>.\n\n \\param[in] channel channel to set\n \\param[in] color color to set it to\n\n \\return none"]
    pub fn GX_SetChanAmbColor(channel: s32, color: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_SetChanMatColor(s32 channel,GXColor color)\n \\brief Sets the material color register for color channel \\a chan.\n\n \\details This color will be used by the channel as the material color if the material source, set by GX_SetChanCtrl(), is <tt>GX_SRC_REG</tt>.\n\n \\param[in] channel channel to set\n \\param[in] color color to set it to\n\n \\return none"]
    pub fn GX_SetChanMatColor(channel: s32, color: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_SetArray(u32 attr,void *ptr,u8 stride)\n \\brief Sets the array base pointer and stride for a single attribute.\n\n \\details The array base and stride are used to compute the address of indexed attribute data using the equation:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>attr_addr</i> = \\a ptr + <i>attr_idx</i> * \\a stride\n\n When drawing a graphics primitive that has been enabled to use indexed attributes (see GX_SetVtxDesc()), <i>attr_idx</i> is supplied in the vertex\n data. The format and size of the data in the array must also be described using GX_SetVtxAttrFmt(). You can also index other data, such as\n matrices (see GX_LoadPosMtxIdx(), GX_LoadNrmMtxIdx3x3(), and GX_LoadTexMtxIdx()), and light objects (see GX_LoadLightObjIdx()). In the case\n of matrices and light objects, the size and format of the data to be loaded is implied by the function call.\n\n There is a base pointer, \\a ptr, for each type of attribute as well as for light data and matrices. Each attribute can be stored in its own\n array for maximum data compression (i.e., removal of redundant attribute data). The \\a stride is in byte units and is the distance between\n attributes in the array.\n\n \\note Indexed data is loaded into a vertex cache in the graphics processor. The vertex cache fetches 32B of data for each cache miss;\n therefore, there is a small performance benefit to aligning attribute arrays to 32B, and possibly for arranging vertex data so that it\n doesn't span 32B boundaries. Conveniently enough, memalign() returns 32-byte aligned pointers. For static data arrays, you can use the\n ATTRIBUTE_ALIGN(32) attribute macro to align the \\a ptr to 32B.\n\n \\param[in] attr \\ref vtxattr that the array is storing\n \\param[in] ptr pointer to the array itself\n \\param[in] stride stride (in bytes) between each element in the array\n\n \\return none"]
    pub fn GX_SetArray(attr: u32_, ptr: *mut ::libc::c_void, stride: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetVtxAttrFmt(u8 vtxfmt,u32 vtxattr,u32 comptype,u32 compsize,u32 frac)\n \\brief Sets the attribute format (\\a vtxattr) for a single attribute in the Vertex Attribute Table (VAT).\n\n \\details Each attribute format describes the data type (comptype), number of elements (compsize), and fixed point format (frac), if required. The\n are eight vertex formats available in the VAT. The vertex format describes the format of all attributes in a vertex. The application can pre-program\n all eight vertex formats and then select one of them during the actual drawing of geometry (See GX_Begin()). Note that all vertices used to draw a\n particular graphics primitive will have the same format. The vertex format set using this function, along with the current vertex descriptor set\n using GX_SetVtxDesc(), completely define the vertex data format.\n\n \\note The vertex format allows data to be sent to the graphics processor in its most <i>quantized</i> format. The graphics hardware will <i>inverse-quantize</i>\n the data (into floating point format) before it is used. The vertex attribute format is used to communicate the data quantization format to the hardware.<br><br>\n\n \\note <tt>GX_VA_NRM</tt> and <tt>GX_VA_NBT</tt> attributes share the same type. Also, the frac for these attributes is fixed according to the type. The component count\n (compsize) for <tt>GX_VA_NRM</tt> must be set to <tt>GX_NRM_XYZ</tt>. The component count for <tt>GX_VA_NBT</tt> must be set to <tt>GX_NRM_NBT</tt> or <tt>GX_NRM_NBT3</tt>.\n\n \\param[in] vtxfmt \\ref vtxfmt\n \\param[in] vtxattr \\ref vtxattr\n \\param[in] comptype \\ref comptype\n \\param[in] compsize \\ref compsize\n \\param[in] frac number of fractional bits in a fixed-point number\n\n \\return none"]
    pub fn GX_SetVtxAttrFmt(vtxfmt: u8_, vtxattr: u32_, comptype: u32_, compsize: u32_, frac: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetVtxAttrFmtv(u8 vtxfmt,GXVtxAttrFmt *attr_list)\n \\brief Sets multiple attribute formats within a single vertex format.\n\n \\details This is useful when you need to set all the attributes in a vertex format at once (e.g., during graphics initialization).\n\n \\note The constant <tt>GX_MAX_VTXATTRFMT_LISTSIZE</tt> should be used to allocate the list. You can get a current vertex format using GX_GetVtxAttrFmtv().\n\n \\param[in] vtxfmt \\ref vtxfmt\n \\param[in] attr_list pointer to array of GXVtxAttrFmt structs to draw from\n\n \\return none"]
    pub fn GX_SetVtxAttrFmtv(vtxfmt: u8_, attr_list: *mut GXVtxAttrFmt);
}
extern "C" {
    #[doc = " \\fn void GX_SetVtxDesc(u8 attr,u8 type)\n \\brief Sets the \\a type of a single attribute (\\a attr) in the current vertex descriptor.\n\n \\details The current vertex descriptor defines which attributes are present in a vertex and how each attribute is referenced. The current\n vertex descriptor is used by the Graphics Processor (GP) to interpret the graphics command stream produced by the GX API. In particular,\n the current vertex descriptor is used to parse the vertex data that is present in the command stream.\n\n \\param[in] attr \\ref vtxattr\n \\param[in] type \\ref vtxattrin\n\n \\return none"]
    pub fn GX_SetVtxDesc(attr: u8_, type_: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetVtxDescv(GXVtxDesc *attr_list)\n \\brief Sets the type of multiple attributes.\n\n \\details This function is used when more than one attribute needs to be set (e.g., during initialization of geometry).\n\n \\note The constant <tt>GX_MAX_VTXATTRFMT_LISTSIZE</tt> can be used to allocate memory for \\a attr_list\n\n \\param[in] attr_list array of pointers to GXVtxDesc structs; last element of the array should be <tt>GX_VA_NULL</tt>\n\n \\return none"]
    pub fn GX_SetVtxDescv(attr_list: *mut GXVtxDesc);
}
extern "C" {
    #[doc = " \\fn void GX_GetVtxDescv(GXVtxDesc *attr_list)\n \\brief Gets the type of multiple attributes.\n\n \\details This function saves the attributes that are current set. This is usually used in conjunction with GX_SetVtxDescv\n\n \\note The constant <tt>GX_MAX_VTXATTRFMT_LISTSIZE</tt> must be used to allocate memory for \\a attr_list\n\n \\param[in] attr_list array of pointers to GXVtxDesc structs\n\n \\return none"]
    pub fn GX_GetVtxDescv(attr_list: *mut GXVtxDesc);
}
extern "C" {
    #[doc = " \\fn u32 GX_EndDispList(void)\n \\brief Ends a display list and resumes writing graphics commands to the CPU FIFO.\n\n \\details This function returns the size of the display list written to the display list buffer since GX_BeginDispList() was called. If\n the display list size exceeds the size of the buffer allocated, a zero length size will be returned. The display list size is a\n multiple of 32B and any unsed commands in the last 32B will be padded with <tt>GX_NOP</tt>. The size returned should be passed to\n GX_CallDispList() when the display list needs to be executed.\n\n \\note Due to the mechanics of flushing the write-gather pipe (which is used to create the display list), the display buffer should be\n at least 32 bytes larger than the maximum expected amount of data stored. This function calls GX_Flush(), and thus it is not necessary\n to call GX_Flush() explicitly after creating the display list.<br><br>\n\n \\note A display list cannot be nested; i.e., no display list functions (GX_BeginDispList(), GX_EndDispList() and GX_CallDispList()) can\n be called between a GX_BeginDispList() and GX_EndDispList() pair.<br><br>\n\n \\note To execute a display list, use GX_CallDispList().\n\n \\return 0 if display list size exceeds buffer, otherwise gives list size in bytes\n\n \\bug Specifying a display list buffer size for GX_BeginDispList() the exact size that the display list will be (after padding) will cause\n this function to return a very large (and very incorrect) value."]
    pub fn GX_EndDispList() -> u32_;
}
extern "C" {
    #[doc = " \\fn void GX_Begin(u8 primitve,u8 vtxfmt,u16 vtxcnt)\n \\brief Begins drawing of a graphics primitive.\n\n \\details To draw a graphics primitive, a stream of vertex data matching the description of both GX_SetVtxDesc() and GX_SetVtxAttrFmt() is\n enclosed between GX_Begin()/GX_End() pairs. The number of vertices between GX_Begin() and GX_End() must match that specified by the \\a vtxcnt\n parameter. The type of the primitive will determine the minimum number of vertices required. For example, a <tt>GX_TRIANGLES</tt> primitive must\n have at least 3 vertices.\n\n \\note Primitives in which the vertex order is clockwise to the viewer are considered front-facing (for culling purposes).\n\n \\param[in] primitve \\ref primtype to draw\n \\param[in] vtxfmt \\ref vtxfmt to use\n \\param[in] vtxcnt number of vertices being drawn; maximum is 65536"]
    pub fn GX_Begin(primitve: u8_, vtxfmt: u8_, vtxcnt: u16_);
}
extern "C" {
    #[doc = " \\fn void GX_BeginDispList(void *list,u32 size)\n \\brief Begins a display list and disables writes to the FIFO currently attached to the CPU.\n\n \\details After this function is called, GX API functions that normally send command or data into the CPU FIFO will send them to the\n display list buffer instead of the FIFO until GX_EndDispList() is called. Writes to the CPU FIFO will be re-enabled when the function\n GX_EndDispList() executes.\n\n Basically you can put most of GX API commands into a display list. However, since the use of display list can bypass all state\n coherences controlled by GX API in run-time, sometimes it brings some state collisions or incoherences that may lead to unexpected\n behavior or even graphics pipeline hang. The most recommended safe way is putting only primitives (regions enclosed by GX_Begin() and\n GX_End()) that don't cause any state collisions.\n\n \\note The application is expected to allocate the memory for the display list buffer. If the display list exceeds the maximum size\n of the buffer, GX_EndDispList() will return 0. The address of the buffer must be 32-byte aligned; memalign() can return 32-byte-aligned\n pointers. You can use the macro ATTRIBUTE_ALIGN(32) to align statically allocated buffers.<br><br>\n\n \\note The CPU's write-gather pipe is used to write graphics commands to the display list. Therefore, the display list buffer must be\n forced out of the CPU cache prior to being filled. DCInvalidateRange() may be used for this purpose. In addition, due to the mechanics\n of flushing the write-gather pipe, the display list buffer should be at least 63 bytes larger than the maximum expected amount of data\n stored.<br><br>\n\n \\note A display list cannot be nested; i.e., no display list functions (GX_BeginDispList(), GX_EndDispList() and GX_CallDispList()) can\n be called between a GX_BeginDispList() and GX_EndDispList() pair.<br><br>\n\n \\note To execute a display list, use GX_CallDispList().\n\n \\param[in] list 32-byte aligned buffer to hold the list\n \\param[in] size size of the buffer, multiple of 32\n\n \\return none"]
    pub fn GX_BeginDispList(list: *mut ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_CallDispList(void *list,u32 nbytes)\n \\brief Causes the GP to execute graphics commands from the display \\a list instead of from the GP FIFO.\n\n \\details When the number of bytes specified by \\a nbytes have been read, the graphics processor will resume executing\n commands from the graphics FIFO. Graphics commands from a display list are prefetched into a separate 4KB FIFO. This prevents\n any data prefetched for the main graphics command stream from being lost during the display list call.\n\n \\note A display list cannot call another display list.<br><br>\n\n \\note The display list must be padded to a length of 32B. All the data in the display list is interpreted by the graphics\n processor, so any unused memory at the end of a display list should be set to GX_NOP. If you create the display list using\n GX_BeginDispList()/GX_EndDispList(), this padding will be inserted automatically.\n\n \\param[in] list 32-byte aligned pointer to the display list buffer\n \\param[in] nbytes number of bytes in the display list. Use the return value of GX_EndDispList() here.\n\n \\return none"]
    pub fn GX_CallDispList(list: *mut ::libc::c_void, nbytes: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_AdjustForOverscan(GXRModeObj *rmin,GXRModeObj *rmout,u16 hor,u16 ver)\n \\brief Takes a given render mode and returns a version that is reduced in size to account for overscan.\n\n \\details The number of pixels specified by \\a hor is subtracted from each side of the screen, and the number of pixels specified\n by \\a ver is subtracted from both the top and the bottom of the screen. The active screen area is centered within what the render\n mode specified before the adjustment.\n\n \\note Due to the wide possibilities of how a render mode may be configured, this function may not work in all cases. For instance,\n if you use Y-scaling to create a size difference between the EFB and XFB, this function may not do the right thing. In such cases,\n you should configure the desired render mode manually (or else call this function and then fix up the results).\n\n \\param[in] rmin rmode that is being copied\n \\param[in] rmout rmode to hold the adjusted version. Needs to be allocated but can be uninitialized.\n \\param[in] hor pixels to trim from each side of the screen\n \\param[in] ver pixels to tim from top and bottom of the screen\n\n \\returns none"]
    pub fn GX_AdjustForOverscan(
        rmin: *mut GXRModeObj,
        rmout: *mut GXRModeObj,
        hor: u16_,
        ver: u16_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_LoadPosMtxImm(Mtx mt,u32 pnidx)\n \\brief Used to load a 3x4 modelview matrix \\a mt into matrix memory at location \\a pnidx.\n\n \\details This matrix can be used to transform positions in model space to view space, either by making the matrix the current one (see\n GX_SetCurrentMtx()), or by setting a matrix \\a pnidx for each vertex. The parameter \\a mt is a pointer to a 3x4 (row x column) matrix. The\n parameter \\a pnidx is used to refer to the matrix location (see \\ref pnmtx) in matrix memory.\n\n You can also load a normal matrix (GX_LoadNrmMtxImm() or GX_LoadNrmMtxIdx3x3()) to the same \\a pnidx. Generally, the normal matrix\n will be the inverse transpose of the position matrix. The normal matrix is used during vertex lighting. In cases where the modelview\n and inverse transpose of the modelview (excluding translation) are the same, you can load the <i>same</i> matrix for both position and normal\n transforms.\n\n \\note The matrix data is copied from DRAM through the CPU cache into the Graphics FIFO, so matrices loaded using this function are always\n coherent with the CPU cache.\n\n \\param[in] mt the matrix to load\n \\param[in] pnidx \\ref pnmtx to load into\n\n \\return none"]
    pub fn GX_LoadPosMtxImm(mt: *mut [f32_; 4usize], pnidx: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadPosMtxIdx(u16 mtxidx,u32 pnidx)\n \\brief Loads a 3x4 modelview matrix at index \\a mtxidx from the array in main memory.\n\n \\details The array is set by GX_SetArray(), and the matrix is loaded into matrix memory at index \\a pnidx (see \\ref pnmtx). This\n modelview matrix is used to transform positions in model space to view space, either by making the matrix the current one (see\n GX_SetCurrentMtx()) or by setting a matrix \\a pnidx for each vertex (see GX_SetVtxDesc()). The matrix will be loaded through the vertex cache.\n\n You can also load a normal matrix (GX_LoadNrmMtxImm() or GX_LoadNrmMtxIdx3x3()) to the same \\a pnidx. Generally, the normal matrix\n will be the inverse transpose of the position matrix. The normal matrix is used during vertex lighting. In cases where the modelview\n and inverse transpose of the modelview (excluding translation) are the same, you can load the <i>same</i> matrix for both position and normal\n transforms. Since indexed matrix loads are through the vertex cache, you will only incur the main memory bandwidth load of one matrix load.\n\n \\note The matrix is loaded directly from main memory into the matrix memory thrugh the vertex cache, so it is incoherent with the CPU's cache.\n It is the application's responsibility to flush any matrix data from the CPU cache (see DCStoreRange()) before calling this function.\n\n \\param[in] mtxidx index to the matrix array to load\n \\param[in] pnidx \\ref pnmtx to load into\n\n \\return none"]
    pub fn GX_LoadPosMtxIdx(mtxidx: u16_, pnidx: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadNrmMtxImm(Mtx mt,u32 pnidx)\n \\brief Used to load a normal transform matrix into matrix memory at location \\a pnidx from the 4x3 matrix \\a mt.\n\n \\details This matrix is used to transform normals in model space to view space, either by making it the current matrix (see GX_SetCurrentMtx()),\n or by setting a matrix pnidx for each vertex. The parameter \\a mt is a pointer to a 3x4 (row x column) matrix. The translation terms\n in the 3x4 matrix are not needed for normal rotation and are ignored during the load. The parameter \\a pnidx is used to refer to the\n matrix location (see \\ref pnmtx) in matrix memory.\n\n \\note You can also load a position matrix (GX_LoadPosMtxImm()) to the same \\a pnidx. Normally, the normal matrix will be the inverse transpose of\n the position (modelview) matrix and is used during vertex lighting. In cases where the modelview and the inverse transpose of the modelview\n matrix (excluding translation) are the same, the same matrix can be loaded for both normal and position matrices.<br><br>\n\n \\note The matrix data is copied from main memory or the CPU cache into the Graphics FIFO, so matrices loaded by this function are always coherent\n with the CPU cache.<br><br>\n\n \\note To load a normal matrix from a 3x3 matrix, use GX_LoadNrmMtxImm3x3().\n\n \\param[in] mt the matrix to load\n \\param[in] pnidx \\ref pnmtx to load into\n\n \\return none"]
    pub fn GX_LoadNrmMtxImm(mt: *mut [f32_; 4usize], pnidx: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadNrmMtxImm3x3(Mtx33 mt,u32 pnidx)\n \\brief Used to load a normal transform matrix into matrix memory at location \\a pnidx from the 3x3 matrix \\a mt.\n\n \\details This matrix is used to transform normals in model space to view space, either by making it the current matrix (see GX_SetCurrentMtx()),\n or by setting a matrix pnidx for each vertex. The parameter \\a mt is a pointer to a 3x3 (row x column) matrix. The translation terms\n in the 3x3 matrix are not needed for normal rotation and are ignored during the load. The parameter \\a pnidx is used to refer to the\n matrix location (see \\ref pnmtx) in matrix memory.\n\n \\note You can also load a position matrix (GX_LoadPosMtxImm()) to the same \\a pnidx. Normally, the normal matrix will be the inverse transpose of\n the position (modelview) matrix and is used during vertex lighting. In cases where the modelview and the inverse transpose of the modelview\n matrix (excluding translation) are the same, the same matrix can be loaded for both normal and position matrices.<br><br>\n\n \\note The matrix data is copied from main memory or the CPU cache into the Graphics FIFO, so matrices loaded by this function are always coherent\n with the CPU cache.<br><br>\n\n \\param[in] mt the matrix to load\n \\param[in] pnidx \\ref pnmtx to load into\n\n \\return none"]
    pub fn GX_LoadNrmMtxImm3x3(mt: *mut [f32_; 3usize], pnidx: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadNrmMtxIdx3x3(u16 mtxidx,u32 pnidx)\n \\brief Loads a 3x3 normal matrix into matrix memory at location \\a pnidx from a 3x3 matrix located at index \\a mtxidx\n from the array in main memory.\n\n \\details The array is set by set by GX_SetArray(), and the matrix is loaded into matrix memory at index \\a pnidx. This matrix can be used to\n transform normals in model space to view space, either by making the matrix the current one (see GX_SetCurrentMtx()), or by setting a\n matrix \\a pnidx for each vertex (see GX_SetVtxDesc()). The matrix will be loaded through the vertex cache. You can also load a position\n matrix (GX_LoadPosMtxImm() or GX_LoadPosMtxIdx()) to the same \\a pnidx.\n\n \\note You cannot use an indexed load to load a 3x3 matrix from an indexed 3x4 matrix in main memory; you must use GX_LoadNrmMtxImm() for\n this case.<br><br>\n\n \\note The matrix is loaded directly from main memory into the matrix memory through the vertex cache, therefore it is incoherent with the\n CPU's cache. It is the application's responsibility to flush any matrix data from the CPU cache (see DCStoreRange()) before calling this\n function.\n\n \\param[in] mtxidx index to the matrix array to load\n \\param[in] pnidx \\ref pnmtx to load into\n\n \\return none"]
    pub fn GX_LoadNrmMtxIdx3x3(mtxidx: u16_, pnidx: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadTexMtxImm(Mtx mt,u32 texidx,u8 type)\n \\brief Loads a texture matrix \\a mt into the matrix memory at location \\a texidx.\n\n \\details The matrix loaded can be either a 2x4 or 3x4 matrix as indicated by \\a type. You can use the loaded matrix to\n transform texture coordinates, or to generate texture coordinates from position or normal vectors. Such generated texture\n coordinates are used for projected textures, reflection mapping, etc. See GX_SetTexCoordGen() for more details.\n\n Texture matrices can be either 2x4 or 3x4. <tt>GX_MTX_2x4</tt> matrices can be used for simple translations and/or rotations of texture\n coordinates. <tt>GX_MTX_3x4</tt> matrices are used when projection is required.\n\n \\note The default matrix memory configuration allows for ten (3x4 or 2x4) texture matrices, and a 3x4 identity matrix. The <tt>GX_IDENTITY</tt>\n matrix is preloaded by GX_Init().<br><br>\n\n \\note This function allows one to load post-transform texture matrices as well. Specifying a texidx in the range of \\ref dttmtx will load a\n post-transform texture matrix instead of a regular, first-pass texture matrix. Note that post-transform matrices are always 3x4. Refer to\n GX_SetTexCoordGen2() for information about how to use post-transform texture matrices.\n\n \\param[in] mt the matrix to load\n \\param[in] texidx \\ref texmtx\n \\param[in] type \\ref mtxtype\n\n \\return none"]
    pub fn GX_LoadTexMtxImm(mt: *mut [f32_; 4usize], texidx: u32_, type_: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadTexMtxIdx(u16 mtxidx,u32 texidx,u8 type)\n \\brief Loads a texture matrix at index \\a mtxidx from the array in main memory\n\n \\details The array is set by GX_SetArray(), and the matrix is loaded into matrix memory at location \\a texid. The loaded matrix can be\n either 2x4 or 3x4 as indicated by \\a type. This matrix can be used to generate texture coordinates from positions, normals, and input\n texture coordinates (see GX_SetTexCoordGen()). The matrix is loaded through the vertex cache. The size of the matrix to load is indicated by its\n \\a type. Texture matrices can be either 2x4 or 3x4. <tt>GX_MTX_2x4</tt> matrices can be used for simple translations and/or rotations of texture\n coordinates; <tt>GX_MTX_3x4</tt> matrices are used when projection is required.\n\n \\note The matrix is loaded directly from main memory into the matrix memory through the vertex cache, so it is incoherent with the CPU's\n cache. It is the application's responsibility to flush any matrix data from the CPU cache (see DCStoreRange()) before calling this function.<br><br>\n\n \\note This function allows one to load post-transform texture matrices as well. Specifying a \\a texidx in the range of \\ref dttmtx will load a\n post-transform texture matrix instead of a regular, first-pass texture matrix. Note that post-transform matrices are always 3x4. Refer to\n GX_SetTexCoordGen2() for information about how to use post-transform texture matrices.\n\n \\param[in] mtxidx index to the matrix array to load\n \\param[in] texidx \\ref texmtx\n \\param[in] type \\ref mtxtype\n\n \\return none"]
    pub fn GX_LoadTexMtxIdx(mtxidx: u16_, texidx: u32_, type_: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetCurrentMtx(u32 mtx)\n \\brief Selects a specific matrix to use for transformations.\n\n \\details The matrix \\a mtx specified will be used to select the current modelview transform matrix and normal transform matrix,\n as long as a matrix index is not present in the vertex data (see GX_SetVtxDesc()). If the current vertex descriptor enables <tt>GX_VA_PTNMTXIDX</tt>,\n the matrix \\a mtx specified by this function will be overwritten when the vertices are drawn.\n\n \\param[in] mtx \\ref pnmtx\n\n \\return none"]
    pub fn GX_SetCurrentMtx(mtx: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevOp(u8 tevstage,u8 mode)\n \\brief Simplified function to set various TEV parameters for this \\a tevstage based on a predefined combiner \\a mode.\n\n \\details This is a convenience function designed to make initial programming of the Texture Environment unit (TEV) easier. This function calls\n GX_SetTevColorIn(), GX_SetTevColorOp(), GX_SetTevAlphaIn() and GX_SetTevAlphaOp() with predefined arguments to implement familiar texture\n combining functions.\n\n \\note To enable a consecutive set of TEV stages, you must call GX_SetNumTevStages().\n\n \\param[in] tevstage \\ref tevstage.\n \\param[in] mode \\ref tevdefmode\n\n \\return none"]
    pub fn GX_SetTevOp(tevstage: u8_, mode: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevColor(u8 tev_regid,GXColor color)\n \\brief Used to set one of the primary color registers in the TEV unit.\n\n \\details These registers are available to all TEV stages. At least one of these registers is used to pass the output of one TEV stage to\n the next in a multi-texture configuration. The application is responsible for allocating these registers so that no collisions in usage occur.\n\n \\note This function can only set unsigned 8-bit colors. To set signed, 10-bit colors use GX_SetTevColorS10().\n\n \\param[in] tev_regid \\ref tevcoloutreg.\n \\param[in] color Constant color value.\n\n \\return none"]
    pub fn GX_SetTevColor(tev_regid: u8_, color: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevColorS10(u8 tev_regid,GXColorS10 color)\n \\brief Used to set one of the constant color registers in the TEV unit.\n\n \\details These registers are available to all TEV stages. At least one of these registers is used to pass the output of one TEV stage to the\n next in a multi-texture configuration. The application is responsible for allocating these registers so that no collisions in usage occur.\n\n \\note This function enables the color components to be signed 10-bit numbers. To set 8-bit unsigned colors (the common case), use GX_SetTevColor().\n\n \\param[in] tev_regid \\ref tevcoloutreg.\n \\param[in] color Constant color value in S10 format.\n\n \\return none"]
    pub fn GX_SetTevColorS10(tev_regid: u8_, color: GXColorS10);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevColorIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d)\n \\brief Sets the color input sources for one \\a tevstage of the Texture Environment (TEV) color combiner.\n\n \\details This includes constant (register) colors and alphas, texture color/alpha, rasterized color/alpha (the result of per-vertex lighting),\n and a few useful constants.\n\n \\note The input controls are independent for each TEV stage.\n\n \\param[in] tevstage \\ref tevstage\n \\param[in] a \\ref tevcolorarg\n \\param[in] b \\ref tevcolorarg\n \\param[in] c \\ref tevcolorarg\n \\param[in] d \\ref tevcolorarg\n\n \\return none"]
    pub fn GX_SetTevColorIn(tevstage: u8_, a: u8_, b: u8_, c: u8_, d: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevAlphaIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d)\n \\brief Sets the alpha input sources for one \\a tevstage of the Texture Environment (TEV) alpha combiner.\n\n \\details There are fewer alpha inputs than color inputs, and there are no color channels available in the alpha combiner.\n\n \\note The input controls are independent for each TEV stage.\n\n \\param[in] tevstage \\ref tevstage\n \\param[in] a \\ref tevalphaarg\n \\param[in] b \\ref tevalphaarg\n \\param[in] c \\ref tevalphaarg\n \\param[in] d \\ref tevalphaarg\n\n \\return none"]
    pub fn GX_SetTevAlphaIn(tevstage: u8_, a: u8_, b: u8_, c: u8_, d: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevColorOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid)\n \\brief Sets the \\a tevop, \\a tevbias, \\a tevscale and \\a clamp-mode operation for the color combiner\n        for this \\a tevstage of the TEV unit.\n\n \\details This function also specifies the register, \\a tevregid, that will contain the result of the color combiner function. The color\n combiner function is:<br><br>\n\n\t\t  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\a tevregid = (d (\\a tevop) ((1.0 - c)*a + c*b) + \\a tevbias) * \\a tevscale;<br><br>\n\n\n The input sources a,b,c and d are set using GX_SetTevColorIn().\n\n \\param[in] tevstage \\ref tevstage.\n \\param[in] tevop \\ref tevop\n \\param[in] tevbias \\ref tevbias.\n \\param[in] tevscale \\ref tevscale.\n \\param[in] clamp Clamp results when <tt>GX_TRUE</tt>.\n \\param[in] tevregid \\ref tevcoloutreg\n\n \\return none"]
    pub fn GX_SetTevColorOp(
        tevstage: u8_,
        tevop: u8_,
        tevbias: u8_,
        tevscale: u8_,
        clamp: u8_,
        tevregid: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetTevAlphaOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid)\n \\brief Sets the \\a tevop, \\a tevbias, \\a tevscale and \\a clamp-mode operation for the alpha combiner\n        for this \\a tevstage of the TEV unit.\n\n \\details This function also specifies the register, \\a tevregid, that will contain the result of the alpha combiner function. The alpha\n combiner function is:<br><br>\n\n        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\a tevregid = (d (\\a tevop) ((1.0 - c)*a + c*b) + \\a tevbias) * \\a tevscale;<br><br>\n\n The input sources a,b,c and d are set using GX_SetTevAlphaIn().\n\n \\param[in] tevstage \\ref tevstage.\n \\param[in] tevop \\ref tevop\n \\param[in] tevbias \\ref tevbias.\n \\param[in] tevscale \\ref tevscale.\n \\param[in] clamp Clamp results when <tt>GX_TRUE</tt>.\n \\param[in] tevregid \\ref tevcoloutreg\n\n \\return none"]
    pub fn GX_SetTevAlphaOp(
        tevstage: u8_,
        tevop: u8_,
        tevbias: u8_,
        tevscale: u8_,
        clamp: u8_,
        tevregid: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetNumTexGens(u32 nr)\n \\brief Sets the number of texture coordinates that are generated and available for use in the Texture Environment TEV stages.\n\n \\details Texture coordinates are generated from input data as described by GX_SetTexCoordGen(). The generated texture coordinates are linked to\n specific textures and specific TEV stages using GX_SetTevOrder().\n\n \\note A consecutive number of texture coordinates may be generated, starting at <tt>GX_TEXCOORD0</tt>. A maximum of 8 texture coordinates may be generated.\n If \\a nr is set to 0, no texture coordinates will be generated. In this case, at least one color channel must be output (see GX_SetNumChans()).\n\n \\param[in] nr number of tex coords to generate, between 0 and 8 inclusive\n\n \\return none"]
    pub fn GX_SetNumTexGens(nr: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTexCoordGen(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc)\n \\brief Specifies how texture coordinates are generated.\n\n \\details Output texture coordinates are usually the result of some transform of an input attribute; either position, normal, or texture coordinate.\n You can also generate texture coordinates from the output color channel of the per-vertex lighting calculations. In C-language syntax the texture\n coordinate generation function would look like this:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\a texcoord = \\a tgen_typ(\\a tgen_src, \\a mtxsrc);<br><br>\n\n The current vertex descriptor as set by GX_SetVtxDesc() only describes the data input to the graphics processor. Using this function, you can create\n new output texture coordinates from the input data. The texcoord parameter is used to give the output texture coordinate a name. This texture\n coordinate can be bound to a texture using GX_SetTevOrder(). GX_SetNumTexGens() specifies a consecutive number of texture coordinates, starting at\n <tt>GX_TEXCOORD0</tt>, that are available to GX_SetTevOrder().\n\n \\ref texmtx defines a default set of texture matrix names that can be supplied as mtxsrc. The matrix names are actually row addresses (4 floats per\n row) in the matrix memory that indicate the first row of a loaded matrix. The user may define another memory map of matrix memory to suit their\n needs. Keep in mind, however, that modelview matrices (see GX_LoadPosMtxImm() and \\ref pnmtx) and texture matrices share matrix memory.\n\n \\note Input texture coordinates must always go through the texture coordinate generation hardware. GX_Init() initializes the hardware (by calling\n this function) so that all texture coordinates are transformed by the <tt>GX_IDENTITY</tt> matrix in order to appear as if input coordinates are passed\n unchanged through to the texture hardware.\n\n There are 8 output texture coordinates that can be referenced in any of the 16 TEV stages. There are a maximum of 8 input texture coordinates.\n\n \\param[in] texcoord \\ref texcoordid\n \\param[in] tgen_typ \\ref texgentyp\n \\param[in] tgen_src \\ref texgensrc\n \\param[in] mtxsrc \\ref texmtx\n\n \\return none"]
    pub fn GX_SetTexCoordGen(texcoord: u16_, tgen_typ: u32_, tgen_src: u32_, mtxsrc: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTexCoordGen2(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc,u32 normalize,u32 postmtx)\n \\brief An extension of GX_SetTexCoordGen(). It allows one to specify additional texgen options.\n\n \\details The first four arguments are identical to those for GX_SetTexCoordGen() and function in the same way. All requirements for the first\n four arguments are the same as they are for that function as well. The new options only apply for \"ordinary\" texgens, where the texgen type is\n <tt>GX_TG_MTX2x4</tt> or <tt>GX_TG_MTX3x4</tt>. They do not work for light-based texgens or emboss texgens.\n\n The \\a normalize argument allows the computed texcoord to be normalized after the multiplication by \\a mtxsrc (the first-pass transformation).\n After the optional normalization step, the texcoord is then multiplied by the 3x4 matrix \\a postmtx. This matrix is refered to as the\n post-transform matrix.\n\n The result of this step is the texture coordinate that is used to look up the texture.\n\n \\note The post-transform matrices are separate from the first pass matrices. They are stored in a separate memory area in the same format as the\n first pass matrices, except that all matrices have three rows.<br><br>\n\n \\note When a vertex contains only position and one texture coordinate and the texgen type is <tt>GX_TG_MTX2x4</tt>, there are certain limitations. In\n this special performance case, normalization is not performed (even if specified).\n\n \\param[in] texcoord \\ref texcoordid\n \\param[in] tgen_typ \\ref texgentyp\n \\param[in] tgen_src \\ref texgensrc\n \\param[in] mtxsrc \\ref texmtx\n \\param[in] normalize if <tt>GX_TRUE</tt>, normalize tex coord after first-pass transform. Only used with <tt>GX_TG_MTX*</tt>.\n \\param[in] postmtx \\ref dttmtx\n\n \\return none"]
    pub fn GX_SetTexCoordGen2(
        texcoord: u16_,
        tgen_typ: u32_,
        tgen_src: u32_,
        mtxsrc: u32_,
        normalize: u32_,
        postmtx: u32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetZTexture(u8 op,u8 fmt,u32 bias)\n \\brief Controls Z texture operations.\n\n \\details Z textures can be used to implement image-based rendering algorithms. A composite image consisting of color and depth image planes can\n be merged into the Embedded Frame Buffer (EFB).\n\n Normally, the Z for a quad (2x2) of pixels is computed as a reference Z and two slopes. Once Z texturing is enabled, the Z is computed by adding\n a Z texel to the reference Z (\\a op = <tt>GX_ZT_ADD</tt>) or by replacing the reference Z with the Z texel value (\\a op = <tt>GX_ZT_REPLACE</tt>).\n\n Z textures are always the output from the last active Texture Environment (TEV) stage (see GX_SetNumTevStages()) when enabled. When Z texturing is\n enabled, the texture color of the last TEV stage is not available, but all other color inputs and operations are available. The pixel color is\n always output from the last active TEV stage. You cannot use the TEV to operate on the Z texture, it is fed directly into the Z texture logic.\n\n Z texel formats can be unsigned 8-bit (<tt>GX_TF_Z8</tt>), 16-bit (<tt>GX_TF_Z16</tt>), or 24-bit (<tt>GX_TF_Z24X8</tt> (32-bit texture)) are used. The Graphics Processor\n converts the Z-textures to 24-bit values by placing the texel value in the least-significant bits and inserting zero's in the remaining\n most-significant bits. The 24-bit constant \\a bias is added to the Z texture. If the pixel format is GX_PF_RGB565_Z16 the 24-bit result is converted\n to the current 16-bit Z format before comparing with the EFB's Z.\n\n \\note The Z-texture calculation is done before the fog range calculation.<br><br>\n\n \\note GX_Init() disables Z texturing.\n\n \\param[in] op \\ref ztexop to perform\n \\param[in] fmt \\ref ztexfmt to use\n \\param[in] bias Bias value. Format is 24bit unsigned.\n\n \\return none"]
    pub fn GX_SetZTexture(op: u8_, fmt: u8_, bias: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetZMode(u8 enable,u8 func,u8 update_enable)\n \\brief Sets the Z-buffer compare mode.\n\n \\details The result of the Z compare is used to conditionally write color values to the Embedded Frame Buffer (EFB).\n\n When \\a enable is set to <tt>GX_DISABLE</tt>, Z buffering is disabled and the Z buffer is not updated.\n\n The \\a func parameter determines the comparison that is performed. In the comparison function, the newly rasterized Z value is on the left\n while the Z value from the Z buffer is on the right. If the result of the comparison is false, the newly rasterized pixel is discarded.\n\n The parameter \\a update_enable determines whether or not the Z buffer is updated with the new Z value after a comparison is performed. This\n parameter also affects whether the Z buffer is cleared during copy operations (see GX_CopyDisp() and GX_CopyTex()).\n\n \\param[in] enable Enables comparisons with source and destination Z values if <tt>GX_TRUE</tt>; disables compares otherwise.\n \\param[in] func \\ref compare\n \\param[in] update_enable Enables Z-buffer updates when <tt>GX_TRUE</tt>; otherwise, Z-buffer updates are disabled, but compares may still be enabled.\n\n \\return none"]
    pub fn GX_SetZMode(enable: u8_, func: u8_, update_enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetZCompLoc(u8 before_tex)\n \\brief Sets whether Z buffering happens before or after texturing.\n\n \\details Normally, Z buffering should happen before texturing, as this enables better performance by not texturing pixels that are not\n visible; however, when alpha compare is used, Z buffering must be done after texturing (see GX_SetAlphaCompare()).\n\n \\param[in] before_tex Enables Z-buffering before texturing when set to <tt>GX_TRUE</tt>; otherwise, Z-buffering takes place after texturing.\n\n \\return none"]
    pub fn GX_SetZCompLoc(before_tex: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetLineWidth(u8 width,u8 fmt)\n \\brief Sets the width of line primitives.\n\n The parameter \\a fmt is added to the texture coordinate to obtain texture coordinates at the other corners of a wide line. The \\a fmt\n values are added after the texture coordinate generation operation; see GX_SetTexCoordGen().\n\n \\param[in] width width of the line in 1/16th pixel increments; maximum width is 42.5 px\n \\param[in] fmt \\ref texoff\n\n \\return none"]
    pub fn GX_SetLineWidth(width: u8_, fmt: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetPointSize(u8 width,u8 fmt)\n \\brief Sets the size of point primitives.\n\n \\details The parameter \\a fmt is added to the texture coordinate(s), if any, to obtain texture coordinates at the other corners of a point. The\n \\a fmts are added after the texture coordinate generation operation; see GX_SetTexCoordGen().\n\n \\param[in] width width of the point in 1/16th pixel increments; maximum width is 42.5 px\n \\param[in] fmt \\ref texoff\n\n \\return none"]
    pub fn GX_SetPointSize(width: u8_, fmt: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op)\n \\brief Determines how the source image, generated by the graphics processor, is blended with the Embedded Frame Buffer (EFB).\n\n \\details When \\a type is set to <tt>GX_BM_NONE</tt>, the source data is written directly to the EFB. When \\a type is set to <tt>GX_BM_BLEND</tt>, the source color and EFB\n pixels are blended using the following equation:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>src_pix_clr</i> * \\a src_fact + <i>dst_pix_clr</i> * \\a dst_fact\n\n The <tt>GX_BL_DSTALPHA</tt> / <tt>GX_BL_INVDSTALPHA</tt> can be used only when the EFB has <tt>GX_PF_RGBA6_Z24</tt> as the pixel format (see GX_SetPixelFmt()). If the pixel\n format is <tt>GX_PF_RGBA6_Z24</tt> then the \\a src_fact and \\a dst_fact are also applied to the alpha channel. To write the alpha channel to the EFB you must\n call GX_SetAlphaUpdate().\n\n When type is set to <tt>GX_BM_LOGIC</tt>, the source and EFB pixels are blended using logical bitwise operations. When type is set to <tt>GX_BM_SUBTRACT</tt>, the destination\n pixel is computed as follows:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>dst_pix_clr</i> - <i>src_pix_clr [clamped to zero]</i>\n\n Note that \\a src_fact and \\a dst_fact are not part of this equation.\n\n \\note Color updates should be enabled by calling GX_SetColorUpdate().\n\n \\param[in] type \\ref blendmode\n \\param[in] src_fact \\ref blendfactor\n \\param[in] dst_fact \\ref blendfactor\n \\param[in] op \\ref logicop\n\n \\return none"]
    pub fn GX_SetBlendMode(type_: u8_, src_fact: u8_, dst_fact: u8_, op: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetCullMode(u8 mode)\n \\brief Enables or disables culling of geometry based on its orientation to the viewer.\n\n \\details Primitives in which the vertex order is clockwise to the viewer are considered front-facing.\n\n \\note GX_Init() sets this to <tt>GX_CULL_BACK</tt>.\n\n \\param[in] mode \\ref cullmode\n\n \\return none"]
    pub fn GX_SetCullMode(mode: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetCoPlanar(u8 enable)\n \\brief Enables or disables coplanar triangle processing.\n\n \\details While coplanar mode is enabled, all subsequent triangles (called decal triangles) will have the same Z coefficients as the reference\n plane. Coplanar mode should be enabled immediately after a reference triangle is drawn.\n\n \\note The reference triangle can be culled using <tt>GX_SetCullMode(GX_CULL_ALL)</tt> to create an invisible reference plane; however, the reference\n triangle must not be completely out of view, i.e. trivially rejected by clipping.<br><br>\n\n \\note GX_Init() disables coplanar mode.\n\n \\param[in] enable when <tt>GX_ENABLE</tt>, coplanar mode is enabled; <tt>GX_DISABLE</tt> disables this mode\n\n \\return none"]
    pub fn GX_SetCoPlanar(enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_EnableTexOffsets(u8 coord,u8 line_enable,u8 point_enable)\n \\brief Enables a special texture offset feature for points and lines.\n\n \\details When a point's size is defined using GX_SetPointSize() or a line's width is described using GX_SetLineWidth(), you can also specify a second\n parameter. The parameter \\a fmt is added to the texture coordinate(s), if any, to obtain texture coordinates at the other corners of a\n point or line. The \\a fmts are added after the texture coordinate generation operation; see GX_SetTexCoordGen(). This function enables this\n operation for a particular texture coordinate. Offset operations for points and lines are enabled separately. If the enables are false, the same\n texture coordinate is used for every vertex of the line or point.\n\n \\param[in] coord \\ref texcoordid\n \\param[in] line_enable enable or disable tex offset calculation for lines\n \\param[in] point_enable enable or disable tex offset calculation for points\n\n \\return none"]
    pub fn GX_EnableTexOffsets(coord: u8_, line_enable: u8_, point_enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetClipMode(u8 mode)\n \\brief Enables or disables clipping of geometry.\n\n \\details This may help performance issues that occur when objects are far-clipped; however, any near-clipped objects will be rendered incorrectly.\n\n \\note GX_Init() sets this to <tt>GX_CLIP_ENABLE</tt>.\n\n \\param[in] mode \\ref clipmode\n\n \\return none"]
    pub fn GX_SetClipMode(mode: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetScissor(u32 xOrigin,u32 yOrigin,u32 wd,u32 ht)\n \\brief Sets the scissor rectangle.\n\n \\details The scissor rectangle specifies an area of the screen outside of which all primitives are culled. This function sets the scissor rectangle in\n screen coordinates. The screen origin (\\a xOrigin=0, \\a yOrigin=0) is at the top left corner of the display.\n\n The values may be within the range of 0 - 2047 inclusive. Using values that extend beyond the EFB size is allowable since the scissor box may be\n repositioned within the EFB using GX_SetScissorBoxOffset().\n\n \\note By default, the scissor rectangle is set to match the viewport rectangle. GX_Init() initializes the scissor rectangle to match the viewport\n given the current render mode.\n\n \\param[in] xOrigin left-most coord in screen coordinates\n \\param[in] yOrigin top-most coord in screen coordinates\n \\param[in] wd width of the scissorbox in screen coordinates\n \\param[in] ht height of the scissorbox in screen coordinates\n\n \\return none"]
    pub fn GX_SetScissor(xOrigin: u32_, yOrigin: u32_, wd: u32_, ht: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetScissorBoxOffset(s32 xoffset,s32 yoffset)\n \\brief Repositions the scissorbox rectangle within the Embedded Frame Buffer (EFB) memory space.\n\n \\details The offsets are subtracted from the screen coordinates to determine the actual EFB coordinates where the pixels are stored. Thus with\n positive offsets, the scissor box may be shifted left and/or up; and with negative offsets, the scissor box may be shifted right and/or down.\n\n The intended use for this command is to make it easy to do two-pass antialiased rendering. To draw the top half of the screen, the scissor box is set to\n the top and the offset set to zero. To draw the bottom half, the scissor box is set to the bottom, and the offset is set to shift the scissor box back up\n to the top.\n\n Another use for the offset is to displace how an image is rendered with respect to the dither matrix. Since the dither matrix is 4x4, a \\a yoffset of -2\n shifts the image down by 2 lines with respect to the matrix. This can be useful for field-rendering mode.\n\n \\note Achieving an offset of an odd number of lines is possible, but more difficult than just changing the scissor box: one must render and copy 2\n additional lines, then skip one by adjusting the argument of VIDEO_SetNextFrameBuffer().<br><br>\n\n \\note GX_Init() initializes the scissor box offset to zero. Since the GP works on 2x2 regions of pixels, only even offsets are allowed.\n\n \\param[in] xoffset number of pixels to shift the scissorbox left, between -342 - 382 inclusive; must be even\n \\param[in] yoffset number of pixels to shift the scissorbox up, between -342 - 494 inclusive; must be even\n\n \\return none"]
    pub fn GX_SetScissorBoxOffset(xoffset: s32, yoffset: s32);
}
extern "C" {
    #[doc = " \\fn void GX_SetNumChans(u8 num)\n \\brief Sets the number of color channels that are output to the TEV stages.\n\n \\details Color channels are the mechanism used to compute per-vertex lighting effects. Color channels are controlled using GX_SetChanCtrl().\n Color channels are linked to specific TEV stages using GX_SetTevOrder().\n\n This function basically defines the number of per-vertex colors that get rasterized. If \\a num is set to 0, then at least one texture coordinate\n must be generated (see GX_SetNumTexGens()). If \\a num is set to 1, then channel <tt>GX_COLOR0A0</tt> will be rasterized. If \\a num is set to 2 (the maximum\n value), then <tt>GX_COLOR0A0</tt> and <tt>GX_COLOR1A1</tt> will be rasterized.\n\n \\param[in] num number of color channels to rasterize; number must be 0, 1 or 2\n\n \\return none"]
    pub fn GX_SetNumChans(num: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevOrder(u8 tevstage,u8 texcoord,u32 texmap,u8 color)\n \\brief Specifies the texture and rasterized color that will be available as inputs to this TEV \\a tevstage.\n\n The texture coordinate \\a texcoord is generated from input attributes using the GX_SetTexCoordGen() function and is used to look up the\n texture map, previously loaded by GX_LoadTexObj(). The \\a color to rasterize for this \\a tevstage is also specified. The color\n is the result of per-vertex lighting which is controlled by GX_SetChanCtrl().\n\n This function will scale the normalized texture coordinates produced by GX_SetTexCoordGen() according to the size of the texture map in the\n function call. For this reason, texture coordinates can only be broadcast to multiple texture maps if and only if the maps are the same size. In\n some cases, you may want to generate a texture coordinate having a certain scale, but disable the texture lookup (this comes up when generating\n texture coordinates for indirect bump mapping). To accomplish this, use the <tt>GX_TEXMAP_DISABLE</tt> flag:\n\n \\code GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP3 | GX_TEXMAP_DISABLE, GX_COLORNULL); \\endcode\n\n \\details This will scale <tt>GX_TEXCOORD0</tt> using <tt>GX_TEXMAP3</tt> but disable the lookup of <tt>GX_TEXMAP3</tt>.\n\n \\note This function does not enable the TEV stage. To enable a consecutive number of TEV stages, starting at stage <tt>GX_TEVSTAGE0</tt>, use GX_SetNumTevStages().<br><br>\n\n \\note The operation of each TEV stage is independent. The color operations are controlled by GX_SetTevColorIn() and GX_SetTevColorOp(). The alpha\n operations are controlled by GX_SetTevAlphaIn() and GX_SetTevAlphaOp().<br><br>\n\n \\note The number of texture coordinates available for all the active TEV stages is set using GX_SetNumTexGens(). The number of color channels\n available for all the active TEV stages is set using GX_SetNumChans(). Active TEV stages should not reference more texture coordinates or colors\n than are being generated.<br><br>\n\n \\note There are some special settings for the \\a color argument. If you specify <tt>GX_COLOR_ZERO</tt>, you always get zero as rasterized color. If you specify\n <tt>GX_ALPHA_BUMP</tt> or <tt>GX_ALPHA_BUMPN</tt>, you can use \"Bump alpha\" component from indirect texture unit as rasterized color input (see GX_SetTevIndirect()\n for details about how to configure bump alpha). Since bump alpha contains only 5-bit data, <tt>GX_ALPHA_BUMP</tt> shifts them to higher bits, which makes the\n value range 0-248. Meanwhile <tt>GX_ALPHA_BUMPN</tt> performs normalization and you can get the value range 0-255.\n\n \\param[in] tevstage \\ref tevstage\n \\param[in] texcoord \\ref texcoordid\n \\param[in] texmap \\ref texmapid\n \\param[in] color \\ref channelid\n\n \\return none"]
    pub fn GX_SetTevOrder(tevstage: u8_, texcoord: u8_, texmap: u32_, color: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetNumTevStages(u8 num)\n \\brief Enables a <i>consecutive</i> number of TEV stages.\n\n \\details The output pixel color (before fogging and blending) is the result from the last stage. The last TEV stage must write to register <tt>GX_TEVPREV</tt>;\n see GX_SetTevColorOp() and GX_SetTevAlphaOp(). At least one TEV stage must be enabled. If a Z-texture is enabled, the Z texture must be looked up on\n the last stage; see GX_SetZTexture().\n\n \\note The association of lighting colors, texture coordinates, and texture maps with a TEV stage is set using GX)SetTevOrder(). The number of texture\n coordinates available is set using GX_SetNumTexGens(). The number of color channels available is set using GX_SetNumChans().<br><br>\n\n \\note GX_Init() will set \\a num to 1.\n\n \\param[in] num number of active TEV stages, between 1 and 16 inclusive\n\n \\return none"]
    pub fn GX_SetNumTevStages(num: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetAlphaCompare(u8 comp0,u8 ref0,u8 aop,u8 comp1,u8 ref1)\n \\brief Sets the parameters for the alpha compare function which uses the alpha output from the last active TEV stage.\n\n \\details The alpha compare operation is:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>alpha_pass</i> = (<i>alpha_src</i> (\\a comp0) \\a ref0) (\\a op) (<i>alpha_src</i> (\\a comp1) \\a ref1)<br><br>\n\n where <i>alpha_src</i> is the alpha from the last active TEV stage. As an example, you can implement these equations:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>alpha_pass</i> = (<i>alpha_src</i> \\> \\a ref0) <b>AND</b> (<i>alpha_src</i> \\< \\a ref1)\n\n or\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>alpha_pass</i> = (<i>alpha_src</i> \\> \\a ref0) <b>OR</b> (<i>alpha_src</i> \\< \\a ref1)\n\n \\note The output alpha can be used in the blending equation (see GX_SetBlendMode()) to control how source and destination (frame buffer)\n pixels are combined.<br><br>\n\n \\note The Z compare can occur either before or after texturing (see GX_SetZCompLoc()). In the case where Z compare occurs before texturing, the Z is\n written based only on the Z test. The color is written if both the Z test and alpha test pass. When Z compare occurs <i>after</i> texturing, the color\n and Z are written if both the Z test and alpha test pass. When using texture to make cutout shapes (like billboard trees) that need to be correctly Z\n buffered, you should configure the pipeline to Z buffer after texturing.<br><br>\n\n \\note The number of active TEV stages is specified using GX_SetNumTevStages().\n\n \\param[in] comp0 \\ref compare subfunction 0\n \\param[in] ref0 reference val for subfunction 0\n \\param[in] aop \\ref alphaop for combining subfunctions 0 and 1; must not be <tt>GX_MAX_ALPHAOP</tt>\n \\param[in] comp1 \\ref compare subfunction 1\n \\param[in] ref1 reference val for subfunction 1\n\n \\return none"]
    pub fn GX_SetAlphaCompare(comp0: u8_, ref0: u8_, aop: u8_, comp1: u8_, ref1: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevKColor(u8 sel, GXColor col)\n \\brief Sets one of the \"konstant\" color registers in the TEV unit.\n\n \\details These registers are available to all TEV stages. They are constant in the sense that they cannot be written to be the TEV itself.\n\n \\param[in] sel \\ref tevkcolorid\n \\param[in] col constant color value\n\n \\return none"]
    pub fn GX_SetTevKColor(sel: u8_, col: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevKColorSel(u8 tevstage,u8 sel)\n \\brief Selects a \"konstant\" color input to be used in a given TEV stage.\n\n The constant color input is used only if <tt>GX_CC_KONST</tt> is selected for an input for that TEV stage. Only one constant color selection is\n available for a given TEV stage, though it may be used for more than one input.\n\n \\param[in] tevstage \\ref tevstage\n \\param[in] sel \\ref tevkcolorsel\n\n \\return none"]
    pub fn GX_SetTevKColorSel(tevstage: u8_, sel: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevKAlphaSel(u8 tevstage,u8 sel)\n \\brief Selects a \"konstant\" alpha input to be used in a given TEV stage.\n\n \\details The constant alpha input is used only if <tt>GX_CA_KONST</tt> is selected for an input for that TEV stage. Only one constant alpha selection is\n available for a given TEV stage, though it may be used for more than one input.\n\n \\param[in] tevstage \\ref tevstage\n \\param[in] sel \\ref tevkalphasel\n\n \\return none"]
    pub fn GX_SetTevKAlphaSel(tevstage: u8_, sel: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevKColorS10(u8 sel, GXColorS10 col)\n \\brief Used to set one of the constant color registers in the Texture Environment (TEV) unit.\n\n \\details These registers are available to all TEV stages. At least one of these registers is used to pass the output of one TEV stage to the next\n in a multi-texture configuration.\n\n \\note The application is responsible for allocating these registers so that no collisions in usage occur.<br><br>\n\n \\note This function takes 10-bit signed values as color values; use GX_SetTevColor() to give 8-bit values.\n\n \\param[in] sel \\ref tevcoloutreg\n \\param[in] col constant color value\n\n \\return none"]
    pub fn GX_SetTevKColorS10(sel: u8_, col: GXColorS10);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevSwapMode(u8 tevstage,u8 ras_sel,u8 tex_sel)\n \\brief Selects a set of swap modes for the rasterized color and texture color for a given TEV stage.\n\n \\details This allows the color components of these inputs to be rearranged or duplicated.\n\n \\note There are four different swap mode table entries, and each entry in the table specifies how the RGBA inputs map to the RGBA outputs.\n\n \\param[in] tevstage \\ref tevstage\n \\param[in] ras_sel selects a swap mode for the rasterized color input.\n \\param[in] tex_sel selects a swap mode for the texture color input.\n\n \\return none"]
    pub fn GX_SetTevSwapMode(tevstage: u8_, ras_sel: u8_, tex_sel: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevSwapModeTable(u8 swapid,u8 r,u8 g,u8 b,u8 a)\n \\brief Sets up the TEV color swap table.\n\n \\details The swap table allows the rasterized color and texture color to be swapped component-wise. An entry in the table specifies how the\n input color components map to the output color components.\n\n \\param[in] swapid \\ref tevswapsel\n \\param[in] r input color component that should be mapped to the red output component.\n \\param[in] g input color component that should be mapped to the green output component.\n \\param[in] b input color component that should be mapped to the blue output component.\n \\param[in] a input color component that should be mapped to the alpha output component.\n\n \\return none"]
    pub fn GX_SetTevSwapModeTable(swapid: u8_, r: u8_, g: u8_, b: u8_, a: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevIndirect(u8 tevstage,u8 indtexid,u8 format,u8 bias,u8 mtxid,u8 wrap_s,u8 wrap_t,u8 addprev,u8 utclod,u8 a)\n \\brief Controls how the results from an indirect lookup will be used to modify a given regular TEV stage lookup.\n\n \\param[in] tevstage \\ref tevstage being affected\n \\param[in] indtexid \\ref indtexstage results to use with this TEV stage\n \\param[in] format \\ref indtexformat, i.e. how many bits to extract from the indirect result color to use in indirect offsets and the indirect \"bump\" alpha\n \\param[in] bias \\ref indtexbias to be applied to each component of the indirect offset\n \\param[in] mtxid which \\ref indtexmtx and scale value to multiply the offsets with\n \\param[in] wrap_s \\ref indtexwrap to use with the S component of the regular texture coordinate\n \\param[in] wrap_t \\ref indtexwrap to use with the T component of the regular texture coordinate\n \\param[in] addprev whether the tex coords results from the previous TEV stage should be added in\n \\param[in] utclod whether to the unmodified (<tt>GX_TRUE</tt>) or modified (<tt>GX_FALSE</tt>) tex coords for mipmap LOD computation\n \\param[in] a which offset component will supply the \\ref indtexalphasel, if any\n\n \\return none"]
    pub fn GX_SetTevIndirect(
        tevstage: u8_,
        indtexid: u8_,
        format: u8_,
        bias: u8_,
        mtxid: u8_,
        wrap_s: u8_,
        wrap_t: u8_,
        addprev: u8_,
        utclod: u8_,
        a: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetTevDirect(u8 tevstage)\n \\brief Used to turn off all indirect texture processing for the specified regular TEV stage.\n\n \\param[in] tevstage the \\ref tevstage to change\n\n \\return none"]
    pub fn GX_SetTevDirect(tevstage: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetNumIndStages(u8 nstages)\n \\brief Used to set how many indirect lookups will take place.\n\n \\details The results from these indirect lookups may then be used to alter the lookups for any number of regular TEV stages.\n\n \\param[in] nstages number of indirect lookup stages\n\n \\return none"]
    pub fn GX_SetNumIndStages(nstages: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetIndTexOrder(u8 indtexstage,u8 texcoord,u8 texmap)\n \\brief Used to specify the \\a texcoord and \\a texmap to used with a given indirect lookup.\n\n \\param[in] indtexstage \\ref indtexstage being affected\n \\param[in] texcoord \\ref texcoordid to be used for this stage\n \\param[in] texmap \\ref texmapid to be used for this stage\n\n \\return none"]
    pub fn GX_SetIndTexOrder(indtexstage: u8_, texcoord: u8_, texmap: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetIndTexCoordScale(u8 indtexid,u8 scale_s,u8 scale_t)\n \\brief Allows the sharing of a texcoord between an indirect stage and a regular TEV stage.\n\n It allows the texture coordinates to be scaled down for use with an indirect map that is smaller than the corresponding regular map.\n\n \\param[in] indtexid \\ref indtexstage being affected\n \\param[in] scale_s \\ref indtexscale factor for the S coord\n \\param[in] scale_t \\ref indtexscale factor for the T coord\n\n \\return none"]
    pub fn GX_SetIndTexCoordScale(indtexid: u8_, scale_s: u8_, scale_t: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetFog(u8 type,f32 startz,f32 endz,f32 nearz,f32 farz,GXColor col)\n \\brief Enables fog.\n\n \\details Using \\a type, the programmer may select one of several functions to control the fog density as a function of range to a quad (2x2 pixels).\n Range is cosine corrected Z in the x-z plane (eye coordinates), but is not corrected in the y direction (see GX_SetFogRangeAdj()). The parameters \\a startz and\n \\a endz allow further control over the fog behavior. The parameters \\a nearz and \\a farz should be set consistent with the projection matrix parameters. Note that these\n parameters are defined in eye-space. The fog color, in RGBX format (i.e. the alpha component is ignored), is set using the \\a col parameter. This will be the\n color of the pixel when fully fogged.\n\n \\note GX_Init() turns fog off by default.\n\n \\param[in] type \\ref fogtype to use\n \\param[in] startz minimum Z value at which the fog function is active\n \\param[in] endz maximum Z value at which the fog function is active\n \\param[in] nearz near plane (which should match the projection matrix parameters)\n \\param[in] farz far plane (which should match the projection matrix parameters)\n \\param[in] col fog color; alpha component is ignored\n\n \\return none"]
    pub fn GX_SetFog(type_: u8_, startz: f32_, endz: f32_, nearz: f32_, farz: f32_, col: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_SetFogRangeAdj(u8 enable,u16 center,GXFogAdjTbl *table)\n \\brief Enables or disables horizontal fog-range adjustment.\n\n \\details This adjustment is a factor that is multiplied by the eye-space Z used for fog computation; it is based upon the X position of the pixels being\n rendered. The Y direction is not compensated. This effectively increases the fog density at the edges of the screen, making for a more realistic fog\n effect. The adjustment is computed per quad (2x2 pixels), not per-pixel. The center of the viewport is specified using \\a center. The range adjustment\n table is specified using \\a table. The range adjust function is mirrored horizontally about the \\a center.\n\n \\note GX_Init() disables range adjustment.\n\n \\sa GX_InitFogAdjTable()\n\n \\param[in] enable enables adjustment when <tt>GX_ENABLE</tt> is passed; disabled with <tt>GX_DISABLE</tt>\n \\param[in] center centers the range adjust function; normally corresponds with the center of the viewport\n \\param[in] table range adjustment parameter table\n\n \\return none"]
    pub fn GX_SetFogRangeAdj(enable: u8_, center: u16_, table: *mut GXFogAdjTbl);
}
extern "C" {
    #[doc = " \\fn GX_SetFogColor(GXColor color)\n \\brief Sets the fog color.\n\n \\details \\a color is the color that a pixel will be if fully fogged. Alpha channel is ignored.\n\n \\param[in] color color to set fog to"]
    pub fn GX_SetFogColor(color: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_InitFogAdjTable(GXFogAdjTbl *table,u16 width,f32 projmtx[4][4])\n \\brief Generates the standard range adjustment table and puts the results into \\a table.\n\n \\details This table can be used by GX_SetFogRangeAdj() to adjust the eye-space Z used for fog based upon the X position of the pixels being rendered.\n The Y direction is not compensated. This effectively increases the fog density at the edges of the screen, making for a more realistic fog effect. The\n width of the viewport is specified using \\a width. The \\a projmtx parameter is the projection matrix that is used to render into the viewport. It must\n be specified so that the function can compute the X extent of the viewing frustum in eye space.\n\n \\note You must allocate \\a table yourself.\n\n \\param[in] table range adjustment parameter table\n \\param[in] width width of the viewport\n \\param[in] projmtx projection matrix used to render into the viewport"]
    pub fn GX_InitFogAdjTable(table: *mut GXFogAdjTbl, width: u16_, projmtx: *mut [f32_; 4usize]);
}
extern "C" {
    #[doc = " \\fn void GX_SetIndTexMatrix(u8 indtexmtx,f32 offset_mtx[2][3],s8 scale_exp)\n \\brief Sets one of the three static indirect matrices and the associated scale factor.\n\n \\details The indirect matrix and scale is used to process the results of an indirect lookup in order to produce offsets to use during a regular lookup.\n The matrix is multiplied by the [S T U] offsets that have been extracted (and optionally biased) from the indirect lookup color. In this matrix-vector\n multiply, the matrix is on the left and the [S T U] column vector is on the right.\n\n \\note The matrix values are stored in the hardware as a sign and 10 fractional bits (two's complement); thus the smallest number that can be stored is\n -1 and the largest is (1 - 1/1024) or approximately 0.999. Since +1 cannot be stored, you may consider dividing all the matrix values by 2 (thus +1\n becomes +0.5) and adding one to the scale value in order to compensate.\n\n \\param[in] indtexmtx \\ref indtexmtx that is being affected\n \\param[in] offset_mtx values to assign to the indirect matrix\n \\param[in] scale_exp exponent to use for the associated scale factor\n\n \\return none"]
    pub fn GX_SetIndTexMatrix(indtexmtx: u8_, offset_mtx: *mut [f32_; 3usize], scale_exp: s8);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevIndBumpST(u8 tevstage,u8 indstage,u8 mtx_sel)\n \\brief Sets up an environment-mapped bump-mapped indirect lookup.\n\n \\details The indirect map specifies offsets in (S,T) space. This kind of lookup requires 3 TEV stages to compute. As a result of all this work, a simple\n 2D bump map is properly oriented to the surface to which it is applied. It is used to alter a normal-based texgen which then looks up an environment map.\n The environment map may be a simple light map, or else it may be a reflection map of the surrounding scenery.\n\n \\note When using this function, texture lookup should be disabled for the first two TEV stages. The third stage is where the texture lookup is actually performed.\n The associated geometry must supply normal/binormal/tangent coordinates at each vertex. Appropriate texgens must supply each of these to the proper stages\n (binormal to the first, tangent to the second, and normal to the third). Although a static indirect matrix is not used, one must choose a matrix slot and set up\n the associated scale value to be used with this lookup.\n\n \\param[in] tevstage \\ref tevstage that is being affected\n \\param[in] indstage \\ref indtexstage results to use with this TEV stage\n \\param[in] mtx_sel which \\ref indtexmtx to multiply the offsets with\n\n \\return none"]
    pub fn GX_SetTevIndBumpST(tevstage: u8_, indstage: u8_, mtx_sel: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevIndBumpXYZ(u8 tevstage,u8 indstage,u8 mtx_sel)\n \\brief Sets up an environment-mapped bump-mapped indirect lookup.\n\n \\details The indirect map specifies offsets in object (X, Y, Z) space. This kind of lookup requires only one TEV stage to compute; however, the bump map (indirect\n map) used is geometry-specific. Thus there is a space/computation tradeoff between using this function and using GX_SetTevIndBumpST().\n\n \\note The indirect matrix must be loaded with a transformation for normals from object space to texture space (similar to eye space, but possibly with an inverted\n Y axis). The surface geometry need only provide regular normals at each vertex. A normal-based texgen must be set up for the regular texture coordinate.\n\n \\param[in] tevstage \\ref tevstage that is being affected\n \\param[in] indstage \\ref indtexstage results to use with this TEV stage\n \\param[in] mtx_sel which \\ref indtexmtx to multiply the offsets with\n\n \\return none"]
    pub fn GX_SetTevIndBumpXYZ(tevstage: u8_, indstage: u8_, mtx_sel: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTevIndTile(u8 tevstage,u8 indtexid,u16 tilesize_x,u16 tilesize_y,u16 tilespacing_x,u16 tilespacing_y,u8 indtexfmt,u8 indtexmtx,u8 bias_sel,u8 alpha_sel)\n \\brief Used to implement tiled texturing using indirect textures.\n\n \\details It will set up the correct values in the given indirect matrix; you only need to specify which matrix slot to use.\n\n \\note The regular texture map contains only the tile definitions. The actual texture size to be applied to the polygon being drawn is the product of the base tile\n size and the size of the indirect map. In order to set the proper texture coordinate scale, one must call GX_SetTexCoordScaleManually(). One can also use\n GX_SetIndTexCoordScale() in order to use the same texcoord for the indirect stage as the regular TEV stage.\n\n \\param[in] tevstage \\ref tevstage that is being affected\n \\param[in] indtexid \\ref indtexstage results to use with this TEV stage\n \\param[in] tilesize_x size of the tile in the X dimension\n \\param[in] tilesize_y size of the tile in the Y dimension\n \\param[in] tilespacing_x spacing of the tiles (in the tile-definition map) in the X dimension\n \\param[in] tilespacing_y spacing of the tiles (in the tile-definition map) in the Y dimension\n \\param[in] indtexfmt \\ref indtexformat to use\n \\param[in] indtexmtx \\ref indtexmtx to multiply the offsets with\n \\param[in] bias_sel \\ref indtexbias to indicate tile stacking direction for pseudo-3D textures\n \\param[in] alpha_sel which \\ref indtexalphasel will supply the indirect \"bump\" alpha, if any (for pseudo-3D textures).\n\n \\return none"]
    pub fn GX_SetTevIndTile(
        tevstage: u8_,
        indtexid: u8_,
        tilesize_x: u16_,
        tilesize_y: u16_,
        tilespacing_x: u16_,
        tilespacing_y: u16_,
        indtexfmt: u8_,
        indtexmtx: u8_,
        bias_sel: u8_,
        alpha_sel: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetTevIndWarp(u8 tevstage, u8 indtexid, u8 bias_flag, u8 replace_tex, u8 mtxid)\n \\brief Used to warp a normal texture lookup using an indirect texture map with 8-bit offsets.\n\n \\param[in] tevstage \\ref tevstage that is being affected\n \\param[in] indtexid \\ref indtexstage results to use with this TEV stage\n \\param[in] bias_flag biases the indirect texture map offsets by -128 if the value is GX_TRUE\n \\param[in] replace_tex GX_TRUE makes the indirect texture map offsets replace the input texture coordinates rather than offset them as with GX_FALSE\n \\param[in] mtxid which \\ref indtexmtx to use for warping the texture\n \\return none"]
    pub fn GX_SetTevIndWarp(
        tevstage: u8_,
        indtexid: u8_,
        bias_flag: u8_,
        replace_tex: u8_,
        mtxid: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetTevIndRepeat(u8 tevstage)\n \\brief Set a given TEV stage to use the same texture coordinates as were computed in the previous stage.\n\n \\note This is only useful when the previous stage texture coordinates took more than one stage to compute, as is the case for GX_SetTevIndBumpST().\n\n \\param[in] tevstage \\ref tevstage to modify\n\n \\return none"]
    pub fn GX_SetTevIndRepeat(tevstage: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetColorUpdate(u8 enable)\n \\brief Enables or disables color-buffer updates when rendering into the Embedded Frame Buffer (EFB).\n\n \\note This function also affects whether the color buffer is cleared during copies; see GX_CopyDisp() and GX_CopyTex().\n\n \\param[in] enable enables color-buffer updates with <tt>GX_TRUE</tt>\n\n \\return none"]
    pub fn GX_SetColorUpdate(enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetAlphaUpdate(u8 enable)\n \\brief Enables or disables alpha-buffer updates of the Embedded Frame Buffer (EFB).\n\n \\note This function also affects whether the alpha buffer is cleared during copy operations; see GX_CopyDisp() and GX_CopyTex().<br><br>\n\n \\note The only EFB pixel format supporting an alpha buffer is <tt>GX_PF_RGBA6_Z24</tt>; see GX_SetPixelFmt(). The alpha \\a enable is ignored for non-alpha\n pixel formats.\n\n \\param[in] enable enables alpha-buffer updates with <tt>GX_TRUE</tt>\n\n \\return none"]
    pub fn GX_SetAlphaUpdate(enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetPixelFmt(u8 pix_fmt,u8 z_fmt)\n \\brief Sets the format of pixels in the Embedded Frame Buffer (EFB).\n\n \\details There are two non-antialiased \\a pix_fmts: <tt>GX_PF_RGB8_Z24</tt> and <tt>GX_PF_RGBA6_Z24</tt>. The stride of the EFB is fixed at 640 pixels. The\n non-antialiased EFB has 528 lines available.\n\n When \\a pix_fmt is set to <tt>GX_PF_RGB565_Z16</tt>, multi-sample antialiasing is enabled. In order to get proper results, one must also call GX_SetCopyFilter().\n The position of the subsamples and the antialiasing filter coefficients are set using GX_SetCopyFilter(). When antialiasing, three 16b color/Z\n samples are computed for each pixel, and the total available number of pixels in the EFB is reduced by half (640 pixels x 264 lines). This function also sets the\n compression type for 16-bit Z formats, which allows trading off Z precision for range. The following guidelines apply:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a) far/near ratio <= 2^16, use <tt>GX_ZC_LINEAR</tt><br>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b) far/near ratio <= 2^18, use <tt>GX_ZC_NEAR</tt><br>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c) far/near ratio <= 2^20, use <tt>GX_ZC_MID</tt><br>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d) far/near ratio <= 2^24, use <tt>GX_ZC_FAR</tt><br><br>\n\n It is always best to use as little compression as possible (choice \"a\" is least compressed, choice \"d\" is most compressed). You get less precision with higher compression.\n The \"far\" in the above list does not necessarily refer to the far clipping plane. You should think of it as the farthest object you want correct occlusion for.\n\n \\note This function also controls antialiasing (AA) mode.<br><br>\n\n \\note Since changing pixel format requires the pixel pipeline to be synchronized, the use of this function causes stall of the graphics processor as a result. Therefore,\n you should avoid redundant calls of this function.\n\n \\param[in] pix_fmt <tt>GX_PF_RGB8_Z24</tt> or <tt>GX_PF_RGBA6_Z24</tt> for non-AA, <tt>GX_PF_RGB565_Z16</tt> for AA\n \\param[in] z_fmt \\ref zfmt to use\n\n \\return none"]
    pub fn GX_SetPixelFmt(pix_fmt: u8_, z_fmt: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetDither(u8 dither)\n \\brief Enables or disables dithering.\n\n \\details A 4x4 Bayer matrix is used for dithering.\n\n \\note Only valid when the pixel format (see GX_SetPixelFmt()) is either <tt>GX_PF_RGBA6_Z24</tt> or <tt>GX_PF_RGB565_Z16</tt>.<br><br>\n\n \\note Dithering should probably be turned off if you are planning on using the result of rendering for comparisons (e.g. outline rendering\n algorithm that writes IDs to the alpha channel, copies the alpha channel to a texture, and later compares the texture in the TEV).\n\n \\param[in] dither enables dithering if <tt>GX_TRUE</tt> is given and pixel format is one of the two above, otherwise disabled\n\n \\return none"]
    pub fn GX_SetDither(dither: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetDstAlpha(u8 enable,u8 a)\n \\brief Sets a constant alpha value for writing to the Embedded Frame Buffer (EFB).\n\n \\note To be effective, the EFB pixel type must have an alpha channel (see GX_SetPixelFmt()). The alpha compare operation (see\n GX_SetAlphaCompare()) and blending operations (see GX_SetBlendMode()) still use source alpha (output from the last TEV stage) but when\n writing the pixel color, the constant alpha will replace the pixel alpha in the EFB.\n\n \\param[in] enable \\a a will be written to the framebuffer if <tt>GX_ENABLE</tt> is here and frame buffer pixel format supports destination alpha\n \\param[in] a constant alpha value\n\n \\return none"]
    pub fn GX_SetDstAlpha(enable: u8_, a: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetFieldMask(u8 even_mask,u8 odd_mask)\n \\brief selectively enables and disables interlacing of the frame buffer image.\n\n \\details This function is used when rendering fields to an interlaced Embedded Frame Buffer (EFB).\n\n \\note When the mask is <tt>GX_FALSE</tt>, that field will not be written to the EFB, but the other field will be computed. In other words, you pay the\n fill rate price of a frame to produce a field.\n\n \\param[in] even_mask whether to write pixels with even Y coordinate\n \\param[in] odd_mask whether to write pixels with odd Y coordinate\n\n \\return none"]
    pub fn GX_SetFieldMask(even_mask: u8_, odd_mask: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetFieldMode(u8 field_mode,u8 half_aspect_ratio)\n \\brief Controls various rasterization and texturing parameters that relate to field-mode and double-strike rendering.\n\n \\details In field-mode rendering, one must adjust the vertical part of the texture LOD computation to account for the fact that pixels cover only half of\n the space from one rendered scan line to the next (with the other half of the space filled by a pixel from the other field).  In both field-mode and\n double-strike rendering, one must adjust the aspect ratio for points and lines to account for the fact that pixels will be double-height when displayed\n (the pixel aspect ratio is 1/2).\n\n \\note The values set here usually come directly from the render mode. The \\a field_rendering flags goes straight into \\a field_mode. The \\a half_aspect_ratio\n parameter is true if the \\a xfbHeight is half of the \\a viHeight, false otherwise.<br><br>\n\n \\note GX_Init() sets both fields according to the default render mode.<br><br>\n\n \\note On production hardware (i.e. a retail GameCube), only line aspect-ratio adjustment is implemented. Points are not adjusted.\n\n \\param[in] field_mode adjusts texture LOD computation as described above if true, otherwise does not\n \\param[in] half_aspect_ratio adjusts line aspect ratio accordingly, otherwise does not\n\n \\return none"]
    pub fn GX_SetFieldMode(field_mode: u8_, half_aspect_ratio: u8_);
}
extern "C" {
    #[doc = " \\fn f32 GX_GetYScaleFactor(u16 efbHeight,u16 xfbHeight)\n \\brief Calculates an appropriate Y scale factor value for GX_SetDispCopyYScale() based on the height of the EFB and\n        the height of the XFB.\n\n \\param[in] efbHeight Height of embedded framebuffer. Range from 2 to 528. Should be a multiple of 2.\n \\param[in] xfbHeight Height of external framebuffer. Range from 2 to 1024. Should be equal or greater than \\a efbHeight.\n\n \\return Y scale factor which can be used as argument of GX_SetDispCopyYScale()."]
    pub fn GX_GetYScaleFactor(efbHeight: u16_, xfbHeight: u16_) -> f32_;
}
extern "C" {
    #[doc = " \\fn u32 GX_SetDispCopyYScale(f32 yscale)\n \\brief Sets the vertical scale factor for the EFB to XFB copy operation.\n\n \\details The number of actual lines copied is returned, based on the current EFB height. You can use this number to allocate the proper XFB size. You\n have to call GX_SetDispCopySrc() prior to this function call if you want to get the number of lines by using this function.\n\n \\param[in] yscale Vertical scale value. Range from 1.0 to 256.0.\n\n \\return Number of lines that will be copied."]
    pub fn GX_SetDispCopyYScale(yscale: f32_) -> u32_;
}
extern "C" {
    #[doc = " \\fn void GX_SetDispCopySrc(u16 left,u16 top,u16 wd,u16 ht)\n \\brief Sets the source parameters for the EFB to XFB copy operation.\n\n \\param[in] left left most source pixel to copy. Must be a multiple of 2 pixels.\n \\param[in] top top most source line to copy. Must be a multiple of 2 lines.\n \\param[in] wd width in pixels to copy. Must be a multiple of 2 pixels.\n \\param[in] ht height in lines to copy. Must be a multiple of 2 lines.\n\n \\return none"]
    pub fn GX_SetDispCopySrc(left: u16_, top: u16_, wd: u16_, ht: u16_);
}
extern "C" {
    #[doc = " \\fn void GX_SetDispCopyDst(u16 wd,u16 ht)\n \\brief Sets the witdth and height of the display buffer in pixels.\n\n \\details The application typical renders an image into the EFB(source) and then copies it into the XFB(destination) in main memory. \\a wd\n specifies the number of pixels between adjacent lines in the destination buffer and can be different than the width of the EFB.\n\n \\param[in] wd Distance between successive lines in the XFB, in pixels. Must be a multiple of 16.\n \\param[in] ht Height of the XFB in lines.\n\n \\return none"]
    pub fn GX_SetDispCopyDst(wd: u16_, ht: u16_);
}
extern "C" {
    #[doc = " \\fn void GX_SetCopyClamp(u8 clamp)\n \\brief Sets the vertical clamping mode to use during the EFB to XFB or texture copy.\n\n \\param[in] clamp bit-wise OR of desired \\ref xfbclamp. Use <tt>GX_CLAMP_NONE</tt> for no clamping.\n\n \\return none"]
    pub fn GX_SetCopyClamp(clamp: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetDispCopyGamma(u8 gamma)\n \\brief Sets the gamma correction applied to pixels during EFB to XFB copy operation.\n\n \\param[in] gamma \\ref gammamode\n\n \\return none"]
    pub fn GX_SetDispCopyGamma(gamma: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetCopyFilter(u8 aa,u8 sample_pattern[12][2],u8 vf,u8 vfilter[7])\n \\brief Sets the subpixel sample patterns and vertical filter coefficients used to filter subpixels into pixels.\n\n \\details This function normally uses the \\a aa, \\a sample_pattern and \\a vfilter provided by the render mode struct:<br><br>\n\n \\code GXRModeObj* rmode = VIDEO_GetPreferredMode(NULL);\n GX_SetCopyFilter(rmode->aa,rmode->sample_pattern,GX_TRUE,rmode->vfilter); \\endcode\n\n \\note In order to make use of the \\a sample_pattern, antialiasing must be enabled by setting the Embedded Frame Buffer (EFB) format to\n <tt>GX_PF_RGB565_Z16</tt>; see GX_SetPixelFmt().\n\n \\param[in] aa utilizes \\a sample_pattern if <tt>GX_TRUE</tt>, otherwise all sample points are centered\n \\param[in] sample_pattern array of coordinates for sample points; valid range is 1 - 11 inclusive\n \\param[in] vf use \\a vfilter if <tt>GX_TRUE</tt>, otherwise use default 1-line filter\n \\param[in] vfilter vertical filter coefficients; valid coefficient range is 0 - 63 inclusive; sum should equal 64\n\n \\return none"]
    pub fn GX_SetCopyFilter(
        aa: u8_,
        sample_pattern: *mut [u8_; 2usize],
        vf: u8_,
        vfilter: *mut u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetDispCopyFrame2Field(u8 mode)\n \\brief Determines which lines are read from the Embedded Frame Buffer (EFB) when using GX_CopyDisp().\n\n \\details Specifically, it determines whether all lines, only even lines, or only odd lines are read.\n\n \\note The opposite function, which determines whether all lines, only even lines or only odd lines are <i>written</i> to the EFB, is GX_SetFieldMask().<br><br>\n\n \\note Only applies to display copies, GX_CopyTex() always uses the <tt>GX_COPY_PROGRESSIVE</tt> mode.\n\n \\param[in] mode \\ref copymode to determine which field to copy (or both)\n\n \\return none"]
    pub fn GX_SetDispCopyFrame2Field(mode: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetCopyClear(GXColor color,u32 zvalue)\n \\brief Sets color and Z value to clear the EFB to during copy operations.\n\n \\details These values are used during both display copies and texture copies.\n\n \\param[in] color RGBA color (8-bit/component) to use during clear operation.\n \\param[in] zvalue 24-bit Z value to use during clear operation. Use the constant <tt>GX_MAX_Z24</tt> to specify the maximum depth value.\n\n \\return none"]
    pub fn GX_SetCopyClear(color: GXColor, zvalue: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_CopyDisp(void *dest,u8 clear)\n \\brief Copies the embedded framebuffer (EFB) to the external framebuffer(XFB) in main memory.\n\n \\note The stride of the XFB is set using GX_SetDispCopyDst(). The source image in the EFB is described using GX_SetDispCopySrc().<br><br>\n\n \\note The graphics processor will stall all graphics commands util the copy is complete.<br><br>\n\n \\note If the \\a clear flag is true, the color and Z buffers will be cleared during the copy. They will be cleared to the constant\n values set using GX_SetCopyClear().\n\n \\param[in] dest pointer to the external framebuffer. \\a dest should be 32B aligned.\n \\param[in] clear flag that indicates framebuffer should be cleared if <tt>GX_TRUE</tt>.\n\n \\return none"]
    pub fn GX_CopyDisp(dest: *mut ::libc::c_void, clear: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTexCopySrc(u16 left,u16 top,u16 wd,u16 ht)\n \\brief Sets the source parameters for the Embedded Frame Buffer (EFB) to texture image copy.\n\n \\details The GP will copy textures into the tiled texture format specified in GX_CopyTex(). The GP always copies tiles (32B) so image widths and\n heights that are not a multiple of the tile width will be padded with undefined data in the copied image\n\n \\param[in] left left-most source pixel to copy, multiple of two\n \\param[in] top top-most source line to copy, multiple of two\n \\param[in] wd width to copy in pixels, multiple of two\n \\param[in] ht height to copy in pixels, multiple of two\n\n \\return none"]
    pub fn GX_SetTexCopySrc(left: u16_, top: u16_, wd: u16_, ht: u16_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTexCopyDst(u16 wd,u16 ht,u32 fmt,u8 mipmap)\n \\brief This function sets the width and height of the destination texture buffer in texels.\n\n \\details This function sets the width (\\a wd) and height (\\a ht) of the destination texture buffer in texels. The application may render an image into\n the EFB and then copy it into a texture buffer in main memory. \\a wd specifies the number of texels between adjacent lines in the texture buffer and can\n be different than the width of the source image. This function also sets the texture format (\\a fmt) to be created during the copy operation. An\n optional box filter can be enabled using \\a mipmap. This flag will scale the source image by 1/2.\n\n Normally, the width of the EFB and destination \\a wd are the same. When rendering smaller images that get copied and composited into a larger texture\n buffer, however, the EFB width and texture buffer \\a wd are not necessarily the same.\n\n The Z buffer can be copied to a Z texture format by setting \\a fmt to <tt>GX_TF_Z24X8</tt>. This operation is only valid when the EFB format is\n <tt>GX_PF_RGB8_Z24</tt> or <tt>GX_PF_RGBA6_Z24</tt>.\n\n The alpha channel can be copied from an EFB with format <tt>GX_PF_RGBA6_Z24</tt> by setting \\a fmt to <tt>GX_TF_A8</tt>.\n\n \\param[in] wd distance between successive lines in the texture buffer, in texels; must be a multiple of the texture tile width, which depends on \\a fmt.\n \\param[in] ht height of the texture buffer\n \\param[in] fmt \\ref texfmt\n \\param[in] mipmap flag that indicates framebuffer should be cleared if <tt>GX_TRUE</tt>.\n\n \\return none"]
    pub fn GX_SetTexCopyDst(wd: u16_, ht: u16_, fmt: u32_, mipmap: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_CopyTex(void *dest,u8 clear)\n \\brief Copies the embedded framebuffer (EFB) to the texture image buffer \\a dest in main memory.\n\n \\details This is useful when creating textures using the Graphics Processor (GP). If the \\a clear flag is set to <tt>GX_TRUE</tt>, the EFB will be cleared\n to the current color(see GX_SetCopyClear()) during the copy operation.\n\n \\param[in] dest pointer to the image buffer in main memory. \\a dest should be 32B aligned.\n \\param[in] clear flag that indicates framebuffer should be cleared if <tt>GX_TRUE</tt>.\n\n \\return none"]
    pub fn GX_CopyTex(dest: *mut ::libc::c_void, clear: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PixModeSync(void)\n \\brief Causes the GPU to wait for the pipe to flush.\n\n \\details This function inserts a synchronization command into the graphics FIFO. When the GPU sees this command it will allow the rest of the pipe to\n flush before continuing. This command is useful in certain situation such as after using GX_CopyTex() and before a primitive that uses the copied texture.\n\n \\note The command is actually implemented by writing the control register that determines the format of the embedded frame buffer (EFB). As a result, care\n should be used if this command is placed within a display list.\n\n \\return none"]
    pub fn GX_PixModeSync();
}
extern "C" {
    #[doc = " \\fn void GX_ClearBoundingBox(void)\n \\brief Clears the bounding box values before a new image is drawn.\n\n \\details The graphics hardware keeps track of a bounding box of pixel coordinates that are drawn in the Embedded Frame Buffer (EFB).\n\n \\return none"]
    pub fn GX_ClearBoundingBox();
}
extern "C" {
    #[doc = " \\fn GX_PokeAlphaMode(u8 func,u8 threshold)\n \\brief Sets a threshold which is compared to the alpha of pixels written to the Embedded Frame Buffer (EFB) using the GX_Poke*() functions.\n\n \\details The compare function order is:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src_alpha \\a func \\a threshold\n\n \\note The alpha compare function can be used to conditionally write pixels to the EFB using the source alpha channel as a template. If the compare function is\n true, the source color will be written to the EFB based on the result of the Z compare (see GX_PokeZMode()). If the alpha compare function is false, the source\n color is not written to the EFB.<br><br>\n\n \\note The alpha compare test happens before the Z compare and before blending (see GX_PokeBlendMode()).\n\n \\param[in] func \\ref compare to use\n \\param[in] threshold to which the source alpha will be compared to\n\n \\return none"]
    pub fn GX_PokeAlphaMode(func: u8_, threshold: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeAlphaUpdate(u8 update_enable)\n \\brief Enables or disables alpha-buffer updates for GX_Poke*() functions.\n\n \\details The normal rendering state (set by GX_SetAlphaUpdate()) is not affected.\n\n \\param[in] update_enable enables alpha-buffer updates with <tt>GX_TRUE</tt>, otherwise does not\n\n \\return none"]
    pub fn GX_PokeAlphaUpdate(update_enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeColorUpdate(u8 update_enable)\n \\brief Enables or disables color-buffer updates when writing the Embedded Frame Buffer (EFB) using the GX_Poke*() functions.\n\n \\param[in] update_enable enables color-buffer updates with <tt>GX_TRUE</tt>, otherwise does not\n\n \\return none"]
    pub fn GX_PokeColorUpdate(update_enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeDither(u8 dither)\n \\brief Enables dithering when writing the Embedded Frame Buffer (EFB) using GX_Poke*() functions.\n\n \\note The \\a dither enable is only valid when the pixel format (see GX_SetPixelFmt()) is either <tt>GX_PF_RGBA6_Z24</tt> or <tt>GX_PF_RGB565_Z16</tt>.<br><br>\n\n \\note A 4x4 Bayer matrix is used for dithering.\n\n \\param[in] dither if set to <tt>GX_TRUE</tt> and pixel format is one of the above, dithering is enabled; otherwise disabled\n\n \\return none"]
    pub fn GX_PokeDither(dither: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op)\n \\brief Determines how the source image, is blended with the current Embedded Frame Buffer (EFB).\n\n \\details When type is set to <tt>GX_BM_NONE</tt>, no color data is written to the EFB. When type is set to <tt>GX_BM_BLEND</tt>, the source and EFB pixels\n are blended using the following equation:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>src_pix_clr</i> * \\a src_fact + <i>dst_pix_clr</i> * \\a dst_fact<br><br>\n\n When type is set to <tt>GX_BM_SUBTRACT</tt>, the destination pixel is computed as follows:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>dst_pix_clr</i> - <i>src_pix_clr [clamped to zero]</i><br><br>\n\n Note that \\a src_fact and \\a dst_fact are not part of the equation.\n\n \\note \\a dst_fact can be used only when the frame buffer has <tt>GX_PF_RGBA6_Z24</tt> as the pixel format (see GX_SetPixelFmt()).<br><br>\n\n \\note When type is set to <tt>GX_BM_LOGIC</tt>, the source and EFB pixels are blended using logical bitwise operations.<br><br>\n\n \\note This function does not effect the normal rendering state; see GX_SetBlendMode().\n\n \\param[in] type \\ref blendmode\n \\param[in] src_fact source \\ref blendfactor; the pixel color produced by the graphics processor is multiplied by this factor\n \\param[in] dst_fact destination \\ref blendfactor; the current frame buffer pixel color is multiplied by this factor\n \\param[in] op \\ref logicop to use"]
    pub fn GX_PokeBlendMode(type_: u8_, src_fact: u8_, dst_fact: u8_, op: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeAlphaRead(u8 mode)\n \\brief Determines what value of alpha will be read from the Embedded Frame Buffer (EFB).\n\n \\details The mode only applies to GX_Peek*() functions.\n\n \\note This feature works no matter what pixel type (see GX_SetPixelFmt()) you are using. If you are using the EFB with alpha plane, it is\n recommended that you use <tt>GX_READ_NONE</tt> so that you can read correct alpha value from the EFB. If you are using the EFB with no alpha, you should\n set either of <tt>GX_READ_00</tt> or <tt>GX_READ_FF</tt> in order to get a certain value.<br><br>\n\n \\param[in] mode \\ref alphareadmode that determines value of alpha read from a frame buffer with no alpha channel.\n\n \\return none"]
    pub fn GX_PokeAlphaRead(mode: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeDstAlpha(u8 enable,u8 a)\n \\brief Sets a constant alpha value for writing to the Embedded Frame Buffer (EFB).\n\n \\details The EFB pixel type must have an alpha channel for this function to be effective (see GX_SetPixelFmt()). The blending operations (see\n GX_PokeBlendMode()) still use source alpha but when writing the pixel color, the constant \\a a will replace the pixel alpha in the EFB.\n\n \\param[in] enable if set to <tt>GX_ENABLE</tt> and pixel format supports dest alpha, \\a a will be written to the framebuffer\n \\param[in] a constant alpha value\n\n \\return none"]
    pub fn GX_PokeDstAlpha(enable: u8_, a: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeARGB(u16 x,u16 y,GXColor color)\n \\brief Allows the CPU to write \\a color directly to the Embedded Frame Buffer (EFB) at position \\a x,\\a y.\n\n \\details The alpha value in \\a color can be compared with the current alpha threshold (see GX_PokeAlphaMode()). The color will be blended\n into the EFB using the blend mode set by GX_PokeBlendMode().\n\n \\note For an antialiased frame buffer, all 3 subsamples of a pixel are affected by the poke.\n\n \\param[in] x coordinate, in pixels; must be 0 - 639 inclusive\n \\param[in] y coordinate, in lines; must be 0 - 527 inclusive\n \\param[in] color color to write at the location\n\n \\return none"]
    pub fn GX_PokeARGB(x: u16_, y: u16_, color: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_PeekARGB(u16 x,u16 y,GXColor *color)\n \\brief Allows the CPU to read a color value directly from the Embedded Frame Buffer (EFB) at position \\a x,\\a y.\n\n \\note For an antialiased frame buffer, only subsample 0 of a pixel is read.\n\n \\param[in] x coordinate, in pixels; must be 0 - 639 inclusive\n \\param[in] y coordinate, in lines; must be 0 - 527 inclusive\n \\param[out] color struct to store color in\n\n \\return none"]
    pub fn GX_PeekARGB(x: u16_, y: u16_, color: *mut GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_PokeZ(u16 x,u16 y,u32 z)\n \\brief Allows the CPU to write a z value directly to the Embedded Frame Buffer (EFB) at position \\a x,\\a y.\n\n \\details The \\a z value can be compared with the current contents of the EFB. The Z compare fuction is set using GX_PokeZMode().\n\n \\note The \\a z value should be in the range of 0x00000000 <= \\a z < 0x00FFFFFF in the case of non-antialiased frame buffer. For an antialiased\n frame buffer, the \\a z value should be in the compressed 16-bit format (0x00000000 <= \\a z <= 0x0000FFFF), and the poke will affect all 3\n subsamples of a pixel.\n\n \\param[in] x coordinate, in pixels; must be 0 - 639 inclusive\n \\param[in] y coordinate, in lines; must be 0 - 527 inclusive\n \\param[in] z value to write at position \\a x,\\a y in the EFB\n\n \\return none"]
    pub fn GX_PokeZ(x: u16_, y: u16_, z: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_PeekZ(u16 x,u16 y,u32 *z)\n \\brief Allows the CPU to read a z value directly from the Embedded Frame Buffer (EFB) at position x,y.\n\n \\details The z value is raw integer value from the Z buffer.\n\n \\note The value range is 24-bit when reading from non-antialiased frame buffer. When reading from an antialiased frame buffer, subsample\n 0 is read and returned. The value will be compressed 16-bit form in this case.\n\n \\param[in] x coordinate, in pixels; must be 0 - 639 inclusive\n \\param[in] y coordinate, in lines; must be 0 - 527 inclusive\n \\param[out] z pointer to a returned Z value\n\n \\return none"]
    pub fn GX_PeekZ(x: u16_, y: u16_, z: *mut u32_);
}
extern "C" {
    #[doc = " \\fn void GX_PokeZMode(u8 comp_enable,u8 func,u8 update_enable)\n \\brief Sets the Z-buffer compare mode when writing the Embedded Frame Buffer (EFB).\n\n \\details The result of the Z compare is used to conditionally write color values to the EFB. The Z value will be updated according to the\n result of the compare if Z update is enabled.\n\n When \\a comp_enable is set to <tt>GX_DISABLE</tt>, poke Z buffering is disabled and the Z buffer is not updated. The \\a func parameter determines the\n comparison that is performed. In the comparison function, the poked Z value is on the left while the Z value from the Z buffer is on the\n right. If the result of the comparison is false, the poked Z value is discarded. The parameter \\a update_enable determines whether or not the\n Z buffer is updated with the new Z value after a comparison is performed.\n\n \\note The normal rendering Z mode (set by GX_SetZMode()) is not affected by this function.<br><br>\n\n \\note Even if update_enable is <tt>GX_FALSE</tt>, compares may still be enabled.\n\n \\param[in] comp_enable enables comparisons with source and destination Z values if <tt>GX_TRUE</tt>\n \\param[in] func \\ref compare function to use\n \\param[in] update_enable enables Z-buffer updates when <tt>GX_TRUE</tt>\n\n \\return none"]
    pub fn GX_PokeZMode(comp_enable: u8_, func: u8_, update_enable: u8_);
}
extern "C" {
    #[doc = " \\fn u32 GX_GetTexObjFmt(const GXTexObj *obj)\n \\brief Returns the texture format described by texture object \\a obj.\n\n \\note Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture format.\n\n \\param[in] obj ptr to a texture object\n\n \\return texture format of the given texture object"]
    pub fn GX_GetTexObjFmt(obj: *const GXTexObj) -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 GX_GetTexObjMipMap(const GXTexObj *obj)\n \\brief Returns the texture mipmap enable described by texture object \\a obj.\n\n \\note Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture mipmap enable.\n\n \\param[in] obj ptr to a texture object\n\n \\return mipmap enable flag"]
    pub fn GX_GetTexObjMipMap(obj: *const GXTexObj) -> u32_;
}
extern "C" {
    #[doc = " \\fn void* GX_GetTexObjUserData(const GXTexObj *obj)\n \\brief Used to get a pointer to user data from the \\ref GXTexObj structure.\n\n \\details You can use this function to retrieve private data structures from the texture object. This pointer is set using GX_InitTexObjUserData().\n\n \\param[in] obj ptr to object to read data from\n\n \\return Pointer to user data."]
    pub fn GX_GetTexObjUserData(obj: *const GXTexObj) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\fn void* GX_GetTexObjData(const GXTexObj *obj)\n \\brief Used to get a pointer to texture data from the \\ref GXTexObj structure.\n\n \\note The returned pointer is a physical address.\n\n \\param[in] obj ptr to a texture object\n\n \\return Physical pointer to texture data."]
    pub fn GX_GetTexObjData(obj: *const GXTexObj) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\fn u8 GX_GetTexObjWrapS(const GXTexObj* obj)\n \\brief Returns the texture wrap s mode described by texture object \\a obj.\n\n \\note Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture wrap s mode.\n\n \\param[in] obj ptr to a texture object\n\n \\return wrap s mode"]
    pub fn GX_GetTexObjWrapS(obj: *const GXTexObj) -> u8_;
}
extern "C" {
    #[doc = " \\fn u8 GX_GetTexObjWrapT(const GXTexObj* obj)\n \\brief Returns the texture wrap t mode described by texture object \\a obj.\n\n \\note Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture wrap t mode.\n\n \\param[in] obj ptr to a texture object\n\n \\return wrap t mode"]
    pub fn GX_GetTexObjWrapT(obj: *const GXTexObj) -> u8_;
}
extern "C" {
    #[doc = " \\fn u16 GX_GetTexObjHeight(const GXTexObj* obj)\n \\brief Returns the texture height described by texture object \\a obj.\n\n \\note Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture height.\n\n \\param[in] obj ptr to a texture object\n\n \\return texture height"]
    pub fn GX_GetTexObjHeight(obj: *const GXTexObj) -> u16_;
}
extern "C" {
    #[doc = " \\fn u16 GX_GetTexObjWidth(const GXTexObj* obj)\n \\brief Returns the texture width described by texture object \\a obj.\n\n \\note Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture width.\n\n \\param[in] obj ptr to a texture object\n\n \\return texture width"]
    pub fn GX_GetTexObjWidth(obj: *const GXTexObj) -> u16_;
}
extern "C" {
    #[doc = " \\fn void GX_GetTexObjAll(const GXTexObj* obj, void** image_ptr, u16* width, u16* height, u8* format, u8* wrap_s, u8* wrap_t, u8* mipmap);\n \\brief Returns the parameters described by a texture object. Texture objects are used to describe all the parameters associated with a texture, including size, format, wrap modes, filter modes, etc. Texture objects are initialized using either GX_InitTexObj() or, for color index format textures, GX_InitTexObjCI().\n\n \\param[in] obj ptr to a texture object\n \\param[out] image_ptr Returns a physical pointer to the image data for a texture.\n \\param[out] width Returns the width of the texture or LOD 0 for mipmaps\n \\param[out] height Returns the height of the texture or LOD 0 for mipmaps\n \\param[out] format Returns the texel format\n \\param[out] mipmap Returns the mipmap enable flag.\n\n \\return none"]
    pub fn GX_GetTexObjAll(
        obj: *const GXTexObj,
        image_ptr: *mut *mut ::libc::c_void,
        width: *mut u16_,
        height: *mut u16_,
        format: *mut u8_,
        wrap_s: *mut u8_,
        wrap_t: *mut u8_,
        mipmap: *mut u8_,
    );
}
extern "C" {
    #[doc = " \\fn u32 GX_GetTexBufferSize(u16 wd,u16 ht,u32 fmt,u8 mipmap,u8 maxlod)\n \\brief Returns the amount of memory in bytes needed to store a texture of the given size and \\a fmt.\n\n \\details If the \\a mipmap flag is <tt>GX_TRUE</tt>, then the size of buffer needed for the mipmap pyramid up to \\a maxlod will be returned.\n \\a maxlod will be clamped to the number of LODs possible given the map \\a wd and \\a ht. For mipmaps, \\a wd and \\a ht must be a power of two.\n\n \\note This function takes into account the tiling and padding requirements of the GameCube's native texture format. The resulting size can be used\n along with memalign() to allocate texture buffers (see GX_CopyTex()).\n\n \\param[in] wd width of the texture in texels\n \\param[in] ht height of the texture in texels\n \\param[in] fmt format of the texture; use GX_TexFmt() or GX_CITexFmt() to get it\n \\param[in] mipmap flag indicating whether or not the texture is a mipmap\n \\param[in] maxlod if \\a mipmap is \\a GX_TRUE, texture size will include mipmap pyramid up to this value\n\n \\return number of bytes needed for the texture, including tile padding"]
    pub fn GX_GetTexBufferSize(wd: u16_, ht: u16_, fmt: u32_, mipmap: u8_, maxlod: u8_) -> u32_;
}
extern "C" {
    #[doc = " \\fn void GX_InvalidateTexAll(void)\n \\brief Invalidates the current caches of the Texture Memory (TMEM).\n\n \\details It takes about 512 GP clocks to invalidate all the texture caches.\n\n \\note Preloaded textures (see GX_PreloadEntireTexture()) are not affected.\n\n \\return none"]
    pub fn GX_InvalidateTexAll();
}
extern "C" {
    #[doc = " \\fn void GX_InvalidateTexRegion(GXTexRegion *region)\n \\brief Invalidates the texture cache in Texture Memory (TMEM) described by \\a region.\n\n \\details This function should be called when the CPU is used to modify a texture in main memory, or a new texture is loaded into main memory that\n is possibly cached in the texture region.\n\n \\note In reality, this function invalidates the cache tags, forcing the texture cache to load new data. Preloaded textures (see\n GX_PreloadEntireTexture()) do not use the tags.<br><br>\n\n \\note The texture hardware can invalidate 4 tags each GP clock. Each tag represents a superline or 512B of TMEM. Therefore, it takes 16\n GP clocks to invalidate a 32KB texture region.\n\n \\param[in] region ptr to GXTexRegion object\n\n \\return none"]
    pub fn GX_InvalidateTexRegion(region: *mut GXTexRegion);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexCacheRegion(GXTexRegion *region,u8 is32bmipmap,u32 tmem_even,u8 size_even,u32 tmem_odd,u8 size_odd)\n \\brief Initializes a texture memory (TMEM) region object for cache.\n\n \\details The region is allocated by the application and can be used as a cache. An application can create many region objects and some of them can\n overlap; however, no two overlapping regions can be active at the same time.\n\n The possible sizes of a TMEM cache region are 32K, 128K or 512K.\n\n \\note For pre-loaded textures, the region must be defined by using GX_InitTexPreloadRegion().<br><br>\n\n \\note GX_Init() creates default texture regions, so it is not necessary for the application to use this function unless a different Texture Memory\n configuration is desired. In that case, the application should also define a region allocator using GX_SetTexRegionCallback().<br><br>\n\n \\note The function GX_InvalidateTexRegion() can be used to force the texture in main memory associated with this region to be reloaded. This will be\n necessary whenever the texture data in main memory changes. You may invalidate all cached regions at once using GX_InvalidateTexAll().\n\n \\param[in] region ptr to a GXTexRegion struct\n \\param[in] is32bmipmap should be set to <tt>GX_TRUE</tt> to interpret parameters according to the 32b mipmap meaning.\n \\param[in] tmem_even base ptr in TMEM for even LODs; must be multiple of 2KB\n \\param[in] size_even even \\ref texcachesize other than <tt>GX_TEXCACHE_NONE</tt>\n \\param[in] tmem_odd base ptr in TMEM for odd LODs; must be multiple of 2KB\n \\param[in] size_odd odd \\ref texcachesize other than <tt>GX_TEXCACHE_NONE</tt>\n\n \\return none"]
    pub fn GX_InitTexCacheRegion(
        region: *mut GXTexRegion,
        is32bmipmap: u8_,
        tmem_even: u32_,
        size_even: u8_,
        tmem_odd: u32_,
        size_odd: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitTexPreloadRegion(GXTexRegion *region,u32 tmem_even,u32 size_even,u32 tmem_odd,u32 size_odd)\n \\brief Initializes a Texture Memory (TMEM) region object for preloading.\n\n \\details The region is allocated in TMEM by the application and can be used only as a pre-loaded buffer. Cache regions must be allocated\n by using GX_InitTexCacheRegion(). For pre-loaded textures, the size of the region must match the size of the texture. An application can\n create many region objects and some of them can overlap; however, no two overlapping regions can be active at the same time.\n\n \\note The maximum size of a region is 512K.\n\n \\warning GX_Init() creates no region for preloading, so the application should allocate appropriate regions if preloading is necessary. It\n is also required to create cache regions and its allocator by using GX_InitTexCacheRegion() and GX_SetTexRegionCallback(), otherwise new\n cache regions may overwrite the preloaded areas. (Alternatively, if you do not use any color-index textures, you may preload textures into\n the portion of texture memory normally allocated to color-index usage by the default allocator.)\n\n \\param[in] region ptr to a GXTexRegion struct\n \\param[in] tmem_even base ptr in TMEM for even LODs; must be 32B aligned\n \\param[in] size_even size of the even cache, in bytes; should be multiple of 32B\n \\param[in] tmem_odd base ptr in TMEM for odd LODs; must be 32B aligned\n \\param[in] size_odd size of the odd cache, in bytes; should be multiple of 32B\n\n \\return none"]
    pub fn GX_InitTexPreloadRegion(
        region: *mut GXTexRegion,
        tmem_even: u32_,
        size_even: u32_,
        tmem_odd: u32_,
        size_odd: u32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObj(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap)\n \\brief Used to initialize or change a texture object for non-color index textures.\n\n \\details Texture objects are used to describe all the parameters associated with a texture, including size, format, wrap modes, filter modes,\n etc. It is the application's responsibility to provide memory for a texture object. Once initialized, a texture object can be associated with\n one of eight active texture IDs using GX_LoadTexObj().\n\n \\note To initialize a texture object for color index format textures, use GX_InitTexObjCI().<br><br>\n\n \\note If the mipmap flag is <tt>GX_TRUE</tt>, then the texture is a mipmap and the texture will be trilerped. If the mipmap flag is <tt>GX_FALSE</tt>, the texture\n is not a mipmap and the texture will be bilerped. To override the filter modes and other mipmap controls, see GX_InitTexObjLOD().\n\n \\param[out] obj ptr to a texture object\n \\param[in] img_ptr ptr to the image data for a texture, aligned to 32B\n \\param[in] wd width of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n \\param[in] ht height of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n \\param[in] fmt \\ref texfmt\n \\param[in] wrap_s texture coordinate wrapping strategy in the S direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n \\param[in] wrap_t texture coordinate wrapping strategy in the T direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n \\param[in] mipmap trilinear filtering will be used if <tt>GX_TRUE</tt>, otherwise bilinear is used\n\n \\return none"]
    pub fn GX_InitTexObj(
        obj: *mut GXTexObj,
        img_ptr: *mut ::libc::c_void,
        wd: u16_,
        ht: u16_,
        fmt: u8_,
        wrap_s: u8_,
        wrap_t: u8_,
        mipmap: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjCI(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap,u32 tlut_name)\n \\brief Used to initialize or change a texture object when the texture is color index format.\n\n \\details Texture objects are used to describe all the parameters associated with a texture, including size, format, wrap modes, filter modes,\n etc. It is the application's responsibility to provide memory for a texture object. Once initialized, a texture object can be associated with\n one of eight active texture IDs using GX_LoadTexObj().\n\n \\note If the \\a mipmap flag is <tt>GX_TRUE</tt>, then the texture is a mipmap and the texture will be filtered using the <tt>GX_LIN_MIP_NEAR</tt> filter mode\n (color index mipmaps cannot use the <tt>GX_LIN_MIP_LIN</tt> or <tt>GX_NEAR_MIP_LIN</tt> mode). If the \\a mipmap flag is <tt>GX_FALSE</tt>, the texture is not a mipmap\n and the texture will be bilerped. To override the filter modes and other mipmap controls, use GX_InitTexObjLOD(). Mipmap textures should\n set the width and height to a power of two, but mipmaps do not need to be square.<br><br>\n\n \\note Non-mipmap (planar) textures do not have to be a power of two. However, to use the <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt> modes for \\a wrap_s and \\a wrap_t\n the width and height, respectively, must be a power of two.<br><br>\n\n \\note The \\a tlut_name is used to indicate which texture lookup table (TLUT) to use for the index to color conversion. To load the TLUT into\n texture memory, use GX_LoadTlut().\n\n \\param[in] obj ptr to a texture object\n \\param[in] img_ptr ptr to the image data for a texture, aligned to 32B\n \\param[in] wd width of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n \\param[in] ht height of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n \\param[in] fmt \\ref texfmt\n \\param[in] wrap_s texture coordinate wrapping strategy in the S direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n \\param[in] wrap_t texture coordinate wrapping strategy in the T direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n \\param[in] mipmap if <tt>GX_TRUE</tt>, it is a mipmap texture, else it is a planar texture\n \\param[in] tlut_name TLUT name to use for this texture; default texture configuration recognizes \\ref tlutname\n\n \\return none"]
    pub fn GX_InitTexObjCI(
        obj: *mut GXTexObj,
        img_ptr: *mut ::libc::c_void,
        wd: u16_,
        ht: u16_,
        fmt: u8_,
        wrap_s: u8_,
        wrap_t: u8_,
        mipmap: u8_,
        tlut_name: u32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjTlut(GXTexObj *obj,u32 tlut_name)\n \\brief Allows one to modify the TLUT that is associated with an existing texture object.\n\n \\param[in] obj ptr to a texture object\n \\param[in] tlut_name TLUT name to use for this texture; default texture configuration recognizes \\ref tlutname\n\n \\return none"]
    pub fn GX_InitTexObjTlut(obj: *mut GXTexObj, tlut_name: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjData(GXTexObj *obj,void *img_ptr)\n \\brief Allows one to modify the image data pointer for an existing texture object.\n\n \\note The image format and size for the new data must agree with what they were when the texture object was first initialized using\n GX_InitTexObj() or GX_InitTexObjCI().\n\n \\param[in] obj ptr to a texture object\n \\param[in] img_ptr ptr to the texture data in main memory\n\n \\return none"]
    pub fn GX_InitTexObjData(obj: *mut GXTexObj, img_ptr: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjWrapMode(GXTexObj *obj,u8 wrap_s,u8 wrap_t)\n \\brief Allows one to modify the texture coordinate wrap modes for an existing texture object.\n\n \\param[in] obj ptr to a texture object\n \\param[in] wrap_s texture coordinate wrapping strategy in the S direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n \\param[in] wrap_t texture coordinate wrapping strategy in the T direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n\n \\return none"]
    pub fn GX_InitTexObjWrapMode(obj: *mut GXTexObj, wrap_s: u8_, wrap_t: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjFilterMode(GXTexObj *obj,u8 minfilt,u8 magfilt)\n \\brief Sets the filter mode for a texture.\n\n \\details When the ratio of texels for this texture to pixels is not 1:1, the filter type for \\a minfilt or \\a magfilt is used.\n\n \\param[in] obj texture object to set the filters for\n \\param[in] minfilt filter mode to use when the texel/pixel ratio is >= 1.0; needs to be one of \\ref texfilter.\n \\param[in] magfilt filter mode to use when the texel/pixel ratio is < 1.0; needs to be \\a GX_NEAR or \\a GX_LINEAR"]
    pub fn GX_InitTexObjFilterMode(obj: *mut GXTexObj, minfilt: u8_, magfilt: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjMinLOD(GXTexObj *obj,f32 minlod)\n \\brief Sets the minimum LOD for a given texture.\n\n \\param[in] obj texture to set the minimum LOD for\n \\param[in] minlod minimum LOD value; the hardware will use MAX(min_lod, lod); range is 0.0 to 10.0."]
    pub fn GX_InitTexObjMinLOD(obj: *mut GXTexObj, minlod: f32_);
}
extern "C" {
    #[doc = " void GX_InitTexObjMaxLOD(GXTexObj *obj,f32 maxlod)\n \\brief Sets the maximum LOD for a given texture.\n\n \\param[in] obj texture to set the maximum LOD for\n \\param[in] maxlod maximum LOD value; the hardware will use MIN(max_lod, lod); range is 0.0 to 10.0."]
    pub fn GX_InitTexObjMaxLOD(obj: *mut GXTexObj, maxlod: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjLODBias(GXTexObj *obj,f32 lodbias)\n \\brief Sets the LOD bias for a given texture.\n\n \\details The LOD computed by the graphics hardware can be biased using this function. The \\a lodbias is added to the computed lod and the\n result is clamped between the values given to GX_InitTexObjMinLOD() and GX_InitTexObjMaxLOD(). If \\a GX_ENABLE is given to\n GX_InitTexObjBiasClamp(), the effect of \\a lodbias will diminish as the polygon becomes more perpendicular to the view direction.\n\n \\param[in] obj texture to set the LOD bias for\n \\param[in] lodbias bias to add to computed LOD value"]
    pub fn GX_InitTexObjLODBias(obj: *mut GXTexObj, lodbias: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjBiasClamp(GXTexObj *obj,u8 biasclamp)\n \\brief Enables bias clamping for texture LOD.\n\n \\details If \\a biasclamp is \\a GX_ENABLE, the sum of LOD and \\a lodbias (given in GX_InitTexObjLODBias()) is clamped so that it is never\n less than the minimum extent of the pixel projected in texture space. This prevents over-biasing the LOD when the polygon is perpendicular\n to the view direction.\n\n \\param[in] obj texture to set the bias clamp value for\n \\param[in] biasclamp whether or not to enable the bias clamp"]
    pub fn GX_InitTexObjBiasClamp(obj: *mut GXTexObj, biasclamp: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjEdgeLOD(GXTexObj *obj,u8 edgelod)\n \\brief Changes LOD computing mode.\n\n \\details When set to \\a GX_ENABLE, the LOD is computed using adjacent texels; when \\a GX_DISABLE, diagonal texels are used instead. This\n should be set to \\a GX_ENABLE if you use bias clamping (see GX_InitTexObjBiasClamp()) or anisotropic filtering (GX_ANISO_2 or GX_ANISO_4\n for GX_InitTexObjMaxAniso() argument).\n\n \\param[in] obj texture to set the edge LOD for\n \\param[in] edgelod mode to set LOD computation to"]
    pub fn GX_InitTexObjEdgeLOD(obj: *mut GXTexObj, edgelod: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjMaxAniso(GXTexObj *obj,u8 maxaniso)\n \\brief Sets the maximum anisotropic filter to use for a texture.\n\n \\details Anisotropic filtering is accomplished by iterating the square filter along the direction of anisotropy to better approximate the\n quadralateral. This type of filtering results in sharper textures at the expense of multiple cycles per quad. The hardware will only use\n multiple cycles when necessary, and the maximum number of cycles is clamped by the \\a maxaniso parameter, so setting \\a maxaniso to\n \\a GX_ANISO_2 will use at most 2 filter cycles per texture.\n\n \\note These filter cycles are internal to the texture filter hardware and do not affect the available number of TEV stages. When setting\n \\a maxaniso to \\a GX_ANISO_2 or \\a GX_ANISO_4, the \\a minfilt parameter given to GX_InitTexObjFilterMode() should be set to\n \\a GX_LIN_MIP_LIN.\n\n \\param[in] obj texture to set the max anisotropy value to\n \\param[in] maxaniso the maximum anistropic filter to use; must be one of \\ref anisotropy"]
    pub fn GX_InitTexObjMaxAniso(obj: *mut GXTexObj, maxaniso: u8_);
}
extern "C" {
    #[doc = " \\fn GX_InitTexObjUserData(GXTexObj *obj,void *userdata)\n \\brief Used to set a pointer to user data in the \\ref GXTexObj structure.\n\n \\details You can use this function to attach private data structures to the texture object. This pointer can be retrieved using GX_GetTexObjUserData().\n\n \\param[in] obj ptr to a texture object\n \\param[in] userdata pointer to your data to attach to this texture"]
    pub fn GX_InitTexObjUserData(obj: *mut GXTexObj, userdata: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " \\fn void GX_LoadTexObj(GXTexObj *obj,u8 mapid)\n \\brief Loads the state describing a texture into one of eight hardware register sets.\n\n \\details Before this happens, the texture object \\a obj should be initialized using GX_InitTexObj() or GX_InitTexObjCI(). The \\a id parameter refers to\n the texture state register set. Once loaded, the texture can be used in any Texture Environment (TEV) stage using GX_SetTevOrder().\n\n \\note This function will call the functions set by GX_SetTexRegionCallback() (and GX_SetTlutRegionCallback() if the texture is color-index\n format) to obtain the texture regions associated with this texture object. These callbacks are set to default functions by GX_Init().\n\n \\warning If the texture is a color-index texture, you <b>must</b> load the associated TLUT (using GX_LoadTlut()) before calling GX_LoadTexObj().\n\n \\param[in] obj ptr to a texture object\n \\param[in] mapid \\ref texmapid, <tt>GX_TEXMAP0</tt> to <tt>GX_TEXMAP7</tt> only\n\n \\return none"]
    pub fn GX_LoadTexObj(obj: *mut GXTexObj, mapid: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadTlut(GXTlutObj *obj,u32 tlut_name)\n \\brief Copies a Texture Look-Up Table (TLUT) from main memory to Texture Memory (TMEM).\n\n \\details The \\a tlut_name parameter is the name of a pre-allocated area of TMEM. The callback function set by GX_SetTlutRegionCallback() converts\n the \\a tlut_name into a \\ref GXTlutRegion pointer. The TLUT is loaded in the TMEM region described by this pointer. The TLUT object \\a obj describes the\n location of the TLUT in main memory, the TLUT format, and the TLUT size. \\a obj should have been previously initialized using GX_InitTlutObj().\n\n \\note GX_Init() sets a default callback to convert \\a tlut_names from \\ref tlutname to \\ref GXTlutRegion pointers. The default configuration of\n TMEM has 20 TLUTs, 16 each 256 entries by 16 bits, and 4 each 1k entries by 16 bits. This configuration can be overriden by calling\n GX_InitTlutRegion() and GX_InitTexCacheRegion() to allocate TMEM. Then you can define your own region allocation scheme using GX_SetTlutRegionCallback()\n and GX_SetTexRegionCallback().\n\n \\param[in] obj ptr to a TLUT object; application must allocate this\n \\param[in] tlut_name \\ref tlutname\n\n \\return none"]
    pub fn GX_LoadTlut(obj: *mut GXTlutObj, tlut_name: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadTexObjPreloaded(GXTexObj *obj,GXTexRegion *region,u8 mapid)\n \\brief Loads the state describing a preloaded texture into one of eight hardware register sets.\n\n \\details Before this happens, the texture object \\a obj should be initialized using GX_InitTexObj() or GX_InitTexObjCI(). The \\a mapid parameter refers to\n the texture state register set. The texture should be loaded beforehand using GX_PreloadEntireTexture(). Once loaded, the texture can be used in any Texture Environment\n (TEV) stage using GX_SetTevOrder().\n\n \\note GX_Init() initially calls GX_SetTevOrder() to make a simple texture pipeline that associates <tt>GX_TEXMAP0</tt> with <tt>GX_TEVSTAGE0</tt>,\n <tt>GX_TEXMAP1</tt> with <tt>GX_TEVSTAGE1</tt>, etc.<br><br>\n\n \\note GX_LoadTexObjPreloaded() will not call the functions set by GX_SetTexRegionCallback() (and GX_SetTlutRegionCallback() if the texture is color\n index format) because the region is set explicitly; however, these callback functions must be aware of all regions that are preloaded. The default\n callbacks set by GX_Init() assume there are no preloaded regions.\n\n \\param[in] obj ptr to a texture object\n \\param[in] region ptr to a region object that describes an area of texture memory\n \\param[in] mapid \\ref texmapid for reference in a TEV stage\n\n \\return none"]
    pub fn GX_LoadTexObjPreloaded(obj: *mut GXTexObj, region: *mut GXTexRegion, mapid: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_PreloadEntireTexture(GXTexObj *obj,GXTexRegion *region)\n \\brief Loads a given texture from DRAM into the texture memory.\n\n \\details Accesses to this texture will bypass the texture cache tag look-up and instead read the texels directly from texture memory. The\n texture region must be the same size as the texture (see GX_InitTexPreloadRegion()).\n\n \\note This function loads the texture into texture memory, but to use it as a source for the Texture Environment (TEV) unit, you must first\n call GX_LoadTexObjPreloaded(). The default configuration (as set by GX_Init()) of texture memory has no preloaded regions, so you must install\n your own region allocator callbacks using GX_SetTexRegionCallback() and GX_SetTlutRegionCallback().\n\n \\param[in] obj ptr to object describing the texture to laod\n \\param[in] region TMEM texture region to load the texture into\n\n \\return none"]
    pub fn GX_PreloadEntireTexture(obj: *mut GXTexObj, region: *mut GXTexRegion);
}
extern "C" {
    #[doc = " \\fn void GX_InitTlutObj(GXTlutObj *obj,void *lut,u8 fmt,u16 entries)\n \\brief Initializes a Texture Look-Up Table (TLUT) object.\n\n \\details The TLUT object describes the location of the TLUT in main memory, its format and the number of entries. The TLUT in main\n memory described by this object can be loaded into a TLUT allocated in the texture memory using the GX_LoadTlut() function.\n\n \\param[in] obj ptr to a TLUT object\n \\param[in] lut ptr to look-up table data; must be 32B aligned\n \\param[in] fmt format of the entries in the TLUt; <tt>GX_TL_IA8</tt>, <tt>GX_TL_RGB565</tt> or <tt>GX_TL_RGB5A3</tt>\n \\param[in] entries number of entries in this table; maximum is 16,384\n\n \\return none"]
    pub fn GX_InitTlutObj(obj: *mut GXTlutObj, lut: *mut ::libc::c_void, fmt: u8_, entries: u16_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTlutRegion(GXTlutRegion *region,u32 tmem_addr,u8 tlut_sz)\n \\brief Initializes a Texture Look-Up Table (TLUT) region object.\n\n \\note GX_Init() creates default TLUT regions, so the application does not need to call this function unless a new configuration\n of Texture Memory is desired. In that case, the application should also set a new TLUT region allocator using GX_SetTlutRegionCallback().\n\n \\param[in] region obj ptr to a TLUT region struct; application must allocate this\n \\param[in] tmem_addr location of the TLU in TMEM; ptr must be aligned to table size\n \\param[in] tlut_sz size of the table\n\n \\return none"]
    pub fn GX_InitTlutRegion(region: *mut GXTlutRegion, tmem_addr: u32_, tlut_sz: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_InitTexObjLOD(GXTexObj *obj,u8 minfilt,u8 magfilt,f32 minlod,f32 maxlod,f32 lodbias,u8 biasclamp,u8 edgelod,u8 maxaniso)\n \\brief Sets texture Level Of Detail (LOD) controls explicitly for a texture object.\n\n \\details It is the application's responsibility to provide memory for a texture object. When initializing a texture object using GX_InitTexObj()\n or GX_InitTexObjCI(), this information is set to default values based on the mipmap flag. This function allows the programmer to override those\n defaults.\n\n \\note This function should be called after GX_InitTexObj() or GX_InitTexObjCI() for a particular texture object.<br><br>\n\n \\note Setting \\a biasclamp prevents over-biasing the LOD when the polygon is perpendicular to the view direction.<br><br>\n\n \\note \\a edgelod should be set if \\a biasclamp is set or \\a maxaniso is set to <tt>GX_ANISO_2</tt> or <tt>GX_ANISO_4</tt>.<br><br>\n\n \\note Theoretically, there is no performance difference amongst various magnification/minification filter settings except <tt>GX_LIN_MIP_LIN</tt> filter with\n <tt>GX_TF_RGBA8</tt> texture format which takes twice as much as other formats. However, this argument is assuming an environment where texture cache always\n hits. On real environments, you will see some performance differences by changing filter modes (especially minification filter) because cache-hit ratio\n changes according to which filter mode is being used.\n\n \\param[in] obj ptr to a texture object\n \\param[in] minfilt \\ref texfilter to use when the texel/pixel ratio is >= 1.0\n \\param[in] magfilt \\ref texfilter to use when the texel/pixel ratio is < 1.0; use only <tt>GX_NEAR</tt> or <tt>GX_LINEAR</tt>\n \\param[in] minlod minimum LOD value from 0.0 - 10.0 inclusive\n \\param[in] maxlod maximum LOD value from 0.0 - 10.0 inclusive\n \\param[in] lodbias bias to add to computed LOD value\n \\param[in] biasclamp if <tt>GX_ENABLE</tt>, clamp (LOD+lodbias) so that it is never less than the minimum extent of the pixel projected in texture space\n \\param[in] edgelod if <tt>GX_ENABLE</tt>, compute LOD using adjacent texels\n \\param[in] maxaniso \\ref anisotropy to use\n\n \\return none"]
    pub fn GX_InitTexObjLOD(
        obj: *mut GXTexObj,
        minfilt: u8_,
        magfilt: u8_,
        minlod: f32_,
        maxlod: f32_,
        lodbias: f32_,
        biasclamp: u8_,
        edgelod: u8_,
        maxaniso: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_SetTexCoordScaleManually(u8 texcoord,u8 enable,u16 ss,u16 ts)\n \\brief Overrides the automatic texture coordinate scaling (based upon the associated map size) and lets one manually assign the scale values that\n are used for a given \\a texcoord.\n\n \\details Setting the \\a enable parameter to <tt>GX_TRUE</tt> gives this behavior. The given \\a texcoord retains these manual scale values until this function is\n called again. This function is also used to return a given texture coordinate back to normal, automatic scaling (by setting \\a enable to <tt>GX_FALSE</tt>).\n\n \\note A texture coordinate is scaled after being computed by the relevant texgen and before the actual texture lookup  Normally, the scale value is set\n according to the texture map that is associated with the texcoord by GX_SetTevOrder(). However, there are certain cases where a different scale value is\n desirable. One such case is when using indirect tiled textures (see GX_SetTevIndTile()).\n\n \\param[in] texcoord the \\ref texcoordid being changed\n \\param[in] enable if <tt>GX_TRUE</tt>, scale will be set manually, otherwise set automatically and \\a ss and \\a ts ignored\n \\param[in] ss manual scale value for the S component of the coordinate\n \\param[in] ts manual scale value for the T component of the coordinate\n\n \\return none"]
    pub fn GX_SetTexCoordScaleManually(texcoord: u8_, enable: u8_, ss: u16_, ts: u16_);
}
extern "C" {
    pub fn GX_SetTexCoordCylWrap(texcoord: u8_, s_enable: u8_, t_enable: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_SetTexCoordBias(u8 texcoord,u8 s_enable,u8 t_enable)\n \\brief Sets the texture coordinate bias of a particular texture.\n\n \\details Range bias is used with texture coordinates applied in <tt>GX_REPEAT</tt> wrap mode in order to increase the precision of texture coordinates\n that spread out over a large range. The texture coordinate values for a primitive are biased (by an equal integer) towards zero early in the\n graphics pipeline, thus preserving bits for calculation later in the pipe.  Since the coordinates are repeated, this bias by an integer should\n have no effect upon the actual appearance of the texture.\n\n \\note Texture coordinate range bias is something that is normally set automatically by the GX API (during GX_Begin()); however, when a texture\n coordinate is being scaled manually (by using GX_SetTexCoordScaleManually()), the associated bias is no longer modified by GX. Thus,\n GX_SetTexCoordBias() allows the bias to be changed while a texture coordinate is being manually controlled.\n\n \\param[in] texcoord \\ref texcoordid being changed\n \\param[in] s_enable enable or disable range bias in the S direction with <tt>GX_ENABLE</tt>/<tt>GX_DISABLE</tt>\n \\param[in] t_enable enable or disable range bias in the T direction with <tt>GX_ENABLE</tt>/<tt>GX_DISABLE</tt>\n\n \\return none"]
    pub fn GX_SetTexCoordBias(texcoord: u8_, s_enable: u8_, t_enable: u8_);
}
extern "C" {
    #[doc = " \\fn GXTexRegionCallback GX_SetTexRegionCallback(GXTexRegionCallback cb)\n \\brief Sets the callback function called by GX_LoadTexObj() to obtain an available texture region.\n\n \\details GX_Init() calls this function to set a default region-assignment policy. A programmer can override this default region assignment\n by implementing his own callback function. A pointer to the texture object and the texture map ID that are passed\n to GX_LoadTexObj() are provided to the callback function.\n\n \\param[in] cb ptr to a function that takes a pointer to a GXTexObj and a \\ref texmapid as a parameter and returns a pointer to a \\ref GXTexRegion.\n\n \\return pointer to the previously set callback"]
    pub fn GX_SetTexRegionCallback(cb: GXTexRegionCallback) -> GXTexRegionCallback;
}
extern "C" {
    #[doc = " \\fn GXTlutRegionCallback GX_SetTlutRegionCallback(GXTlutRegionCallback cb)\n \\brief Sets the callback function called by GX_LoadTlut() to find the region into which to load the TLUT.\n\n \\details GX_LoadTexObj() will also call \\a cb to obtain the Texture Look-up Table (TLUT) region when the texture forma\n is color-index.\n\n GX_Init() calls GX_SetTlutRegionCallback() to set a default TLUT index-to-region mapping. The name for the TLUT from the texture\n object is provided as an argument to the callback. The callback should return a pointer to the \\ref GXTlutRegion for this TLUT index.\n\n \\note For a given \\a tlut_name (in the \\ref GXTlutRegionCallback struct), \\a cb must always return the same \\ref GXTlutRegion; this is because\n GX_LoadTlut() will initialize data into the \\ref GXTlutRegion which GX_LoadTexObj() will subsequently use.\n\n \\param[in] cb ptr to a function that takes a u32 TLUT name as a parameter and returns a pointer to a \\ref GXTlutRegion.\n\n \\return pointer to the previously set callback"]
    pub fn GX_SetTlutRegionCallback(cb: GXTlutRegionCallback) -> GXTlutRegionCallback;
}
extern "C" {
    #[doc = " \\fn void GX_InitLightPos(GXLightObj *lit_obj,f32 x,f32 y,f32 z)\n \\brief Sets the position of the light in the light object.\n\n \\details The GameCube graphics hardware supports local diffuse lights. The position of the light should be in the same space as a transformed\n vertex position (i.e., view space).\n\n \\note Although the hardware doesn't support parallel directional diffuse lights, it is possible to get \"almost parallel\" lights by setting\n sufficient large values to position parameters (x, y and z) which makes the light position very far away from objects to be lit and all rays\n considered almost parallel.<br><br>\n\n \\note The memory for the light object must be allocated by the application; this function does not load any hardware registers directly. To\n load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to the light object\n \\param[in] x X coordinate to place the light at\n \\param[in] y Y coordinate to place the light at\n \\param[in] z Z coordinate to place the light at\n\n \\return none"]
    pub fn GX_InitLightPos(lit_obj: *mut GXLightObj, x: f32_, y: f32_, z: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitLightColor(GXLightObj *lit_obj,GXColor col)\n \\brief Sets the color of the light in the light object.\n\n \\note The memory for the light object should be allocated by the application; this function does not load any hardware register directly.  To\n load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to the light object\n \\param[in] col color to set the light to\n\n \\return none"]
    pub fn GX_InitLightColor(lit_obj: *mut GXLightObj, col: GXColor);
}
extern "C" {
    #[doc = " \\fn void GX_InitLightDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz)\n \\brief Sets the direction of a light in the light object.\n\n \\details This direction is used when the light object is used as spotlight or a specular light (see the <i>attn_fn</i> parameter of GX_SetChanCtrl()).\n\n \\note The coordinate space of the light normal should be consistent with a vertex normal transformed by a normal matrix; i.e., it should be\n transformed to view space.<br><br>\n\n \\note This function does not set the direction of parallel directional diffuse lights. If you want parallel diffuse lights, you may put the light\n position very far from every objects to be lit. (See GX_InitLightPos() and GX_SetChanCtrl())<br><br>\n\n \\note The memory for the light object must be allocated by the application; this function does not load any hardware registers.  To load a light\n object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to the light object\n \\param[in] nx X coordinate of the light normal\n \\param[in] ny Y coordinate of the light normal\n \\param[in] nz Z coordinate of the light normal\n\n \\return none"]
    pub fn GX_InitLightDir(lit_obj: *mut GXLightObj, nx: f32_, ny: f32_, nz: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadLightObj(const GXLightObj *lit_obj,u8 lit_id)\n \\brief Loads a light object into a set of hardware registers associated with a \\ref lightid.\n\n \\details This function copies the light object data into the graphics FIFO through the CPU write-gather buffer mechanism. This guarantees that\n the light object is coherent with the CPU cache.\n\n \\note The light object must have been initialized first using the necessary GX_InitLight*() functions.<br><br>\n\n \\note Another way to load a light object is with GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to the light object to load\n \\param[in] lit_id \\ref lightid to load this light into\n\n \\return none"]
    pub fn GX_LoadLightObj(lit_obj: *const GXLightObj, lit_id: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_LoadLightObjIdx(u32 litobjidx,u8 litid)\n \\brief Instructs the GP to fetch the light object at \\a ltobjindx from an array.\n\n \\details The light object is retrieved from the array to which <tt>GX_SetArray(GX_VA_LIGHTARRAY, ...)</tt> points. Then it loads the object into\n the hardware register associated with \\ref lightid.\n\n \\note Data flows directly from the array in DRAM to the GP; therefore, the light object data may not be coherent with the CPU's cache. The\n application is responsible for storing the light object data from the CPU cache (using DCStoreRange()) before calling GX_LoadLightObjIdx().\n\n \\param[in] litobjidx index to a light object\n \\param[in] litid \\ref lightid to load this light into\n\n \\return none"]
    pub fn GX_LoadLightObjIdx(litobjidx: u32_, litid: u8_);
}
extern "C" {
    #[doc = " \\fn void GX_InitLightDistAttn(GXLightObj *lit_obj,f32 ref_dist,f32 ref_brite,u8 dist_fn)\n \\brief Sets coefficients for distance attenuation in a light object.\n\n \\details This function uses three easy-to-control parameters instead of <i>k0</i>, <i>k1</i>, and <i>k2</i> in GX_InitLightAttn().\n\n In this function, you can specify the brightness on an assumed reference point. The parameter \\a ref_distance is distance between the light\n and the reference point. The parameter \\a ref_brite specifies ratio of the brightness on the reference point. The value for \\a ref_dist should\n be greater than 0 and that for \\a ref_brite should be within 0 < \\a ref_brite < 1, otherwise distance attenuation feature is turned off. The\n parameter \\a dist_fn defines type of the brightness decreasing curve by distance; <tt>GX_DA_OFF</tt> turns distance attenuation feature off.\n\n \\note If you want more flexible control, it is better to use GX_InitLightAttn() and calculate appropriate coefficients.<br><br>\n\n \\note This function sets parameters only for distance attenuation. Parameters for angular attenuation should be set by using\n GX_InitLightSpot() or GX_InitLightAttnA().<br><br>\n\n \\note This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or\n GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] ref_dist distance between the light and reference point\n \\param[in] ref_brite brightness of the reference point\n \\param[in] dist_fn \\ref distattnfn to use\n\n \\return none"]
    pub fn GX_InitLightDistAttn(
        lit_obj: *mut GXLightObj,
        ref_dist: f32_,
        ref_brite: f32_,
        dist_fn: u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitLightAttn(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2,f32 k0,f32 k1,f32 k2)\n \\brief Sts coefficients used in the lighting attenuation calculation in a given light object.\n\n \\details The parameters \\a a0, \\a a1, and \\a a2 are used for angular (spotlight) attenuation. The coefficients \\a k0, \\a k1, and \\a k2 are used for\n distance attenuation. The attenuation function is:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>atten</i> = <i>clamp0</i>(\\a a2^2 * <i>aattn</i>^2 + \\a a1 * <i>aattn</i> + \\a a0) / (\\a k2 * <i>d</i>^2 + \\a k1  * <i>d</i> + \\a k0)\n\n where <i>aattn</i> is the cosine of the angle between the light direction and the vector from the light position to the vertex, and <i>d</i> is\n the distance from the light position to the vertex when the channel attenuation function is <tt>GX_AF_SPOT</tt>. The light color will be\n multiplied by the <i>atten</i> factor when the attenuation function for the color channel referencing this light is set to <tt>GX_AF_SPOT</tt>\n (see GX_SetChanCtrl()).\n\n \\note The convenience function GX_InitLightSpot() can be used to set the angle attenuation coefficents based on several spot light\n types. The convenience function GX_InitLightDistAttn() can be used to set the distance attenuation coefficients using one of several\n common attenuation functions.<br><br>\n\n \\note The convenience macro GX_InitLightShininess() can be used to set the attenuation parameters for specular lights.<br><br>\n\n \\note When the channel attenuation function is set to <tt>GX_AF_SPEC</tt>, the <i>aattn</i> and <i>d</i> parameter are equal to the dot product of the\n eye-space vertex normal and the half-angle vector set by GX_InitSpecularDir().<br><br>\n\n \\note This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj()\n or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] a0 angle attenuation coefficient\n \\param[in] a1 angle attenuation coefficient\n \\param[in] a2 angle attenuation coefficient\n \\param[in] k0 distance attenuation coefficient\n \\param[in] k1 distance attenuation coefficient\n \\param[in] k2 distance attenuation coefficient\n\n \\return none"]
    pub fn GX_InitLightAttn(
        lit_obj: *mut GXLightObj,
        a0: f32_,
        a1: f32_,
        a2: f32_,
        k0: f32_,
        k1: f32_,
        k2: f32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitLightAttnA(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2)\n \\brief Sets coefficients used in the lighting angle attenuation calculation in a given light object.\n\n \\details The parameters \\a a0, \\a a1, and \\a a2 are used for angular (spotlight) attenuation. The attenuation\n function is:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>atten</i> = <i>clamp0</i>(\\a a2^2 * <i>cos(theta)</i>^2 + \\a a1 * <i>cos(theta)</i> + \\a a0) / (\\a k2 * <i>d</i>^2 + \\a k1  * <i>d</i> + \\a k0)\n\n where <i>cos(theta)</i> is the cosine of the angle between the light normal and the vector from the light position to the vertex, and <i>d</i> is the distance\n from the light position to the vertex. The \\a k0-\\a 2 coefficients can be set using GX_InitLightAttnK(). You can set both the \\a a0-\\a 2 and \\a k0-\\a 2 coefficients\n can be set using GX_InitLightAttn(). The light color will be multiplied by the <i>atten</i> factor when the attenuation function for the color channel\n referencing this light is set to <tt>GX_AF_SPOT</tt> (see GX_SetChanCtrl()).\n\n \\note The convenience function GX_InitLightSpot() can be used to set the angle attenuation coefficents based on several spot light types. The\n convenience function GX_InitLightDistAttn() can be used to set the distance attenuation coefficients using one of several common attenuation functions.<br><br>\n\n \\note This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] a0 angle attenuation coefficient\n \\param[in] a1 angle attenuation coefficient\n \\param[in] a2 angle attenuation coefficient\n\n \\return none"]
    pub fn GX_InitLightAttnA(lit_obj: *mut GXLightObj, a0: f32_, a1: f32_, a2: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitLightAttnK(GXLightObj *lit_obj,f32 k0,f32 k1,f32 k2)\n \\brief Sets coefficients used in the lighting distance attenuation calculation in a given light object.\n\n \\details The coefficients \\a k0, \\a k1, and \\a k2 are used for distance attenuation. The attenuation function is:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>atten</i> = <i>clamp0</i>(\\a a2^2 * <i>cos(theta)</i>^2 + \\a a1 * <i>cos(theta)</i> + \\a a0) / (\\a k2 * <i>d</i>^2 + \\a k1  * <i>d</i> + \\a k0)\n\n where <i>cos(theta)</i> is the cosine of the angle between the light normal and the vector from the light position to the vertex, and <i>d</i> is the distance\n from the light position to the vertex. The \\a a0-\\a 2 coefficients can be set using GX_InitLightAttnA(). You can set both the \\a a0-\\a 2 and \\a k0-\\a 2 coefficients\n can be set using GX_InitLightAttn(). The light color will be multiplied by the <i>atten</i> factor when the attenuation function for the color channel\n referencing this light is set to <tt>GX_AF_SPOT</tt> (see GX_SetChanCtrl()).\n\n \\note The convenience function GX_InitLightSpot() can be used to set the angle attenuation coefficents based on several spot light types. The convenience\n function GX_InitLightDistAttn() can be used to set the distance attenuation coefficients using one of several common attenuation functions.<br><br>\n\n \\note Note that this function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or\n GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] k0 distance attenuation coefficient\n \\param[in] k1 distance attenuation coefficient\n \\param[in] k2 distance attenuation coefficient\n\n \\return none"]
    pub fn GX_InitLightAttnK(lit_obj: *mut GXLightObj, k0: f32_, k1: f32_, k2: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitSpecularDirHA(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz,f32 hx,f32 hy,f32 hz)\n \\brief Sets the direction and half-angle vector of a specular light in the light object.\n\n \\details These vectors are used when the light object is used only as specular light. In contrast to GX_InitSpecularDir(),\n which caclulates half-angle vector automatically by assuming the view vector as (0, 0, 1), this function allows users to\n specify half-angle vector directly as input arguments. It is useful to do detailed control for orientation of highlights.\n\n \\note This function does not load any hardware registers. To load a light object into a hardware light, use GX_LoadLightObj()\n or GX_LoadLightObjIdx().<br><br>\n\n \\note Other notes are similar to those described in GX_InitSpecularDir().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] nx X coordinate of the light normal\n \\param[in] ny Y coordinate of the light normal\n \\param[in] nz Z coordinate of the light normal\n \\param[in] hx X coordinate of half-angle\n \\param[in] hy Y coordinate of half-angle\n \\param[in] hz Z coordinate of half-angle\n\n \\return none"]
    pub fn GX_InitSpecularDirHA(
        lit_obj: *mut GXLightObj,
        nx: f32_,
        ny: f32_,
        nz: f32_,
        hx: f32_,
        hy: f32_,
        hz: f32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_InitSpecularDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz)\n \\brief Sets the direction of a specular light in the light object.\n\n \\details This direction is used when the light object is used only as specular light. The coordinate space of the light normal\n should be consistent with a vertex normal transformed by a normal matrix; i.e., it should be transformed to view space.\n\n \\note This function should be used if and only if the light object is used as specular light. One specifies a specular light in\n GX_SetChanCtrl() by setting the \\ref attenfunc to <tt>GX_AF_SPEC</tt>. Furthermore, one must not use GX_InitLightDir() or\n GX_InitLightPos() to set up a light object which will be used as a specular light since these functions will destroy the information\n set by GX_InitSpecularDir(). In contrast to diffuse lights (including spotlights) that are considered local lights, a specular light\n is a parallel light (i.e. the specular light is infinitely far away such that all the rays of the light are parallel), and thus one\n can only specify directional information.\n\n \\note This function does not load any hardware registers. To load a light object into a hardware light, use GX_LoadLightObj()\n or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] nx X coordinate of the light normal\n \\param[in] ny Y coordinate of the light normal\n \\param[in] nz Z coordinate of the light normal\n\n \\return none"]
    pub fn GX_InitSpecularDir(lit_obj: *mut GXLightObj, nx: f32_, ny: f32_, nz: f32_);
}
extern "C" {
    #[doc = " \\fn void GX_InitLightSpot(GXLightObj *lit_obj,f32 cut_off,u8 spotfn)\n \\brief Sets coefficients for angular (spotlight) attenuation in light object.\n\n \\details This function uses two easy-to-control parameters instead of \\a a0, \\a a1, and \\a a2 on GX_InitLightAttn().\n\n \\details The parameter \\a cut_off specifies cutoff angle of the spotlight by degree. The spotlight works while the angle between the ray for a vertex and\n the light direction given by GX_InitLightDir() is smaller than this cutoff angle. The value for \\a cut_off should be within 0 < \\a cut_off <= 90.0, otherwise\n given light object doesn't become a spotlight.\n\n The parameter \\a spotfn defines type of the illumination distribution within cutoff angle. The value <tt>GX_SP_OFF</tt> turns spotlight feature off even if\n color channel setting is using <tt>GX_AF_SPOT</tt> (see GX_SetChanCtrl()).\n\n \\note This function can generate only some kind of simple spotlights. If you want more flexible control, it is better to use GX_InitLightAttn() and calculate\n appropriate coefficients.<br><br>\n\n \\note This function sets parameters only for angular attenuation. Parameters for distance attenuation should be set by using GX_InitLightDistAttn() or\n GX_InitLightAttnK().<br><br>\n\n \\note This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n \\param[in] lit_obj ptr to a light object\n \\param[in] cut_off cutoff angle of the spotlight, in degrees\n \\param[in] spotfn \\ref spotfn to use for this light\n\n \\return none"]
    pub fn GX_InitLightSpot(lit_obj: *mut GXLightObj, cut_off: f32_, spotfn: u8_);
}
extern "C" {
    pub fn GX_ReadClksPerVtx() -> u32_;
}
extern "C" {
    pub fn GX_GetOverflowCount() -> u32_;
}
extern "C" {
    pub fn GX_ResetOverflowCount() -> u32_;
}
extern "C" {
    #[doc = " \\fn lwp_t GX_GetCurrentGXThread(void)\n \\brief Returns the current GX thread.\n\n \\details The current GX thread should be the thread that is currently responsible for generating graphics data. By default,\n the GX thread is the thread that invoked GX_Init(); however, it may be changed by calling GX_SetCurrentGXThread().\n\n \\note When graphics data is being generated in immediate mode (that is, the CPU FIFO = GP FIFO, and the GP is actively consuming\n data), the high watermark may be triggered. When this happens, the high watermark interrupt handler will suspend the GX thread, thus\n preventing any further graphics data from being generated. The low watermark interrupt handler will resume the thread.\n\n \\return the current GX thread"]
    pub fn GX_GetCurrentGXThread() -> lwp_t;
}
extern "C" {
    #[doc = " \\fn lwp_t GX_SetCurrentGXThread(void)\n \\brief Sets the current GX thread to the calling thread.\n\n \\details The new thread should be the thread that will be responsible for generating graphics data. By default, the GX thread is\n the thread that invoked GX_Init(); however, it may be changed by calling this function.\n\n \\note It is a programming error to change GX thread while the current GX thread is suspended by a high water mark interrupt. This\n indicates that you have two threads about to generate GX data.<br><br>\n\n \\note When graphics data is being generated in immediate mode (that is, the CPU FIFO = GP FIFO, and the GP is actively consuming\n data), the high watermark may be triggered. When this happens, the high watermark interrupt handler will suspend the GX thread, thus\n preventing any further graphics data from being generated. The low watermark interrupt handler will resume the thread.\n\n \\return the previous GX thread ID"]
    pub fn GX_SetCurrentGXThread() -> lwp_t;
}
extern "C" {
    #[doc = " \\fn void GX_RestoreWriteGatherPipe(void)\n \\brief Restores the write-gather pipe.\n\n \\details The CPU fifo that was attached at the time GX_RedirectWriteGatherPipe() was called will be re-attached. If there is data pending\n in the write gather pipe (e.g. if the amount of data written was not a multiple of 32 bytes), the data will be padded with zeroes and\n flushed out.\n\n \\warning This function must be called between successive calls to GX_RedirectWriteGatherPipe().\n\n \\return none"]
    pub fn GX_RestoreWriteGatherPipe();
}
extern "C" {
    #[doc = " \\fn void GX_SetGPMetric(u32 perf0,u32 perf1)\n \\brief Sets two performance metrics to measure in the GP.\n\n \\details perf0 and perf1 are set to measure. The initial metrics measured are <tt>GX_PERF0_NONE</tt> and <tt>GX_PERF1_NONE</tt>, which return counts of zero\n for the first call to GX_ReadGPMetric().\n\n Each performance counter has a unique set of events or ratios that it can count. In some cases the same metric can be counted using both\n counters, for example <tt>GX_PERF0_VERTICES</tt> and <tt>GX_PERF1_VERTICES</tt>. Ratios (the metric name ends in <tt>_RATIO</tt>) are multiplied by\n 1000 (1000 = all misses/clips, etc., 0 = no misses/clips, etc.).\n\n \\note GX_ReadGPMetric() and GX_ClearGPMetric() can be used in the callback associated with the draw sync interrupt (see GX_SetDrawSyncCallback()).\n This function should not be used in the draw sync callback because it will insert tokens in the GP command stream at random times.\n\n \\warning This function reads results from CPU-accessible registers in the GP, therefore, this command <i>must not</i> be used in a display list. In\n addition, the performance counters in some cases are triggered by sending tokens through the Graphics FIFO to the GP.  This implies that\n the function should only be used in immediate mode (when the Graphics FIFO is connected to the CPU and the GP at the same time).  It may\n also be necessary to send a draw sync token using GX_SetDrawSync() or call GX_SetDrawDone() after GX_ReadGPMetric() to ensure that the\n state has actually been processed by the GP.\n\n \\param[in] perf0 \\ref perf0metrics to measure\n \\param[in] perf1 \\ref perf1metrics to measure\n\n \\returns none"]
    pub fn GX_SetGPMetric(perf0: u32_, perf1: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_ClearGPMetric(void)\n \\brief Clears the two virtual GP performance counters to zero.\n\n \\note The counter's function is set using GX_SetGPMetric(); the counter's value is read using GX_ReadGPMetric(). Consult these for more details.\n\n \\warning This function resets CPU accessible counters, so it should <b>not</b> be used in a display list.\n\n \\return none"]
    pub fn GX_ClearGPMetric();
}
extern "C" {
    #[doc = " \\fn void GX_InitXfRasMetric(void)\n \\brief Initialize the transformation unit (XF) rasterizer unit (RAS) to take performance measurements.\n\n \\warning This function should be avoided; use the GP performance metric functions instead.\n\n \\return none"]
    pub fn GX_InitXfRasMetric();
}
extern "C" {
    #[doc = " \\fn void GX_ReadXfRasMetric(u32 *xfwaitin,u32 *xfwaitout,u32 *rasbusy,u32 *clks)\n \\brief Read performance metric values from the XF and RAS units.\n\n \\warning This function should be avoided; use the GP performance metric functions instead.<br><br>\n\n \\warning The parameters for this function are a best guess based on names and existing code.\n\n \\param[out] xfwaitin Number of clocks the XF has waited for data to arrive?\n \\param[out] xfwaitout Number of clocks the XF has waited to push finished data down?\n \\param[out] rasbusy Number of clocks the RAS has spent being busy?\n \\param[out] clks Clocks that have passed since last count reset?\n\n \\return none"]
    pub fn GX_ReadXfRasMetric(
        xfwaitin: *mut u32_,
        xfwaitout: *mut u32_,
        rasbusy: *mut u32_,
        clks: *mut u32_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_ClearVCacheMetric(void)\n \\brief Clears the Vertex Cache performance counter.\n\n \\details This function clears the performance counter by sending a special clear token via the Graphics FIFO.\n\n \\note To set the metric for the counter, call GX_SetVCacheMetric(); to read the counter value, call GX_ReadVCacheMetric().\n\n \\return none"]
    pub fn GX_ClearVCacheMetric();
}
extern "C" {
    #[doc = " \\fn void GX_ReadVCacheMetric(u32 *check,u32 *miss,u32 *stall)\n \\brief Returns Vertex Cache performance counters.\n\n \\details Each call to this function resets the counter to zero. GX_SetVCacheMetric() sets the metric to be measured by\n the Vertex Cache performance counter.\n\n \\warning This function reads CPU-accessible registers in the GP and so should not be called in a display list.\n\n \\param[out] check total number of accesses to the vertex cache\n \\param[out] miss total number of cache misses to the vertex cache\n \\param[out] stall number of GP clocks that the vertex cache was stalled\n\n \\return none"]
    pub fn GX_ReadVCacheMetric(check: *mut u32_, miss: *mut u32_, stall: *mut u32_);
}
extern "C" {
    #[doc = " \\fn void GX_SetVCacheMetric(u32 attr)\n \\brief Sets the metric the Vertex Cache performance counter will measure.\n\n \\details It is possible to monitor a particular attribute or all attributes using \\a attr.\n\n \\note To clear the counter, call GX_ClearVCacheMetric(); to read the counter value, call GX_ReadVCacheMetric().\n\n \\param[in] attr \\ref vcachemetrics to measure\n\n \\return none"]
    pub fn GX_SetVCacheMetric(attr: u32_);
}
extern "C" {
    #[doc = " \\fn void GX_GetGPStatus(u8 *overhi,u8 *underlow,u8 *readIdle,u8 *cmdIdle,u8 *brkpt)\n \\brief Reads the current status of the GP.\n\n \\details \\a overhi and \\a underlow will indicate whether or not the watermarks have been reached. If the CPU and GP FIFOs\n are the same, then \\a overhi will indicate whether or not the current GX thread is suspended. The value of \\a brkpt can be\n used to determine if a breakpoint is in progress (i.e. GP reads are suspended; they are resumed by a call to\n GX_DisableBreakPt()). A callback can also be used to notify your application that the break point has been reached. (see\n GX_SetBreakPtCallback())\n\n \\param[out] overhi <tt>GX_TRUE</tt> if high watermark has been passed\n \\param[out] underlow <tt>GX_TRUE</tt> if low watermark has been passed\n \\param[out] readIdle <tt>GX_TRUE</tt> if the GP read unit is idle\n \\param[out] cmdIdle <tt>GX_TRUE</tt> if all commands have been flushed to XF\n \\param[out] brkpt <tt>GX_TRUE</tt> if FIFO has reached a breakpoint and GP reads have been stopped\n\n \\return none"]
    pub fn GX_GetGPStatus(
        overhi: *mut u8_,
        underlow: *mut u8_,
        readIdle: *mut u8_,
        cmdIdle: *mut u8_,
        brkpt: *mut u8_,
    );
}
extern "C" {
    #[doc = " \\fn void GX_ReadGPMetric(u32 *cnt0,u32 *cnt1)\n \\brief Returns the count of the previously set performance metrics.\n\n \\note The performance metrics can be set using GX_SetGPMetric(); the counters can be cleared using GX_ClearGPMetric().<br><br>\n\n \\note GX_ReadGPMetric() and GX_ClearGPMetric() can be used in the callback associated with the draw sync interrupt (see GX_SetDrawSyncCallback()).\n The function GX_SetGPMetric() should <b>not</b> be used in the draw sync callback because it will insert tokens in the GP command stream at random times.<br><br>\n\n \\warning This function reads results from CPU-accessible registers in the GP, therefore, this command <i>must not</i> be used in a display list. It\n may also be necessary to send a draw sync token using GX_SetDrawSync() or GX_SetDrawDone() before GX_ReadGPMetric() is called to ensure that the\n state has actually been processed by the GP.\n\n \\param[out] cnt0 current value of GP counter 0\n \\param[out] cnt1 current value of GP counter 1\n\n \\return none"]
    pub fn GX_ReadGPMetric(cnt0: *mut u32_, cnt1: *mut u32_);
}
extern "C" {
    #[doc = " \\fn void GX_ReadBoundingBox(u16 *top,u16 *bottom,u16 *left,u16 *right)\n \\brief Returns the bounding box of pixel coordinates that are drawn in the Embedded Framebuffer (EFB).\n\n \\details This function reads the bounding box values. GX_ClearBoundingBox() can be used reset the values of the bounding box.\n\n \\note Since the hardware can only test the bounding box in quads (2x2 pixel blocks), the result of this function may contain error\n of plus or minus 1 pixel. Also because of this, <b>left</b> and <b>top</b> are always even-numbered and <b>right</b> and <b>bottom</b>\n are always odd-numbered.\n\n \\param[out] top uppermost line in the bounding box\n \\param[out] bottom lowest line in the bounding box\n \\param[out] left leftmost pixel in the bounding box\n \\param[out] right rightmost pixel in the bounding box\n\n \\return none"]
    pub fn GX_ReadBoundingBox(top: *mut u16_, bottom: *mut u16_, left: *mut u16_, right: *mut u16_);
}
extern "C" {
    #[doc = " \\fn volatile void* GX_RedirectWriteGatherPipe(void *ptr)\n \\brief Temporarily points the CPU's write-gather pipe at a new location.\n\n \\details After calling this function, subsequent writes to the address returned by this function (or the WGPipe union)\n will be gathered and sent to a destination buffer. The write pointer is automatically incremented by the GP.  The write\n gather pipe can be restored by calling GX_RestoreWriteGatherPipe(). This function cannot be called between a\n GX_Begin()/GX_End() pair.\n\n \\note The destination buffer, referred to by \\a ptr, must be 32 byte aligned. The amount of data written should\n also be 32-byte aligned. If it is not, zeroes will be added to pad the destination buffer to 32 bytes. No part of the\n destination buffer should be modified inside the CPU caches - this may introduce cache incoherency problems.<br><br>\n\n \\note The write gather pipe is one of the fastest ways to move data out of the CPU (the other being the locked cache DMA).\n In general, you are compute-bound when sending data from the CPU.<br><br>\n\n \\note This function is cheaper than trying to create a fake CPU fifo around a destination buffer, which requires calls to\n GX_SetCPUFifo(), GX_InitFifoBase(), etc. This function performs very light weight state saves by assuming that the CPU and\n GP FIFOs never change.\n\n \\warning <b>No GX commands can be called until the write gather pipe is restored. You MUST call\n GX_RestoreWriteGatherPipe() before calling this function again, or else the final call to restore the pipe will fail.</b>\n\n \\param[in] ptr to destination buffer, 32-byte aligned\n\n \\return real address of the write-gather \"port\". All writes to this address will be gathered by the CPU write gather pipe.\n You may also use the WGPipe union. If you do not use the WGPipe union, ensure that your local variable is volatile."]
    pub fn GX_RedirectWriteGatherPipe(ptr: *mut ::libc::c_void) -> *mut ::libc::c_void;
}
pub type SICallback = ::core::option::Option<unsafe extern "C" fn(arg1: s32, arg2: u32_)>;
pub type RDSTHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32_, arg2: *mut ::libc::c_void)>;
extern "C" {
    pub fn SI_Sync() -> u32_;
}
extern "C" {
    pub fn SI_Busy() -> u32_;
}
extern "C" {
    pub fn SI_IsChanBusy(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_SetXY(line: u16_, cnt: u8_);
}
extern "C" {
    pub fn SI_EnablePolling(poll: u32_);
}
extern "C" {
    pub fn SI_DisablePolling(poll: u32_);
}
extern "C" {
    pub fn SI_SetCommand(chan: s32, cmd: u32_);
}
extern "C" {
    pub fn SI_GetStatus(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_GetResponse(chan: s32, buf: *mut ::libc::c_void) -> u32_;
}
extern "C" {
    pub fn SI_GetResponseRaw(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_SetSamplingRate(samplingrate: u32_);
}
extern "C" {
    pub fn SI_RefreshSamplingRate();
}
extern "C" {
    pub fn SI_Transfer(
        chan: s32,
        out: *mut ::libc::c_void,
        out_len: u32_,
        in_: *mut ::libc::c_void,
        in_len: u32_,
        cb: SICallback,
        us_delay: u32_,
    ) -> u32_;
}
extern "C" {
    pub fn SI_DecodeType(type_: u32_) -> u32_;
}
extern "C" {
    pub fn SI_GetTypeAsync(chan: s32, cb: SICallback) -> u32_;
}
extern "C" {
    pub fn SI_GetType(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_Probe(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_GetCommand(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_TransferCommands();
}
extern "C" {
    pub fn SI_RegisterPollingHandler(handler: RDSTHandler) -> u32_;
}
extern "C" {
    pub fn SI_UnregisterPollingHandler(handler: RDSTHandler) -> u32_;
}
extern "C" {
    pub fn SI_EnablePollingInterrupt(enable: s32) -> u32_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _excption_frame {
    pub EXCPT_Number: u32_,
    pub SRR0: u32_,
    pub SRR1: u32_,
    pub GPR: [u32_; 32usize],
    pub GQR: [u32_; 8usize],
    pub CR: u32_,
    pub LR: u32_,
    pub CTR: u32_,
    pub XER: u32_,
    pub MSR: u32_,
    pub DAR: u32_,
    pub state: u16_,
    pub mode: u16_,
    pub FPR: [f64_; 32usize],
    pub FPSCR: u64_,
    pub PSFPR: [f64_; 32usize],
}
pub type frame_context = _excption_frame;
#[doc = " \\typedef void (*raw_irq_handler_t)(u32 irq,void *ctx)\n\\brief function pointer typedef for the interrupt handler callback\n\\param[in] irq interrupt number of triggered interrupt.\n\\param[in] ctx pointer to the user data."]
pub type raw_irq_handler_t =
    ::core::option::Option<unsafe extern "C" fn(irq: u32_, ctx: *mut ::libc::c_void)>;
extern "C" {
    #[doc = " \\fn raw_irq_handler_t IRQ_Request(u32 nIrq,raw_irq_handler_t pHndl,void *pCtx)\n\\brief Register an interrupt handler.\n\\param[in] nIrq interrupt number to which to register the handler\n\\param[in] pHndl pointer to the handler callback function which to call when interrupt has triggered\n\\param[in] pCtx pointer to user data to pass with, when handler is called\n\n\\return Old interrupt handler, else NULL"]
    pub fn IRQ_Request(
        nIrq: u32_,
        pHndl: raw_irq_handler_t,
        pCtx: *mut ::libc::c_void,
    ) -> raw_irq_handler_t;
}
extern "C" {
    #[doc = " \\fn raw_irq_handler_t IRQ_Free(u32 nIrq)\n\\brief Free an interrupt handler.\n\\param[in] nIrq interrupt number for which to free the handler\n\n\\return Old interrupt handler, else NULL"]
    pub fn IRQ_Free(nIrq: u32_) -> raw_irq_handler_t;
}
extern "C" {
    #[doc = " \\fn raw_irq_handler_t IRQ_GetHandler(u32 nIrq)\n\\brief Get the handler from interrupt number\n\\param[in] nIrq interrupt number for which to retrieve the handler\n\n\\return interrupt handler, else NULL"]
    pub fn IRQ_GetHandler(nIrq: u32_) -> raw_irq_handler_t;
}
extern "C" {
    #[doc = " \\fn u32 IRQ_Disable()\n\\brief Disable the complete IRQ subsystem. No interrupts will be served. Multithreading kernel fully disabled.\n\n\\return Old state of the IRQ subsystem"]
    pub fn IRQ_Disable() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 IRQ_Restore(u32 level)\n\\brief Restore the IRQ subsystem with the given level. This is function should be used together with IRQ_Disable()\n\\param[in] level IRQ level to restore to.\n\n\\return none"]
    pub fn IRQ_Restore(level: u32_);
}
extern "C" {
    pub fn __MaskIrq(nMask: u32_);
}
extern "C" {
    pub fn __UnmaskIrq(nMask: u32_);
}
#[doc = " \\typedef u32 mutex_t\n\\brief typedef for the mutex handle"]
pub type mutex_t = u32_;
extern "C" {
    #[doc = " \\fn s32 LWP_MutexInit(mutex_t *mutex,bool use_recursive)\n\\brief Initializes a mutex lock.\n\\param[out] mutex pointer to a mutex_t handle.\n\\param[in] use_recursive whether to allow the thread, whithin the same context, to enter multiple times the lock or not.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_MutexInit(mutex: *mut mutex_t, use_recursive: bool) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_MutexDestroy(mutex_t mutex)\n\\brief Close mutex lock, release all threads and handles locked on this mutex.\n\\param[in] mutex handle to the mutex_t structure.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_MutexDestroy(mutex: mutex_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_MutexLock(mutex_t mutex)\n\\brief Enter the mutex lock.\n\\param[in] mutex handle to the mutext_t structure.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_MutexLock(mutex: mutex_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_MutexTryLock(mutex_t mutex)\n\\brief Try to enter the mutex lock.\n\\param[in] mutex handle to the mutex_t structure.\n\n\\return 0: on first aquire, 1: would lock"]
    pub fn LWP_MutexTryLock(mutex: mutex_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_MutexUnlock(mutex_t mutex)\n\\brief Release the mutex lock and let other threads process further on this mutex.\n\\param[in] mutex handle to the mutex_t structure.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_MutexUnlock(mutex: mutex_t) -> s32;
}
#[doc = " \\typedef u32 mqbox_t\n\\brief typedef for the message queue handle"]
pub type mqbox_t = u32_;
#[doc = " \\typedef void* mqmsg_t\n\\brief typedef for the message pointer"]
pub type mqmsg_t = *mut ::libc::c_void;
extern "C" {
    #[doc = " \\fn u32 MQ_Init(mqbox_t *mqbox,u32 count)\n\\brief Initializes a message queue\n\\param[out] mqbox pointer to the mqbox_t handle.\n\\param[in] count maximum number of messages the queue can hold\n\n\\return 0 on success, <0 on error"]
    pub fn MQ_Init(mqbox: *mut mqbox_t, count: u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn void MQ_Close(mqbox_t mqbox)\n\\brief Closes the message queue and releases all memory.\n\\param[in] mqbox handle to the mqbox_t structure.\n\n\\return none"]
    pub fn MQ_Close(mqbox: mqbox_t);
}
extern "C" {
    #[doc = " \\fn BOOL MQ_Send(mqbox_t mqbox,mqmsg_t msg,u32 flags)\n\\brief Sends a message to the given message queue.\n\\param[in] mqbox mqbox_t handle to the message queue\n\\param[in] msg message to send\n\\param[in] flags message flags (MQ_MSG_BLOCK, MQ_MSG_NOBLOCK)\n\n\\return bool result"]
    pub fn MQ_Send(mqbox: mqbox_t, msg: mqmsg_t, flags: u32_) -> BOOL;
}
extern "C" {
    #[doc = " \\fn BOOL MQ_Jam(mqbox_t mqbox,mqmsg_t msg,u32 flags)\n\\brief Sends a message to the given message queue and jams it in front of the queue.\n\\param[in] mqbox mqbox_t handle to the message queue\n\\param[in] msg message to send\n\\param[in] flags message flags (MQ_MSG_BLOCK, MQ_MSG_NOBLOCK)\n\n\\return bool result"]
    pub fn MQ_Jam(mqbox: mqbox_t, msg: mqmsg_t, flags: u32_) -> BOOL;
}
extern "C" {
    #[doc = " \\fn BOOL MQ_Receive(mqbox_t mqbox,mqmsg_t *msg,u32 flags)\n\\brief Sends a message to the given message queue.\n\\param[in] mqbox mqbox_t handle to the message queue\n\\param[in] msg pointer to a mqmsg_t_t-type message to receive.\n\\param[in] flags message flags (MQ_MSG_BLOCK, MQ_MSG_NOBLOCK)\n\n\\return bool result"]
    pub fn MQ_Receive(mqbox: mqbox_t, msg: *mut mqmsg_t, flags: u32_) -> BOOL;
}
#[doc = " \\typedef u32 sem_t\n\\brief typedef for the semaphore handle"]
pub type sem_t = u32_;
extern "C" {
    #[doc = " \\fn s32 LWP_SemInit(sem_t *sem,u32 start,u32 max)\n\\brief Initializes a semaphore.\n\\param[out] sem pointer to a sem_t handle.\n\\param[in] start start count of the semaphore\n\\param[in] max maximum count of the semaphore\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_SemInit(sem: *mut sem_t, start: u32_, max: u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_SemDestroy(sem_t sem)\n\\brief Close and destroy a semaphore, release all threads and handles locked on this semaphore.\n\\param[in] sem handle to the sem_t structure.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_SemDestroy(sem: sem_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_SemWait(sem_t sem)\n\\brief Count down semaphore counter and enter lock if counter <=0\n\\param[in] sem handle to the sem_t structure.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_SemWait(sem: sem_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_SemGetValue(sem_t sem, u32* value)\n\\brief return the current semaphore count\n\\param[in] sem handle to the sem_t structure.\n\\param[out] the current value of the semaphore\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_SemGetValue(sem: sem_t, value: *mut u32_) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 LWP_SemPost(sem_t sem)\n\\brief Count up semaphore counter and release lock if counter >0\n\\param[in] sem handle to the sem_t structure.\n\n\\return 0 on success, <0 on error"]
    pub fn LWP_SemPost(sem: sem_t) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _padstatus {
    pub button: u16_,
    pub stickX: s8,
    pub stickY: s8,
    pub substickX: s8,
    pub substickY: s8,
    pub triggerL: u8_,
    pub triggerR: u8_,
    pub analogA: u8_,
    pub analogB: u8_,
    pub err: s8,
}
pub type PADStatus = _padstatus;
pub type sampling_callback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn PAD_Init() -> u32_;
}
extern "C" {
    pub fn PAD_Sync() -> u32_;
}
extern "C" {
    pub fn PAD_Read(status: *mut PADStatus) -> u32_;
}
extern "C" {
    pub fn PAD_Reset(mask: u32_) -> u32_;
}
extern "C" {
    pub fn PAD_Recalibrate(mask: u32_) -> u32_;
}
extern "C" {
    pub fn PAD_Clamp(status: *mut PADStatus);
}
extern "C" {
    pub fn PAD_ControlMotor(chan: s32, cmd: u32_);
}
extern "C" {
    pub fn PAD_SetSpec(spec: u32_);
}
extern "C" {
    pub fn PAD_ScanPads() -> u32_;
}
extern "C" {
    pub fn PAD_ButtonsUp(pad: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn PAD_ButtonsDown(pad: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn PAD_ButtonsHeld(pad: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn PAD_SubStickX(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_SubStickY(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_StickX(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_StickY(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_TriggerL(pad: ::libc::c_int) -> u8_;
}
extern "C" {
    pub fn PAD_TriggerR(pad: ::libc::c_int) -> u8_;
}
extern "C" {
    pub fn PAD_SetSamplingCallback(cb: sampling_callback) -> sampling_callback;
}
pub type FHANDLE = *mut ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tplfile {
    pub type_: ::libc::c_int,
    pub ntextures: ::libc::c_int,
    pub texdesc: *mut ::libc::c_void,
    pub tpl_file: FHANDLE,
}
pub type TPLFile = _tplfile;
extern "C" {
    pub fn TPL_OpenTPLFromFile(tdf: *mut TPLFile, file_name: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn TPL_OpenTPLFromMemory(tdf: *mut TPLFile, memory: *mut ::libc::c_void, len: u32_) -> s32;
}
extern "C" {
    pub fn TPL_GetTexture(tdf: *mut TPLFile, id: s32, texObj: *mut GXTexObj) -> s32;
}
extern "C" {
    pub fn TPL_GetTextureCI(
        tdf: *mut TPLFile,
        id: s32,
        texObj: *mut GXTexObj,
        tlutObj: *mut GXTlutObj,
        tluts: u8_,
    ) -> s32;
}
extern "C" {
    pub fn TPL_GetTextureInfo(
        tdf: *mut TPLFile,
        id: s32,
        fmt: *mut u32_,
        width: *mut u16_,
        height: *mut u16_,
    ) -> s32;
}
extern "C" {
    pub fn TPL_CloseTPLFile(tdf: *mut TPLFile);
}
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
pub type wint_t = ::libc::c_int;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_ulong;
pub type _ssize_t = ::libc::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<wint_t>,
    pub __wchb: __BindgenUnionField<[::libc::c_uchar; 4usize]>,
    pub bindgen_union_field: u32,
}
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::libc::c_ulong;
pub type __daddr_t = ::libc::c_long;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::libc::c_int;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::libc::c_ulong;
pub type _LOCK_T = ::libc::c_int;
pub type _LOCK_RECURSIVE_T = ::libc::c_int;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1 {
    pub _reent: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 25usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::libc::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::libc::c_int;
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::libc::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::libc::c_int,
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub contentionscope: ::libc::c_int,
    pub inheritsched: ::libc::c_int,
    pub schedpolicy: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::libc::c_int,
    pub recursive: ::libc::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::libc::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::libc::c_int,
    pub init_executed: ::libc::c_int,
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::libc::c_long;
}
extern "C" {
    pub static mut _daylight: ::libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::libc::c_char; 2usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::libc::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::libc::c_void>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: sigval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_value: sigval,
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: usize,
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::libc::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::libc::c_int, arg3: sigval) -> ::libc::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::libc::c_int, arg2: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn str2sig(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
pub type sig_atomic_t = ::libc::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn signal(arg1: ::libc::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::libc::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::libc::c_int;
}
#[doc = " \\typedef u32 syswd_t\n \\brief handle typedef for the alarm context"]
pub type syswd_t = u32_;
#[doc = " \\typedef struct _syssram syssram\n \\brief holds the stored configuration value from the system SRAM area\n \\param checksum holds the block checksum.\n \\param checksum_in holds the inverse block checksum\n \\param ead0 unknown attribute\n \\param ead1 unknown attribute\n \\param counter_bias bias value for the realtime clock\n \\param display_offsetH pixel offset for the VI\n \\param ntd mostly unknown attribute\n \\param lang language of system\n \\param flags device and operations flag"]
pub type syssram = _syssram;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _syssram {
    pub checksum: u16_,
    pub checksum_inv: u16_,
    pub ead0: u32_,
    pub ead1: u32_,
    pub counter_bias: u32_,
    pub display_offsetH: s8,
    pub ntd: u8_,
    pub lang: u8_,
    pub flags: u8_,
}
#[doc = " \\typedef struct _syssramex syssramex\n \\brief holds the stored configuration value from the extended SRAM area\n \\param flash_id[2][12] 96bit memorycard unlock flash ID\n \\param wirelessKbd_id Device ID of last connected wireless keyboard\n \\param wirelessPad_id[4] 16bit device ID of last connected pad.\n \\param dvderr_code last non-recoverable error from DVD interface\n \\param __padding0 padding\n \\param flashID_chksum[2] 8bit checksum of unlock flash ID\n \\param gbs Game Boy Player Start-Up Disc settings\n \\param __padding1 padding"]
pub type syssramex = _syssramex;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _syssramex {
    pub flash_id: [[u8_; 12usize]; 2usize],
    pub wirelessKbd_id: u32_,
    pub wirelessPad_id: [u16_; 4usize],
    pub dvderr_code: u8_,
    pub __padding0: u8_,
    pub flashID_chksum: [u8_; 2usize],
    pub gbs: u16_,
    pub __padding1: u16_,
}
pub type alarmcallback =
    ::core::option::Option<unsafe extern "C" fn(alarm: syswd_t, cb_arg: *mut ::libc::c_void)>;
pub type sys_fontheader = _sys_fontheader;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sys_fontheader {
    pub font_type: u16_,
    pub first_char: u16_,
    pub last_char: u16_,
    pub inval_char: u16_,
    pub asc: u16_,
    pub desc: u16_,
    pub width: u16_,
    pub leading: u16_,
    pub cell_width: u16_,
    pub cell_height: u16_,
    pub sheet_size: u32_,
    pub sheet_format: u16_,
    pub sheet_column: u16_,
    pub sheet_row: u16_,
    pub sheet_width: u16_,
    pub sheet_height: u16_,
    pub width_table: u16_,
    pub sheet_image: u32_,
    pub sheet_fullsize: u32_,
    pub c0: u8_,
    pub c1: u8_,
    pub c2: u8_,
    pub c3: u8_,
}
pub type resetcallback =
    ::core::option::Option<unsafe extern "C" fn(irq: u32_, ctx: *mut ::libc::c_void)>;
pub type powercallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type resetfunction = ::core::option::Option<unsafe extern "C" fn(final_: s32) -> s32>;
pub type sys_resetinfo = _sys_resetinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sys_resetinfo {
    pub node: lwp_node,
    pub func: resetfunction,
    pub prio: u32_,
}
extern "C" {
    #[doc = " \\fn void SYS_Init(void)\n\\deprecated Performs basic system initialization such as EXI init etc. This function is called from within the crt0 startup code.\n\n\\return none"]
    pub fn SYS_Init();
}
extern "C" {
    #[doc = " \\fn void* SYS_AllocateFramebuffer(GXRModeObj *rmode)\n \\brief Allocate cacheline aligned memory for the external framebuffer based on the rendermode object.\n \\param[in] rmode pointer to the video/render mode configuration\n\n \\return pointer to the framebuffer's startaddress. <b><i>NOTE:</i></b> Address returned is aligned to a 32byte boundery!"]
    pub fn SYS_AllocateFramebuffer(rmode: *mut GXRModeObj) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_ProtectRange(chan: u32_, addr: *mut ::libc::c_void, bytes: u32_, cntrl: u32_);
}
extern "C" {
    pub fn SYS_StartPMC(mcr0val: u32_, mcr1val: u32_);
}
extern "C" {
    pub fn SYS_DumpPMC();
}
extern "C" {
    pub fn SYS_StopPMC();
}
extern "C" {
    pub fn SYS_ResetPMC();
}
extern "C" {
    #[doc = " \\fn s32 SYS_CreateAlarm(syswd_t *thealarm)\n\\brief Create/initialize sysalarm structure\n\\param[in] thealarm pointer to the handle to store the created alarm context identifier\n\n\\return 0 on succuess, non-zero on error"]
    pub fn SYS_CreateAlarm(thealarm: *mut syswd_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 SYS_SetAlarm(syswd_t thealarm,const struct timespec *tp,alarmcallback cb)\n\\brief Set the alarm parameters for a one-shot alarm, add to the list of alarms and start.\n\\param[in] thealarm identifier to the alarm context to be initialize for a one-shot alarm\n\\param[in] tp pointer to timespec structure holding the time to fire the alarm\n\\param[in] cb pointer to callback which is called when the alarm fires.\n\n\\return 0 on succuess, non-zero on error"]
    pub fn SYS_SetAlarm(
        thealarm: syswd_t,
        tp: *const timespec,
        cb: alarmcallback,
        cbarg: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 SYS_SetPeriodicAlarm(syswd_t thealarm,const struct timespec *tp_start,const struct timespec *tp_period,alarmcallback cb)\n\\brief Set the alarm parameters for a periodioc alarm, add to the list of alarms and start. The alarm and interval persists as long as SYS_CancelAlarm() isn't called.\n\\param[in] thealarm identifier to the alarm context to be initialized for a periodic alarm\n\\param[in] tp_start pointer to timespec structure holding the time to fire first time the alarm\n\\param[in] tp_period pointer to timespec structure holding the interval for all following alarm triggers.\n\\param[in] cb pointer to callback which is called when the alarm fires.\n\n\\return 0 on succuess, non-zero on error"]
    pub fn SYS_SetPeriodicAlarm(
        thealarm: syswd_t,
        tp_start: *const timespec,
        tp_period: *const timespec,
        cb: alarmcallback,
        cbarg: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 SYS_RemoveAlarm(syswd_t thealarm)\n\\brief Remove the given alarm context from the list of contexts and destroy it\n\\param[in] thealarm identifier to the alarm context to be removed and destroyed\n\n\\return 0 on succuess, non-zero on error"]
    pub fn SYS_RemoveAlarm(thealarm: syswd_t) -> s32;
}
extern "C" {
    #[doc = " \\fn s32 SYS_CancelAlarm(syswd_t thealarm)\n\\brief Cancel the alarm, but do not remove from the list of contexts.\n\\param[in] thealarm identifier to the alram context to be canceled\n\n\\return 0 on succuess, non-zero on error"]
    pub fn SYS_CancelAlarm(thealarm: syswd_t) -> s32;
}
extern "C" {
    pub fn SYS_STDIO_Report(use_stdout: bool);
}
extern "C" {
    #[doc = " \\fn void SYS_Report (char const *const fmt_, ...)\n\\brief write formatted string to Dolphin OSReport uart"]
    pub fn SYS_Report(fmt_: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn SYS_GetCounterBias() -> u32_;
}
extern "C" {
    pub fn SYS_SetCounterBias(bias: u32_);
}
extern "C" {
    pub fn SYS_GetDisplayOffsetH() -> s8;
}
extern "C" {
    pub fn SYS_SetDisplayOffsetH(offset: s8);
}
extern "C" {
    pub fn SYS_GetEuRGB60() -> u8_;
}
extern "C" {
    pub fn SYS_SetEuRGB60(enable: u8_);
}
extern "C" {
    pub fn SYS_GetLanguage() -> u8_;
}
extern "C" {
    pub fn SYS_SetLanguage(lang: u8_);
}
extern "C" {
    pub fn SYS_GetProgressiveScan() -> u8_;
}
extern "C" {
    pub fn SYS_SetProgressiveScan(enable: u8_);
}
extern "C" {
    pub fn SYS_GetSoundMode() -> u8_;
}
extern "C" {
    pub fn SYS_SetSoundMode(mode: u8_);
}
extern "C" {
    pub fn SYS_GetVideoMode() -> u8_;
}
extern "C" {
    pub fn SYS_SetVideoMode(mode: u8_);
}
extern "C" {
    pub fn SYS_GetWirelessID(chan: u32_) -> u16_;
}
extern "C" {
    pub fn SYS_SetWirelessID(chan: u32_, id: u16_);
}
extern "C" {
    pub fn SYS_GetGBSMode() -> u16_;
}
extern "C" {
    pub fn SYS_SetGBSMode(mode: u16_);
}
extern "C" {
    pub fn SYS_GetFontEncoding() -> u32_;
}
extern "C" {
    pub fn SYS_InitFont(font_data: *mut sys_fontheader) -> u32_;
}
extern "C" {
    pub fn SYS_GetFontTexture(
        c: s32,
        image: *mut *mut ::libc::c_void,
        xpos: *mut s32,
        ypos: *mut s32,
        width: *mut s32,
    );
}
extern "C" {
    pub fn SYS_GetFontTexel(
        c: s32,
        image: *mut ::libc::c_void,
        pos: s32,
        stride: s32,
        width: *mut s32,
    );
}
extern "C" {
    pub fn SYS_ResetSystem(reset: s32, reset_code: u32_, force_menu: s32);
}
extern "C" {
    pub fn SYS_RegisterResetFunc(info: *mut sys_resetinfo);
}
extern "C" {
    pub fn SYS_UnregisterResetFunc(info: *mut sys_resetinfo);
}
extern "C" {
    pub fn SYS_SwitchFiber(arg0: u32_, arg1: u32_, arg2: u32_, arg3: u32_, pc: u32_, newsp: u32_);
}
extern "C" {
    pub fn SYS_GetArena1Lo() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena1Lo(newLo: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena1Hi() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena1Hi(newHi: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena1Size() -> u32_;
}
extern "C" {
    pub fn SYS_SetResetCallback(cb: resetcallback) -> resetcallback;
}
extern "C" {
    pub fn SYS_ResetButtonDown() -> u32_;
}
extern "C" {
    pub fn SYS_GetHollywoodRevision() -> u32_;
}
extern "C" {
    pub fn SYS_GetArena2Lo() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena2Lo(newLo: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena2Hi() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena2Hi(newHi: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena2Size() -> u32_;
}
extern "C" {
    pub fn SYS_SetPowerCallback(cb: powercallback) -> powercallback;
}
extern "C" {
    pub fn SYS_Time() -> u64_;
}
extern "C" {
    pub fn kprintf(str_: *const ::libc::c_char, ...);
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,singlefield NTSC mode"]
    pub static mut TVNtsc240Ds: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,singlefield,antialiased NTSC mode"]
    pub static mut TVNtsc240DsAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,interlaced NTSC mode"]
    pub static mut TVNtsc240Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,interlaced,antialiased NTSC mode"]
    pub static mut TVNtsc240IntAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced NTSC mode"]
    pub static mut TVNtsc480Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced,doublefield NTSC mode"]
    pub static mut TVNtsc480IntDf: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced,doublefield,antialiased NTSC mode"]
    pub static mut TVNtsc480IntAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,progressive,singlefield NTSC mode"]
    pub static mut TVNtsc480Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVNtsc480ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVNtsc480ProgAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240Ds: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240DsAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240Int: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced,doublefield,antialiased MPAL mode"]
    pub static mut TVMpal480IntDf: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480ProgAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,singlefield PAL mode"]
    pub static mut TVPal264Ds: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,singlefield,antialiased PAL mode"]
    pub static mut TVPal264DsAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,interlaced PAL mode"]
    pub static mut TVPal264Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,interlaced,antialiased PAL mode"]
    pub static mut TVPal264IntAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 528 lines,interlaced PAL mode"]
    pub static mut TVPal528Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 528 lines,interlaced,doublefield PAL mode"]
    pub static mut TVPal528IntDf: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 524 lines,interlaced,doublefield,antialiased PAL mode"]
    pub static mut TVPal524IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVPal576IntDfScale: GXRModeObj;
}
extern "C" {
    pub static mut TVPal528Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVPal528ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVPal524ProgAa: GXRModeObj;
}
extern "C" {
    pub static mut TVPal576ProgScale: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240Ds: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240DsAa: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240Int: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480Int: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480IntDf: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480ProgAa: GXRModeObj;
}
#[doc = " \\typedef void (*VIRetraceCallback)(u32 retraceCnt)\n \\brief function pointer typedef for the user's retrace callback\n \\param[in] retraceCnt current retrace count"]
pub type VIRetraceCallback = ::core::option::Option<unsafe extern "C" fn(retraceCnt: u32_)>;
pub type VIPositionCallback = ::core::option::Option<unsafe extern "C" fn(posX: u32_, posY: u32_)>;
extern "C" {
    pub fn VIDEO_GetNextFramebuffer() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn VIDEO_GetCurrentFramebuffer() -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\fn void VIDEO_Init(void)\n \\brief Initializes the VIDEO subsystem. This call should be done in the early stages of your main()\n\n \\return none"]
    pub fn VIDEO_Init();
}
extern "C" {
    #[doc = " \\fn void VIDEO_Flush(void)\n \\brief Flush the shadow registers to the drivers video registers.\n\n \\return none"]
    pub fn VIDEO_Flush();
}
extern "C" {
    #[doc = " \\fn void VIDEO_SetBlack(bool black)\n \\brief Blackout the VIDEO interface.\n\n \\param[in] black Boolean flag to determine whether to blackout the VI or not.\n\n \\return none"]
    pub fn VIDEO_SetBlack(black: bool);
}
extern "C" {
    #[doc = " \\fn u32 VIDEO_GetNextField(void)\n \\brief Get the next field in DS mode.\n\n \\return \\ref vi_fielddef \"field\""]
    pub fn VIDEO_GetNextField() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 VIDEO_GetCurrentLine(void)\n \\brief Get current video line\n\n \\return linenumber"]
    pub fn VIDEO_GetCurrentLine() -> u32_;
}
extern "C" {
    #[doc = " \\fn u32 VIDEO_GetCurrentTvMode(void)\n \\brief Get current configured TV mode\n\n \\return \\ref vi_standardtypedef \"tvmode\""]
    pub fn VIDEO_GetCurrentTvMode() -> u32_;
}
extern "C" {
    #[doc = " \\fn void VIDEO_Configure(GXRModeObj *rmode)\n \\brief Configure the VI with the given render mode object\n\n \\param[in] rmode pointer to the video/render mode \\ref gxrmode_obj \"configuration\".\n\n \\return none"]
    pub fn VIDEO_Configure(rmode: *mut GXRModeObj);
}
extern "C" {
    pub fn VIDEO_GetFrameBufferSize(rmode: *mut GXRModeObj) -> u32_;
}
extern "C" {
    #[doc = " \\fn void VIDEO_ClearFrameBuffer(GXRModeObj *rmode,void *fb,u32 color)\n \\brief Clear the given framebuffer.\n\n \\param[in] rmode pointer to a GXRModeObj, specifying the mode.\n \\param[in] fb pointer to the startaddress of the framebuffer to clear.\n \\param[in] color YUYUV value to use for clearing.\n\n \\return none"]
    pub fn VIDEO_ClearFrameBuffer(rmode: *mut GXRModeObj, fb: *mut ::libc::c_void, color: u32_);
}
extern "C" {
    #[doc = " \\fn void VIDEO_WaitVSync(void)\n \\brief Wait on the next vertical retrace\n\n \\return none"]
    pub fn VIDEO_WaitVSync();
}
extern "C" {
    #[doc = " \\fn void VIDEO_SetNextFramebuffer(void *fb)\n \\brief Set the framebuffer for the next VI register update.\n\n \\return none"]
    pub fn VIDEO_SetNextFramebuffer(fb: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " \\fn void VIDEO_SetNextRightFramebuffer(void *fb)\n \\brief Set the right framebuffer for the next VI register update. This is used for 3D Gloves for instance.\n\n \\return none"]
    pub fn VIDEO_SetNextRightFramebuffer(fb: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " \\fn VIRetraceCallback VIDEO_SetPreRetraceCallback(VIRetraceCallback callback)\n \\brief Set the Pre-Retrace callback function. This function is called within the video interrupt handler before the VI registers will be updated.\n\n \\param[in] callback pointer to the callback function which is called at pre-retrace.\n\n \\return Old pre-retrace callback or NULL"]
    pub fn VIDEO_SetPreRetraceCallback(callback: VIRetraceCallback) -> VIRetraceCallback;
}
extern "C" {
    #[doc = " \\fn VIRetraceCallback VIDEO_SetPostRetraceCallback(VIRetraceCallback callback)\n \\brief Set the Post-Retrace callback function. This function is called within the video interrupt handler after the VI registers are updated.\n\n \\param[in] callback pointer to the callback function which is called at post-retrace.\n\n \\return Old post-retrace callback or NULL"]
    pub fn VIDEO_SetPostRetraceCallback(callback: VIRetraceCallback) -> VIRetraceCallback;
}
extern "C" {
    #[doc = " \\fn u32 VIDEO_HaveComponentCable(void)\n \\brief Check for a component cable. This function returns 1 when a Component (YPbPr) cable is connected.\n\n \\return 1 if a component cable is connected, 0 otherwise"]
    pub fn VIDEO_HaveComponentCable() -> u32_;
}
extern "C" {
    pub fn VIDEO_GetPreferredMode(mode: *mut GXRModeObj) -> *mut GXRModeObj;
}
extern "C" {
    #[doc = " \\fn u32 VIDEO_GetVideoScanMode(void)\n \\brief Get video scan mode. This function returns 0 when interlaced, 1 when non interlaced and 2 when progressive\n\n \\return 0 when interlaced, 1 when non interlaced and 2 when progressive"]
    pub fn VIDEO_GetVideoScanMode() -> u32_;
}
extern "C" {
    pub fn usb_flush(chn: s32);
}
extern "C" {
    pub fn usb_isgeckoalive(chn: s32) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer_safe(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer_safe(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer_ex(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer_ex(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer_safe_ex(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer_safe_ex(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_flashread(
        chn: s32,
        offset: u32_,
        buffer: *mut ::libc::c_void,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_flashwrite(
        chn: s32,
        offset: u32_,
        buffer: *const ::libc::c_void,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_flashverify(chn: s32) -> ::libc::c_int;
}
extern "C" {
    pub fn MakeTexture565(
        src: *const ::libc::c_void,
        dst: *mut ::libc::c_void,
        width: s32,
        height: s32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ioctlv {
    pub data: *mut ::libc::c_void,
    pub len: u32_,
}
pub type ioctlv = _ioctlv;
extern "C" {
    pub fn __IPC_Reinitialize();
}
pub type ipccallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn iosCreateHeap(size: s32) -> s32;
}
extern "C" {
    pub fn iosAlloc(hid: s32, size: s32) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn iosFree(hid: s32, ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn IPC_GetBufferLo() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn IPC_GetBufferHi() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn IPC_SetBufferLo(bufferlo: *mut ::libc::c_void);
}
extern "C" {
    pub fn IPC_SetBufferHi(bufferhi: *mut ::libc::c_void);
}
extern "C" {
    pub fn IOS_Open(filepath: *const ::libc::c_char, mode: u32_) -> s32;
}
extern "C" {
    pub fn IOS_OpenAsync(
        filepath: *const ::libc::c_char,
        mode: u32_,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Close(fd: s32) -> s32;
}
extern "C" {
    pub fn IOS_CloseAsync(fd: s32, ipc_cb: ipccallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn IOS_Seek(fd: s32, where_: s32, whence: s32) -> s32;
}
extern "C" {
    pub fn IOS_SeekAsync(
        fd: s32,
        where_: s32,
        whence: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Read(fd: s32, buf: *mut ::libc::c_void, len: s32) -> s32;
}
extern "C" {
    pub fn IOS_ReadAsync(
        fd: s32,
        buf: *mut ::libc::c_void,
        len: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Write(fd: s32, buf: *const ::libc::c_void, len: s32) -> s32;
}
extern "C" {
    pub fn IOS_WriteAsync(
        fd: s32,
        buf: *const ::libc::c_void,
        len: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Ioctl(
        fd: s32,
        ioctl: s32,
        buffer_in: *mut ::libc::c_void,
        len_in: s32,
        buffer_io: *mut ::libc::c_void,
        len_io: s32,
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlAsync(
        fd: s32,
        ioctl: s32,
        buffer_in: *mut ::libc::c_void,
        len_in: s32,
        buffer_io: *mut ::libc::c_void,
        len_io: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Ioctlv(fd: s32, ioctl: s32, cnt_in: s32, cnt_io: s32, argv: *mut ioctlv) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvAsync(
        fd: s32,
        ioctl: s32,
        cnt_in: s32,
        cnt_io: s32,
        argv: *mut ioctlv,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvFormat(
        hId: s32,
        fd: s32,
        ioctl: s32,
        format: *const ::libc::c_char,
        ...
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvFormatAsync(
        hId: s32,
        fd: s32,
        ioctl: s32,
        usr_cb: ipccallback,
        usr_data: *mut ::libc::c_void,
        format: *const ::libc::c_char,
        ...
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvReboot(
        fd: s32,
        ioctl: s32,
        cnt_in: s32,
        cnt_io: s32,
        argv: *mut ioctlv,
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvRebootBackground(
        fd: s32,
        ioctl: s32,
        cnt_in: s32,
        cnt_io: s32,
        argv: *mut ioctlv,
    ) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha_context {
    pub states: [u32_; 5usize],
    pub upper_length: u32_,
    pub lower_length: u32_,
}
extern "C" {
    pub fn SHA_Init() -> s32;
}
extern "C" {
    pub fn SHA_Close() -> s32;
}
extern "C" {
    pub fn SHA_InitializeContext(context: *mut sha_context) -> s32;
}
extern "C" {
    pub fn SHA_Calculate(
        context: *mut sha_context,
        data: *const ::libc::c_void,
        data_size: u32_,
        message_digest: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn SHA_Input(
        context: *mut sha_context,
        data: *const ::libc::c_void,
        data_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn AES_Init() -> s32;
}
extern "C" {
    pub fn AES_Close() -> s32;
}
extern "C" {
    pub fn AES_Decrypt(
        key: *const ::libc::c_void,
        key_size: u32_,
        iv: *mut ::libc::c_void,
        iv_size: u32_,
        in_data: *const ::libc::c_void,
        out_data: *mut ::libc::c_void,
        data_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn AES_Encrypt(
        key: *const ::libc::c_void,
        key_size: u32_,
        iv: *mut ::libc::c_void,
        iv_size: u32_,
        in_data: *const ::libc::c_void,
        out_data: *mut ::libc::c_void,
        data_size: u32_,
    ) -> s32;
}
pub type sigtype = u32_;
pub type sig_header = sigtype;
pub type signed_blob = sig_header;
pub type sha1 = [u8_; 20usize];
pub type aeskey = [u8_; 16usize];
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sig_rsa2048 {
    pub type_: sigtype,
    pub sig: [u8_; 256usize],
    pub fill: [u8_; 60usize],
}
pub type sig_rsa2048 = _sig_rsa2048;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sig_rsa4096 {
    pub type_: sigtype,
    pub sig: [u8_; 512usize],
    pub fill: [u8_; 60usize],
}
pub type sig_rsa4096 = _sig_rsa4096;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sig_ecdsa {
    pub type_: sigtype,
    pub sig: [u8_; 60usize],
    pub fill: [u8_; 64usize],
}
pub type sig_ecdsa = _sig_ecdsa;
pub type sig_issuer = [::libc::c_char; 64usize];
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tiklimit {
    pub tag: u32_,
    pub value: u32_,
}
pub type tiklimit = _tiklimit;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tikview {
    pub view: u32_,
    pub ticketid: u64_,
    pub devicetype: u32_,
    pub titleid: u64_,
    pub access_mask: u16_,
    pub reserved: [u8_; 60usize],
    pub cidx_mask: [u8_; 64usize],
    pub padding: u16_,
    pub limits: [tiklimit; 8usize],
}
pub type tikview = _tikview;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tik {
    pub issuer: sig_issuer,
    pub fill: [u8_; 63usize],
    pub cipher_title_key: aeskey,
    pub fill2: u8_,
    pub ticketid: u64_,
    pub devicetype: u32_,
    pub titleid: u64_,
    pub access_mask: u16_,
    pub reserved: [u8_; 60usize],
    pub cidx_mask: [u8_; 64usize],
    pub padding: u16_,
    pub limits: [tiklimit; 8usize],
}
pub type tik = _tik;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tmd_content {
    pub cid: u32_,
    pub index: u16_,
    pub type_: u16_,
    pub size: u64_,
    pub hash: sha1,
}
pub type tmd_content = _tmd_content;
#[repr(C, packed)]
pub struct _tmd {
    pub issuer: sig_issuer,
    pub version: u8_,
    pub ca_crl_version: u8_,
    pub signer_crl_version: u8_,
    pub vwii_title: u8_,
    pub sys_version: u64_,
    pub title_id: u64_,
    pub title_type: u32_,
    pub group_id: u16_,
    pub zero: u16_,
    pub region: u16_,
    pub ratings: [u8_; 16usize],
    pub reserved: [u8_; 12usize],
    pub ipc_mask: [u8_; 12usize],
    pub reserved2: [u8_; 18usize],
    pub access_rights: u32_,
    pub title_version: u16_,
    pub num_contents: u16_,
    pub boot_index: u16_,
    pub fill3: u16_,
    pub contents: __IncompleteArrayField<tmd_content>,
}
pub type tmd = _tmd;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tmd_view_content {
    pub cid: u32_,
    pub index: u16_,
    pub type_: u16_,
    pub size: u64_,
}
pub type tmd_view_content = _tmd_view_content;
#[repr(C, packed)]
pub struct _tmdview {
    pub version: u8_,
    pub filler: [u8_; 3usize],
    pub sys_version: u64_,
    pub title_id: u64_,
    pub title_type: u32_,
    pub group_id: u16_,
    pub reserved: [u8_; 62usize],
    pub title_version: u16_,
    pub num_contents: u16_,
    pub contents: __IncompleteArrayField<tmd_view_content>,
}
pub type tmd_view = _tmdview;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_header {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
}
pub type cert_header = _cert_header;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_rsa2048 {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
    pub modulus: [u8_; 256usize],
    pub exponent: u32_,
    pub pad: [u8_; 52usize],
}
pub type cert_rsa2048 = _cert_rsa2048;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_rsa4096 {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
    pub modulus: [u8_; 512usize],
    pub exponent: u32_,
    pub pad: [u8_; 52usize],
}
pub type cert_rsa4096 = _cert_rsa4096;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_ecdsa {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
    pub r: [u8_; 30usize],
    pub s: [u8_; 30usize],
    pub pad: [u8_; 60usize],
}
pub type cert_ecdsa = _cert_ecdsa;
extern "C" {
    pub fn __ES_Init() -> s32;
}
extern "C" {
    pub fn __ES_Close() -> s32;
}
extern "C" {
    pub fn __ES_Reset() -> s32;
}
extern "C" {
    pub fn ES_GetTitleID(titleID: *mut u64_) -> s32;
}
extern "C" {
    pub fn ES_SetUID(uid: u64_) -> s32;
}
extern "C" {
    pub fn ES_GetDataDir(titleID: u64_, filepath: *mut ::libc::c_char) -> s32;
}
extern "C" {
    pub fn ES_GetNumTicketViews(titleID: u64_, cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTicketViews(titleID: u64_, views: *mut tikview, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumOwnedTitles(cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetOwnedTitles(titles: *mut u64_, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumTitles(cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTitles(titles: *mut u64_, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumStoredTMDContents(
        stmd: *const signed_blob,
        tmd_size: u32_,
        cnt: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_GetStoredTMDContents(
        stmd: *const signed_blob,
        tmd_size: u32_,
        contents: *mut u32_,
        cnt: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_GetStoredTMDSize(titleID: u64_, size: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetStoredTMD(titleID: u64_, stmd: *mut signed_blob, size: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTitleContentsCount(titleID: u64_, num: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTitleContents(titleID: u64_, data: *mut u8_, size: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTMDViewSize(titleID: u64_, size: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTMDView(titleID: u64_, data: *mut u8_, size: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumSharedContents(cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetSharedContents(contents: *mut sha1, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_LaunchTitle(titleID: u64_, view: *const tikview) -> s32;
}
extern "C" {
    pub fn ES_LaunchTitleBackground(titleID: u64_, view: *const tikview) -> s32;
}
extern "C" {
    pub fn ES_Identify(
        certificates: *const signed_blob,
        certificates_size: u32_,
        tmd: *const signed_blob,
        tmd_size: u32_,
        ticket: *const signed_blob,
        ticket_size: u32_,
        keyid: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_AddTicket(
        tik: *const signed_blob,
        tik_size: u32_,
        certificates: *const signed_blob,
        certificates_size: u32_,
        crl: *const signed_blob,
        crl_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_DeleteTicket(view: *const tikview) -> s32;
}
extern "C" {
    pub fn ES_AddTitleTMD(tmd: *const signed_blob, tmd_size: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddTitleStart(
        tmd: *const signed_blob,
        tmd_size: u32_,
        certificatess: *const signed_blob,
        certificatess_size: u32_,
        crl: *const signed_blob,
        crl_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_AddContentStart(titleID: u64_, cid: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddContentData(cid: s32, data: *mut u8_, data_size: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddContentFinish(cid: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddTitleFinish() -> s32;
}
extern "C" {
    pub fn ES_AddTitleCancel() -> s32;
}
extern "C" {
    pub fn ES_ImportBoot(
        tik: *const signed_blob,
        tik_size: u32_,
        tik_certs: *const signed_blob,
        tik_certs_size: u32_,
        tmd: *const signed_blob,
        tmd_size: u32_,
        tmd_certs: *const signed_blob,
        tmd_certs_size: u32_,
        content: *const u8_,
        content_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_OpenContent(index: u16_) -> s32;
}
extern "C" {
    pub fn ES_OpenTitleContent(titleID: u64_, views: *mut tikview, index: u16_) -> s32;
}
extern "C" {
    pub fn ES_ReadContent(cfd: s32, data: *mut u8_, data_size: u32_) -> s32;
}
extern "C" {
    pub fn ES_SeekContent(cfd: s32, where_: s32, whence: s32) -> s32;
}
extern "C" {
    pub fn ES_CloseContent(cfd: s32) -> s32;
}
extern "C" {
    pub fn ES_DeleteTitle(titleID: u64_) -> s32;
}
extern "C" {
    pub fn ES_DeleteTitleContent(titleID: u64_) -> s32;
}
extern "C" {
    pub fn ES_Encrypt(
        keynum: u32_,
        iv: *mut u8_,
        source: *mut u8_,
        size: u32_,
        dest: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn ES_Decrypt(
        keynum: u32_,
        iv: *mut u8_,
        source: *mut u8_,
        size: u32_,
        dest: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn ES_Sign(source: *mut u8_, size: u32_, sig: *mut u8_, certs: *mut u8_) -> s32;
}
extern "C" {
    pub fn ES_GetDeviceCert(outbuf: *mut u8_) -> s32;
}
extern "C" {
    pub fn ES_GetDeviceID(device_id: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetBoot2Version(version: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_NextCert(certs: *const signed_blob) -> *mut signed_blob;
}
pub type stmcallback = ::core::option::Option<unsafe extern "C" fn(event: u32_)>;
extern "C" {
    pub fn __STM_Init() -> s32;
}
extern "C" {
    pub fn __STM_Close() -> s32;
}
extern "C" {
    pub fn STM_ShutdownToStandby() -> s32;
}
extern "C" {
    pub fn STM_ShutdownToIdle() -> s32;
}
extern "C" {
    pub fn STM_SetLedMode(mode: u32_) -> s32;
}
extern "C" {
    pub fn STM_RebootSystem() -> s32;
}
extern "C" {
    pub fn STM_RegisterEventHandler(newhandler: stmcallback) -> stmcallback;
}
extern "C" {
    pub fn __IOS_InitializeSubsystems() -> s32;
}
extern "C" {
    pub fn __IOS_ShutdownSubsystems() -> s32;
}
extern "C" {
    pub fn __IOS_LoadStartupIOS() -> s32;
}
extern "C" {
    pub fn __IOS_LaunchNewIOS(version: ::libc::c_int) -> s32;
}
extern "C" {
    pub fn IOS_GetPreferredVersion() -> s32;
}
extern "C" {
    pub fn IOS_ReloadIOS(version: ::libc::c_int) -> s32;
}
extern "C" {
    pub fn IOS_GetVersion() -> s32;
}
extern "C" {
    pub fn IOS_GetRevision() -> s32;
}
extern "C" {
    pub fn IOS_GetRevisionMajor() -> s32;
}
extern "C" {
    pub fn IOS_GetRevisionMinor() -> s32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbendpointdesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bEndpointAddress: u8_,
    pub bmAttributes: u8_,
    pub wMaxPacketSize: u16_,
    pub bInterval: u8_,
}
pub type usb_endpointdesc = _usbendpointdesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbinterfacedesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bInterfaceNumber: u8_,
    pub bAlternateSetting: u8_,
    pub bNumEndpoints: u8_,
    pub bInterfaceClass: u8_,
    pub bInterfaceSubClass: u8_,
    pub bInterfaceProtocol: u8_,
    pub iInterface: u8_,
    pub extra: *mut u8_,
    pub extra_size: u16_,
    pub endpoints: *mut _usbendpointdesc,
}
pub type usb_interfacedesc = _usbinterfacedesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbconfdesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub wTotalLength: u16_,
    pub bNumInterfaces: u8_,
    pub bConfigurationValue: u8_,
    pub iConfiguration: u8_,
    pub bmAttributes: u8_,
    pub bMaxPower: u8_,
    pub interfaces: *mut _usbinterfacedesc,
}
pub type usb_configurationdesc = _usbconfdesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbdevdesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bcdUSB: u16_,
    pub bDeviceClass: u8_,
    pub bDeviceSubClass: u8_,
    pub bDeviceProtocol: u8_,
    pub bMaxPacketSize0: u8_,
    pub idVendor: u16_,
    pub idProduct: u16_,
    pub bcdDevice: u16_,
    pub iManufacturer: u8_,
    pub iProduct: u8_,
    pub iSerialNumber: u8_,
    pub bNumConfigurations: u8_,
    pub configurations: *mut _usbconfdesc,
}
pub type usb_devdesc = _usbdevdesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbhiddesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bcdHID: u16_,
    pub bCountryCode: u8_,
    pub bNumDescriptors: u8_,
    pub descr: [_usbhiddesc__bindgen_ty_1; 1usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbhiddesc__bindgen_ty_1 {
    pub bDescriptorType: u8_,
    pub wDescriptorLength: u16_,
}
pub type usb_hiddesc = _usbhiddesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usb_device_entry {
    pub device_id: s32,
    pub vid: u16_,
    pub pid: u16_,
    pub token: u32_,
}
pub type usb_device_entry = _usb_device_entry;
pub type usbcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn USB_Initialize() -> s32;
}
extern "C" {
    pub fn USB_Deinitialize() -> s32;
}
extern "C" {
    pub fn USB_OpenDevice(device_id: s32, vid: u16_, pid: u16_, fd: *mut s32) -> s32;
}
extern "C" {
    pub fn USB_CloseDevice(fd: *mut s32) -> s32;
}
extern "C" {
    pub fn USB_CloseDeviceAsync(fd: *mut s32, cb: usbcallback, usrdata: *mut ::libc::c_void)
        -> s32;
}
extern "C" {
    pub fn USB_GetDescriptors(fd: s32, udd: *mut usb_devdesc) -> s32;
}
extern "C" {
    pub fn USB_FreeDescriptors(udd: *mut usb_devdesc);
}
extern "C" {
    pub fn USB_GetGenericDescriptor(
        fd: s32,
        type_: u8_,
        index: u8_,
        interface: u8_,
        data: *mut ::libc::c_void,
        size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetHIDDescriptor(fd: s32, interface: u8_, uhd: *mut usb_hiddesc, size: u32_) -> s32;
}
extern "C" {
    pub fn USB_GetReportDescriptorSize(fd: s32, interface: u8_) -> s32;
}
extern "C" {
    pub fn USB_GetReportDescriptor(
        fd: s32,
        interface: u8_,
        data: *mut ::libc::c_void,
        size: u16_,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetDeviceDescription(fd: s32, devdesc: *mut usb_devdesc) -> s32;
}
extern "C" {
    pub fn USB_DeviceRemovalNotifyAsync(
        fd: s32,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_DeviceChangeNotifyAsync(
        interface_class: u8_,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_SuspendDevice(fd: s32) -> s32;
}
extern "C" {
    pub fn USB_ResumeDevice(fd: s32) -> s32;
}
extern "C" {
    pub fn USB_ReadIsoMsg(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadIsoMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadIntrMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadIntrMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadBlkMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadBlkMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadCtrlMsg(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadCtrlMsgAsync(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIsoMsg(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIsoMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIntrMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIntrMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteBlkMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteBlkMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteCtrlMsg(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteCtrlMsgAsync(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetConfiguration(fd: s32, configuration: *mut u8_) -> s32;
}
extern "C" {
    pub fn USB_SetConfiguration(fd: s32, configuration: u8_) -> s32;
}
extern "C" {
    pub fn USB_SetAlternativeInterface(fd: s32, interface: u8_, alternateSetting: u8_) -> s32;
}
extern "C" {
    pub fn USB_ClearHalt(fd: s32, endpointAddress: u8_) -> s32;
}
extern "C" {
    pub fn USB_GetDeviceList(
        descr_buffer: *mut usb_device_entry,
        num_descr: u8_,
        interface_class: u8_,
        cnt_descr: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetAsciiString(
        fd: s32,
        bIndex: u8_,
        wLangID: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fstats {
    pub file_length: u32_,
    pub file_pos: u32_,
}
pub type fstats = _fstats;
pub type isfscallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn ISFS_Initialize() -> s32;
}
extern "C" {
    pub fn ISFS_Deinitialize() -> s32;
}
extern "C" {
    pub fn ISFS_Format() -> s32;
}
extern "C" {
    pub fn ISFS_FormatAsync(cb: isfscallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn ISFS_Open(filepath: *const ::libc::c_char, mode: u8_) -> s32;
}
extern "C" {
    pub fn ISFS_OpenAsync(
        filepath: *const ::libc::c_char,
        mode: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Close(fd: s32) -> s32;
}
extern "C" {
    pub fn ISFS_CloseAsync(fd: s32, cb: isfscallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn ISFS_Delete(filepath: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn ISFS_DeleteAsync(
        filepath: *const ::libc::c_char,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_ReadDir(
        filepath: *const ::libc::c_char,
        name_list: *mut ::libc::c_char,
        num: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_ReadDirAsync(
        filepath: *const ::libc::c_char,
        name_list: *mut ::libc::c_char,
        num: *mut u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateFile(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateFileAsync(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Write(fd: s32, buffer: *const ::libc::c_void, length: u32_) -> s32;
}
extern "C" {
    pub fn ISFS_WriteAsync(
        fd: s32,
        buffer: *const ::libc::c_void,
        length: u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Read(fd: s32, buffer: *mut ::libc::c_void, length: u32_) -> s32;
}
extern "C" {
    pub fn ISFS_ReadAsync(
        fd: s32,
        buffer: *mut ::libc::c_void,
        length: u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Seek(fd: s32, where_: s32, whence: s32) -> s32;
}
extern "C" {
    pub fn ISFS_SeekAsync(
        fd: s32,
        where_: s32,
        whence: s32,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateDir(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateDirAsync(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetStats(stats: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn ISFS_GetStatsAsync(
        stats: *mut ::libc::c_void,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetFileStats(fd: s32, status: *mut fstats) -> s32;
}
extern "C" {
    pub fn ISFS_GetFileStatsAsync(
        fd: s32,
        status: *mut fstats,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetAttr(
        filepath: *const ::libc::c_char,
        ownerID: *mut u32_,
        groupID: *mut u16_,
        attributes: *mut u8_,
        ownerperm: *mut u8_,
        groupperm: *mut u8_,
        otherperm: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetAttrAsync(
        filepath: *const ::libc::c_char,
        ownerID: *mut u32_,
        groupID: *mut u16_,
        attributes: *mut u8_,
        ownerperm: *mut u8_,
        groupperm: *mut u8_,
        otherperm: *mut u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Rename(
        filepathOld: *const ::libc::c_char,
        filepathNew: *const ::libc::c_char,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_RenameAsync(
        filepathOld: *const ::libc::c_char,
        filepathNew: *const ::libc::c_char,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_SetAttr(
        filepath: *const ::libc::c_char,
        ownerID: u32_,
        groupID: u16_,
        attributes: u8_,
        ownerperm: u8_,
        groupperm: u8_,
        otherperm: u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_SetAttrAsync(
        filepath: *const ::libc::c_char,
        ownerID: u32_,
        groupID: u16_,
        attributes: u8_,
        ownerperm: u8_,
        groupperm: u8_,
        otherperm: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetUsage(
        filepath: *const ::libc::c_char,
        usage1: *mut u32_,
        usage2: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetUsageAsync(
        filepath: *const ::libc::c_char,
        usage1: *mut u32_,
        usage2: *mut u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
pub const CONF_BIGARRAY: _bindgen_ty_2 = 1;
pub const CONF_SMALLARRAY: _bindgen_ty_2 = 2;
pub const CONF_BYTE: _bindgen_ty_2 = 3;
pub const CONF_SHORT: _bindgen_ty_2 = 4;
pub const CONF_LONG: _bindgen_ty_2 = 5;
pub const CONF_BOOL: _bindgen_ty_2 = 7;
pub type _bindgen_ty_2 = ::libc::c_uint;
pub const CONF_VIDEO_NTSC: _bindgen_ty_3 = 0;
pub const CONF_VIDEO_PAL: _bindgen_ty_3 = 1;
pub const CONF_VIDEO_MPAL: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::libc::c_uint;
pub const CONF_REGION_JP: _bindgen_ty_4 = 0;
pub const CONF_REGION_US: _bindgen_ty_4 = 1;
pub const CONF_REGION_EU: _bindgen_ty_4 = 2;
pub const CONF_REGION_KR: _bindgen_ty_4 = 4;
pub const CONF_REGION_CN: _bindgen_ty_4 = 5;
pub type _bindgen_ty_4 = ::libc::c_uint;
pub const CONF_AREA_JPN: _bindgen_ty_5 = 0;
pub const CONF_AREA_USA: _bindgen_ty_5 = 1;
pub const CONF_AREA_EUR: _bindgen_ty_5 = 2;
pub const CONF_AREA_AUS: _bindgen_ty_5 = 3;
pub const CONF_AREA_BRA: _bindgen_ty_5 = 4;
pub const CONF_AREA_TWN: _bindgen_ty_5 = 5;
pub const CONF_AREA_ROC: _bindgen_ty_5 = 6;
pub const CONF_AREA_KOR: _bindgen_ty_5 = 7;
pub const CONF_AREA_HKG: _bindgen_ty_5 = 8;
pub const CONF_AREA_ASI: _bindgen_ty_5 = 9;
pub const CONF_AREA_LTN: _bindgen_ty_5 = 10;
pub const CONF_AREA_SAF: _bindgen_ty_5 = 11;
pub const CONF_AREA_CHN: _bindgen_ty_5 = 12;
pub type _bindgen_ty_5 = ::libc::c_uint;
pub const CONF_SHUTDOWN_STANDBY: _bindgen_ty_6 = 0;
pub const CONF_SHUTDOWN_IDLE: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::libc::c_uint;
pub const CONF_LED_OFF: _bindgen_ty_7 = 0;
pub const CONF_LED_DIM: _bindgen_ty_7 = 1;
pub const CONF_LED_BRIGHT: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::libc::c_uint;
pub const CONF_SOUND_MONO: _bindgen_ty_8 = 0;
pub const CONF_SOUND_STEREO: _bindgen_ty_8 = 1;
pub const CONF_SOUND_SURROUND: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::libc::c_uint;
pub const CONF_LANG_JAPANESE: _bindgen_ty_9 = 0;
pub const CONF_LANG_ENGLISH: _bindgen_ty_9 = 1;
pub const CONF_LANG_GERMAN: _bindgen_ty_9 = 2;
pub const CONF_LANG_FRENCH: _bindgen_ty_9 = 3;
pub const CONF_LANG_SPANISH: _bindgen_ty_9 = 4;
pub const CONF_LANG_ITALIAN: _bindgen_ty_9 = 5;
pub const CONF_LANG_DUTCH: _bindgen_ty_9 = 6;
pub const CONF_LANG_SIMP_CHINESE: _bindgen_ty_9 = 7;
pub const CONF_LANG_TRAD_CHINESE: _bindgen_ty_9 = 8;
pub const CONF_LANG_KOREAN: _bindgen_ty_9 = 9;
pub type _bindgen_ty_9 = ::libc::c_uint;
pub const CONF_ASPECT_4_3: _bindgen_ty_10 = 0;
pub const CONF_ASPECT_16_9: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::libc::c_uint;
pub const CONF_SENSORBAR_BOTTOM: _bindgen_ty_11 = 0;
pub const CONF_SENSORBAR_TOP: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::libc::c_uint;
pub type conf_pad_device = _conf_pad_device;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _conf_pad_device {
    pub bdaddr: [u8_; 6usize],
    pub name: [::libc::c_char; 64usize],
}
pub type conf_pads = _conf_pads;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _conf_pads {
    pub num_registered: u8_,
    pub registered: [conf_pad_device; 10usize],
    pub active: [conf_pad_device; 4usize],
    pub balance_board: conf_pad_device,
    pub unknown: conf_pad_device,
}
extern "C" {
    pub fn CONF_Init() -> s32;
}
extern "C" {
    pub fn CONF_GetLength(name: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn CONF_GetType(name: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn CONF_Get(name: *const ::libc::c_char, buffer: *mut ::libc::c_void, length: u32_) -> s32;
}
extern "C" {
    pub fn CONF_GetShutdownMode() -> s32;
}
extern "C" {
    pub fn CONF_GetIdleLedMode() -> s32;
}
extern "C" {
    pub fn CONF_GetProgressiveScan() -> s32;
}
extern "C" {
    pub fn CONF_GetEuRGB60() -> s32;
}
extern "C" {
    pub fn CONF_GetIRSensitivity() -> s32;
}
extern "C" {
    pub fn CONF_GetSensorBarPosition() -> s32;
}
extern "C" {
    pub fn CONF_GetPadSpeakerVolume() -> s32;
}
extern "C" {
    pub fn CONF_GetPadMotorMode() -> s32;
}
extern "C" {
    pub fn CONF_GetSoundMode() -> s32;
}
extern "C" {
    pub fn CONF_GetLanguage() -> s32;
}
extern "C" {
    pub fn CONF_GetCounterBias(bias: *mut u32_) -> s32;
}
extern "C" {
    pub fn CONF_GetScreenSaverMode() -> s32;
}
extern "C" {
    pub fn CONF_GetDisplayOffsetH(offset: *mut s8) -> s32;
}
extern "C" {
    pub fn CONF_GetPadDevices(pads: *mut conf_pads) -> s32;
}
extern "C" {
    pub fn CONF_GetNickName(nickname: *mut u8_) -> s32;
}
extern "C" {
    pub fn CONF_GetAspectRatio() -> s32;
}
extern "C" {
    pub fn CONF_GetEULA() -> s32;
}
extern "C" {
    pub fn CONF_GetParentalPassword(password: *mut s8) -> s32;
}
extern "C" {
    pub fn CONF_GetParentalAnswer(answer: *mut s8) -> s32;
}
extern "C" {
    pub fn CONF_GetWiiConnect24() -> s32;
}
extern "C" {
    pub fn CONF_GetRegion() -> s32;
}
extern "C" {
    pub fn CONF_GetArea() -> s32;
}
extern "C" {
    pub fn CONF_GetVideo() -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbstorage_handle {
    pub configuration: u8_,
    pub interface: u32_,
    pub altInterface: u32_,
    pub bInterfaceSubClass: u8_,
    pub ep_in: u8_,
    pub ep_out: u8_,
    pub max_lun: u8_,
    pub sector_size: *mut u32_,
    pub usb_fd: s32,
    pub lock: mutex_t,
    pub alarm: syswd_t,
    pub retval: s32,
    pub tag: u32_,
    pub suspended: u8_,
    pub buffer: *mut u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_device_command {
    pub command: [u8; 16usize],
    pub command_length: u8,
    pub flags: u8,
    pub scsi_status: u8,
    pub data: *mut ::libc::c_void,
    pub data_length: usize,
}
extern "C" {
    pub fn USBStorage_Initialize() -> s32;
}
extern "C" {
    pub fn USBStorage_Deinitialize();
}
extern "C" {
    pub fn USBStorage_Open(
        dev: *mut usbstorage_handle,
        device_id: s32,
        vid: u16_,
        pid: u16_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_Close(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_Reset(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_GetMaxLUN(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_MountLUN(dev: *mut usbstorage_handle, lun: u8_) -> s32;
}
extern "C" {
    pub fn USBStorage_Suspend(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_IsDVD() -> s32;
}
extern "C" {
    pub fn USBStorage_ioctl(request: ::libc::c_int, ...) -> s32;
}
extern "C" {
    pub fn USBStorage_ReadCapacity(
        dev: *mut usbstorage_handle,
        lun: u8_,
        sector_size: *mut u32_,
        n_sectors: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_Read(
        dev: *mut usbstorage_handle,
        lun: u8_,
        sector: u32_,
        n_sectors: u16_,
        buffer: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_Write(
        dev: *mut usbstorage_handle,
        lun: u8_,
        sector: u32_,
        n_sectors: u16_,
        buffer: *const u8_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_StartStop(
        dev: *mut usbstorage_handle,
        lun: u8_,
        lo_ej: u8_,
        start: u8_,
        imm: u8_,
    ) -> s32;
}
extern "C" {
    pub static mut __io_usbstorage: DISC_INTERFACE;
}
extern "C" {
    pub fn WII_Initialize() -> s32;
}
extern "C" {
    pub fn WII_ReturnToMenu() -> s32;
}
extern "C" {
    pub fn WII_ReturnToSettings() -> s32;
}
extern "C" {
    pub fn WII_ReturnToSettingsPage(page: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn WII_LaunchTitle(titleID: u64_) -> s32;
}
extern "C" {
    pub fn WII_LaunchTitleWithArgs(titleID: u64_, launchcode: ::libc::c_int, ...) -> s32;
}
extern "C" {
    pub fn WII_OpenURL(url: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = " \\page api_doc Detailed API description\n\n - \\ref aram.h \"ARAM subsystem\"\n - \\ref arqmgr.h \"ARAM queue management subsystem\"\n - \\ref audio.h \"AUDIO subsystem\"\n - \\ref asndlib.h \"ASND library\"\n - \\ref exi.h \"EXI subsystem\"\n - \\ref irq.h \"IRQ subsystem\"\n - \\ref dsp.h \"DSP subsystem\"\n - \\ref dvd.h \"DVD subsystem\"\n - \\ref gx.h \"GX subsystem\"\n - \\ref gu.h \"gu/Matrix subsystem\"\n - \\ref video.h \"VIDEO subsystem\"\n - \\ref cache.h \"Cache subsystem\"\n - \\ref card.h \"Memory card subsystem\"\n - \\ref consol.h \"Console subsystem\"\n - \\ref system.h \"OS functions and initialization\"\n - \\ref lwp.h \"Thread subsystem I\"\n - \\ref message.h \"Thread subsystem II\"\n - \\ref mutex.h \"Thread subsystem III\"\n - \\ref semaphore.h \"Thread subsystem IV\"\n - \\ref cond.h \"Thread subsystem V\""]
    pub fn depackrnc1_ulen(packed: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn depackrnc1(packed: *mut ::libc::c_void, unpacked: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn depackrnc2(packed: *mut ::libc::c_void, unpacked: *mut ::libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
extern "C" {
    pub fn utimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::libc::c_int, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::libc::c_int, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::libc::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: u8_,
    pub sin_family: u8_,
    pub sin_port: u16_,
    pub sin_addr: in_addr,
    pub sin_zero: [s8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8_,
    pub sa_family: u8_,
    pub sa_data: [s8; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::libc::c_char,
    pub h_aliases: *mut *mut ::libc::c_char,
    pub h_addrtype: u16_,
    pub h_length: u16_,
    pub h_addr_list: *mut *mut ::libc::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollsd {
    pub socket: s32,
    pub events: u32_,
    pub revents: u32_,
}
extern "C" {
    pub fn inet_addr(cp: *const ::libc::c_char) -> u32_;
}
extern "C" {
    pub fn inet_aton(cp: *const ::libc::c_char, addr: *mut in_addr) -> s8;
}
extern "C" {
    pub fn inet_ntoa(addr: in_addr) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn if_config(
        local_ip: *mut ::libc::c_char,
        netmask: *mut ::libc::c_char,
        gateway: *mut ::libc::c_char,
        use_dhcp: bool,
        max_retries: ::libc::c_int,
    ) -> s32;
}
extern "C" {
    pub fn if_configex(
        local_ip: *mut in_addr,
        netmask: *mut in_addr,
        gateway: *mut in_addr,
        use_dhcp: bool,
        max_retries: ::libc::c_int,
    ) -> s32;
}
extern "C" {
    pub fn net_init() -> s32;
}
pub type netcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn net_init_async(cb: netcallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn net_get_status() -> s32;
}
extern "C" {
    pub fn net_wc24cleanup();
}
extern "C" {
    pub fn net_get_mac_address(mac_buf: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn net_deinit();
}
extern "C" {
    pub fn net_gethostip() -> u32_;
}
extern "C" {
    pub fn net_socket(domain: u32_, type_: u32_, protocol: u32_) -> s32;
}
extern "C" {
    pub fn net_bind(s: s32, name: *mut sockaddr, namelen: u32_) -> s32;
}
extern "C" {
    pub fn net_listen(s: s32, backlog: u32_) -> s32;
}
extern "C" {
    pub fn net_accept(s: s32, addr: *mut sockaddr, addrlen: *mut u32_) -> s32;
}
extern "C" {
    pub fn net_connect(s: s32, arg1: *mut sockaddr, arg2: u32_) -> s32;
}
extern "C" {
    pub fn net_write(s: s32, data: *const ::libc::c_void, size: s32) -> s32;
}
extern "C" {
    pub fn net_send(s: s32, data: *const ::libc::c_void, size: s32, flags: u32_) -> s32;
}
extern "C" {
    pub fn net_sendto(
        s: s32,
        data: *const ::libc::c_void,
        len: s32,
        flags: u32_,
        to: *mut sockaddr,
        tolen: u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_recv(s: s32, mem: *mut ::libc::c_void, len: s32, flags: u32_) -> s32;
}
extern "C" {
    pub fn net_recvfrom(
        s: s32,
        mem: *mut ::libc::c_void,
        len: s32,
        flags: u32_,
        from: *mut sockaddr,
        fromlen: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_read(s: s32, mem: *mut ::libc::c_void, len: s32) -> s32;
}
extern "C" {
    pub fn net_close(s: s32) -> s32;
}
extern "C" {
    pub fn net_select(
        maxfdp1: s32,
        readset: *mut fd_set,
        writeset: *mut fd_set,
        exceptset: *mut fd_set,
        timeout: *mut timeval,
    ) -> s32;
}
extern "C" {
    pub fn net_getsockopt(
        s: s32,
        level: u32_,
        optname: u32_,
        optval: *const ::libc::c_void,
        optlen: u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_setsockopt(
        s: s32,
        level: u32_,
        optname: u32_,
        optval: *const ::libc::c_void,
        optlen: u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_getsockname(s: s32, addr: *mut sockaddr, addrlen: *mut u32_) -> s32;
}
extern "C" {
    pub fn net_ioctl(s: s32, cmd: u32_, argp: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn net_fcntl(s: s32, cmd: u32_, flags: u32_) -> s32;
}
extern "C" {
    pub fn net_poll(sds: *mut pollsd, nsds: s32, timeout: s32) -> s32;
}
extern "C" {
    pub fn net_shutdown(s: s32, how: u32_) -> s32;
}
extern "C" {
    pub fn net_gethostbyname(addrString: *const ::libc::c_char) -> *mut hostent;
}
extern "C" {
    pub static mut tcp_localip: *const ::libc::c_char;
}
extern "C" {
    pub static mut tcp_netmask: *const ::libc::c_char;
}
extern "C" {
    pub static mut tcp_gateway: *const ::libc::c_char;
}
extern "C" {
    #[doc = "\\fn void _break()\n \\brief Stub function to insert the hardware break instruction. This function is used to enter the debug stub and to\n        connect with the host. The developer is free to insert this function at any position in project's source code.\n\n \\return none."]
    pub fn _break();
}
extern "C" {
    #[doc = "\\fn void DEBUG_Init(s32 device_type,s32 channel_port)\n \\brief Performs the initialization of the debug stub.\n \\param[in] device_type type of device to use. can be either USB or TCP.\n \\param[in] channel_port depending on the used device this can be either the EXI channel or the TCP port.\n\n \\return none."]
    pub fn DEBUG_Init(device_type: s32, channel_port: s32);
}
pub const NOTE_DO: _bindgen_ty_12 = 0;
pub const NOTE_DOs: _bindgen_ty_12 = 1;
pub const NOTE_REb: _bindgen_ty_12 = 1;
pub const NOTE_RE: _bindgen_ty_12 = 2;
pub const NOTE_REs: _bindgen_ty_12 = 3;
pub const NOTE_MIb: _bindgen_ty_12 = 3;
pub const NOTE_MI: _bindgen_ty_12 = 4;
pub const NOTE_FA: _bindgen_ty_12 = 5;
pub const NOTE_FAs: _bindgen_ty_12 = 6;
pub const NOTE_SOLb: _bindgen_ty_12 = 6;
pub const NOTE_SOL: _bindgen_ty_12 = 7;
pub const NOTE_SOLs: _bindgen_ty_12 = 8;
pub const NOTE_LAb: _bindgen_ty_12 = 8;
pub const NOTE_LA: _bindgen_ty_12 = 9;
pub const NOTE_LAs: _bindgen_ty_12 = 10;
pub const NOTE_SIb: _bindgen_ty_12 = 10;
pub const NOTE_SI: _bindgen_ty_12 = 11;
#[doc = " \\addtogroup notecode Note codification\n @{"]
pub type _bindgen_ty_12 = ::libc::c_uint;
pub const NOTE_C: _bindgen_ty_13 = 0;
pub const NOTE_Cs: _bindgen_ty_13 = 1;
pub const NOTE_Db: _bindgen_ty_13 = 1;
pub const NOTE_D: _bindgen_ty_13 = 2;
pub const NOTE_Ds: _bindgen_ty_13 = 3;
pub const NOTE_Eb: _bindgen_ty_13 = 3;
pub const NOTE_E: _bindgen_ty_13 = 4;
pub const NOTE_F: _bindgen_ty_13 = 5;
pub const NOTE_Fs: _bindgen_ty_13 = 6;
pub const NOTE_Gb: _bindgen_ty_13 = 6;
pub const NOTE_G: _bindgen_ty_13 = 7;
pub const NOTE_Gs: _bindgen_ty_13 = 8;
pub const NOTE_Ab: _bindgen_ty_13 = 8;
pub const NOTE_A: _bindgen_ty_13 = 9;
pub const NOTE_As: _bindgen_ty_13 = 10;
pub const NOTE_Bb: _bindgen_ty_13 = 10;
pub const NOTE_B: _bindgen_ty_13 = 11;
pub type _bindgen_ty_13 = ::libc::c_uint;
#[doc = " \\brief Callback type for ASND_SetVoice()."]
pub type ASNDVoiceCallback = ::core::option::Option<unsafe extern "C" fn(voice: s32)>;
extern "C" {
    #[doc = " \\brief Initializes the SND lib and fixes the hardware sample rate.\n \\param[in] note \\ref notecode to play. for example: NOTE(C,4) for note C and octave 4.\n \\param[in] freq_base Frequency base of the sample. For example 8000Hz.\n \\param[in] note_base \\ref notecode of the sample. For example: NOTE(L, 3) for note L and octave 3 (LA 3).\n \\return Frequency, in Hz."]
    pub fn ANote2Freq(
        note: ::libc::c_int,
        freq_base: ::libc::c_int,
        note_base: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Initializes the ASND lib and fixes the hardware sample rate to 48000.\n \\return None."]
    pub fn ASND_Init();
}
extern "C" {
    #[doc = " \\brief De-initializes the ASND lib.\n \\return None."]
    pub fn ASND_End();
}
extern "C" {
    #[doc = " \\brief Used to pause (or unpause) the sound.\n \\note The sound starts paused when ASND_Init() is called.\n \\param[in] paused If 1, sound is paused; sound can be unpaused with 0.\n \\return None."]
    pub fn ASND_Pause(paused: s32);
}
extern "C" {
    #[doc = " \\brief Returns sound paused status.\n \\return 1 if paused, 0 if unpaused."]
    pub fn ASND_Is_Paused() -> s32;
}
extern "C" {
    #[doc = " \\brief Returns the global time.\n \\details The time is updated from the IRQ.\n \\return The current time, in milliseconds."]
    pub fn ASND_GetTime() -> u32_;
}
extern "C" {
    #[doc = " \\brief Retrieves the global sample counter.\n \\details This counter is updated from the IRQ in steps of ASND_GetSamplesPerTick().\n \\note You can use this to implement one timer with high precision.\n \\return Current sample."]
    pub fn ASND_GetSampleCounter() -> u32_;
}
extern "C" {
    #[doc = " \\brief Retrieves the samples sent from the IRQ in one tick.\n \\return Samples per tick."]
    pub fn ASND_GetSamplesPerTick() -> u32_;
}
extern "C" {
    #[doc = " \\brief Set the global time.\n \\details This time is updated from the IRQ.\n \\param[in] time Fix the current time, in milliseconds.\n \\return None."]
    pub fn ASND_SetTime(time: u32_);
}
extern "C" {
    #[doc = " \\brief Sets a global callback for general purposes.\n \\details This callback is called from the IRQ.\n \\param[in] callback Callback function to assign.\n \\return None."]
    pub fn ASND_SetCallback(callback: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " \\brief Returns the current audio rate.\n \\note This function is implemented for compatibility with SNDLIB.\n \\return Audio rate (48000)."]
    pub fn ASND_GetAudioRate() -> s32;
}
extern "C" {
    #[doc = " \\brief Sets a PCM voice to play.\n \\details This function stops one previous voice. Use ASND_StatusVoice() to test the status condition.\n \\note The voices are played in 16-bit stereo, regardless of the source format.<br><br>\n\n \\note \\a callback is used to implement a double buffer. When the second buffer is empty, the callback function is called with the voice number\n as an argument. You can use <tt>void <i>callback</i> (s32 voice)</tt> to call ASND_AddVoice() and add one voice to the second buffer. When the callback\n is non-NULL the, the voice never stops and returns SND_WAITING if successful on timeout condition.\n \\param[in] voice Voice slot to use for this sound; valid values are 0 to (MAX_SND_VOICES-1).\n \\param[in] format \\ref sndsetvoiceformats to use for this sound.\n \\param[in] pitch Frequency to use, in Hz.\n \\param[in] delay Delay to wait before playing this voice; value is in milliseconds.\n \\param[in] snd Buffer containing samples to play back; the buffer <b>must</b> be aligned and padded to 32 bytes!\n \\param[in] size_snd Size of the buffer samples, in bytes.\n \\param[in] volume_l \\ref voicevol of the left channel; value can be 0 - 255 inclusive.\n \\param[in] volume_r \\ref voicevol of the right channel; value can be 0 - 255 inclusive.\n \\param[in] callback Optional callback function to use; set to NULL for no callback. See the note above for details.\n \\return SND_OK or SND_INVALID."]
    pub fn ASND_SetVoice(
        voice: s32,
        format: s32,
        pitch: s32,
        delay: s32,
        snd: *mut ::libc::c_void,
        size_snd: s32,
        volume_l: s32,
        volume_r: s32,
        callback: ASNDVoiceCallback,
    ) -> s32;
}
extern "C" {
    #[doc = " \\brief Sets a PCM voice to play infinitely.\n \\note See ASND_SetVoice() for a detailed description, as it is largely identical."]
    pub fn ASND_SetInfiniteVoice(
        voice: s32,
        format: s32,
        pitch: s32,
        delay: s32,
        snd: *mut ::libc::c_void,
        size_snd: s32,
        volume_l: s32,
        volume_r: s32,
    ) -> s32;
}
extern "C" {
    #[doc = " \\brief Adds a PCM voice to play from the second buffer.\n \\note This function requires a call to ASND_SetVoice() and its subsequent return value to be a status other than SND_UNUSED prior to calling this one.\n \\param[in] voice Voice slot to attach this buffer to; value must be 0 to (MAX_SND_VOICES-1).\n \\param[in] snd Buffer containing the samples; it <b>must</b> be aligned and padded to 32 bytes AND have the same sample format as the first buffer.\n \\param[in] size_snd Size of the buffer samples, in bytes.\n \\return SND_OK or SND_INVALID; it may also return SND_BUSY if the second buffer is not empty and the voice cannot be added."]
    pub fn ASND_AddVoice(voice: s32, snd: *mut ::libc::c_void, size_snd: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Stops the selected voice.\n \\details If the voice is used in song mode, you need to assign the samples with ASND_SetSongSampleVoice() again. In this case, use ANS_PauseSongVoice()\n to stop the voice without loss of samples.\n \\param[in] voice Voice to stop, from 0 to (MAX_SND_VOICES-1).\n \\return SND_OK or SND_INVALID."]
    pub fn ASND_StopVoice(voice: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Pauses the selected voice.\n \\param[in] voice Voice to pause, from 0 to (MAX_SND_VOICES-1).\n \\return SND_OK or SND_INVALID."]
    pub fn ASND_PauseVoice(voice: s32, pause: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Returns the status of the selected voice.\n \\param[in] voice Voice slot to get the status from, from 0 to (MAX_SND_VOICES-1).\n \\return SND_INVALID if invalid, else a value from \\ref sndiavretvals."]
    pub fn ASND_StatusVoice(voice: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Returns the first unused voice.\n \\note Voice 0 is the last possible voice that can be returned. The idea is that this voice is reserved for a MOD/OGG/MP3/etc. player. With this in mind,\n you can use this function to determine that the rest of the voices are working if the return value is < 1.\n \\return SND_INVALID or the first free voice from 0 to (MAX_SND_VOICES-1)."]
    pub fn ASND_GetFirstUnusedVoice() -> s32;
}
extern "C" {
    #[doc = " \\brief Changes the voice pitch in real-time.\n \\details This function can be used to create audio effects such as Doppler effect emulation.\n \\param[in] voice Voice to change the pitch of, from 0 to (MAX_SND_VOICES-1).\n \\return SND_OK or SND_INVALID."]
    pub fn ASND_ChangePitchVoice(voice: s32, pitch: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Changes the voice volume in real-time.\n \\details This function can be used to create audio effects like distance attenuation.\n \\param[in] voice Voice to change the volume of, from 0 to (MAX_SND_VOICES-1).\n \\param[in] volume_l \\ref voicevol to set the left channel to, from 0 to 255.\n \\param[in] volume_r \\ref voicevol to set the right channel to, from 0 to 255.\n \\return SND_OK or SND_INVALID."]
    pub fn ASND_ChangeVolumeVoice(voice: s32, volume_l: s32, volume_r: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Returns the voice tick counter.\n \\details This value represents the number of ticks since this voice started to play, sans delay time. It uses the same resolution as the internal\n sound buffer. For example, if the lib is initialized with INIT_RATE_48000, a return value of 24000 is equal to 0.5 seconds. This value can be used, for\n example, to synchronize audio and video.\n \\note This function does not return error codes.\n \\param[in] voice Voice to retrieve the counter value from, from 0 to (MAX_SND_VOICES-1).\n \\return Number of ticks since this voice started playing."]
    pub fn ASND_GetTickCounterVoice(voice: s32) -> u32_;
}
extern "C" {
    #[doc = " \\brief Returns the voice playback time.\n \\details This value represents the time, in milliseconds, since this voice started playing, sans delay time. This value can be used, for example, to\n synchronize audio and video.\n \\note This function does not return error codes.\n \\param[in] voice Voice to retrieve the time value from, from 0 to (MAX_SND_VOICES-1).\n \\return Amount of time since this voice has started playing."]
    pub fn ASND_GetTimerVoice(voice: s32) -> u32_;
}
extern "C" {
    #[doc = " \\brief Tests if \\a pointer is in use by \\a voice as a buffer.\n \\param[in] voice Voice to test, from 0 to (MAX_SND_VOICES-1).\n \\param[in] pointer Address to test. This must be the same pointer sent to ASND_AddVoice() or ASND_SetVoice().\n \\return SND_INVALID if invalid\n \\return 0 if the pointer is unused\n \\return 1 if the pointer used as a buffer."]
    pub fn ASND_TestPointer(voice: s32, pointer: *mut ::libc::c_void) -> s32;
}
extern "C" {
    #[doc = " \\brief Tests to determine if the \\a voice is ready to receive a new buffer sample with ASND_AddVoice().\n \\details You can use this function to block a reader when double buffering is used. It works similarly to ASND_TestPointer() without needing to pass a\n pointer.\n \\param[in] voice Voice to test, from 0 to (MAX_SND_VOICES-1).\n \\return SND_INVALID\n \\return 0 if voice is NOT ready to receive a new voice.\n \\return 1 if voice is ready to receive a new voice with ASND_AddVoice()."]
    pub fn ASND_TestVoiceBufferReady(voice: s32) -> s32;
}
extern "C" {
    #[doc = " \\brief Returns the DSP usage.\n \\details The value is a percentage of DSP usage.\n \\return DSP usage, in percent."]
    pub fn ASND_GetDSP_PercentUse() -> u32_;
}
extern "C" {
    pub fn ASND_GetDSP_ProcessTime() -> u32_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aesndpb_t {
    _unused: [u8; 0],
}
pub type AESNDPB = aesndpb_t;
pub type AESNDVoiceCallbackArg = ::core::option::Option<
    unsafe extern "C" fn(pb: *mut AESNDPB, state: u32_, cbArg: *mut ::libc::c_void),
>;
pub type AESNDVoiceCallback =
    ::core::option::Option<unsafe extern "C" fn(pb: *mut AESNDPB, state: u32_)>;
pub type AESNDAudioCallbackArg = ::core::option::Option<
    unsafe extern "C" fn(audio_buffer: *mut ::libc::c_void, len: u32_, cbArg: *mut ::libc::c_void),
>;
pub type AESNDAudioCallback =
    ::core::option::Option<unsafe extern "C" fn(audio_buffer: *mut ::libc::c_void, len: u32_)>;
extern "C" {
    pub fn AESND_Init();
}
extern "C" {
    pub fn AESND_Reset();
}
extern "C" {
    pub fn AESND_Pause(pause: bool);
}
extern "C" {
    pub fn AESND_GetDSPProcessTime() -> u32_;
}
extern "C" {
    pub fn AESND_GetDSPProcessUsage() -> f32_;
}
extern "C" {
    pub fn AESND_RegisterAudioCallbackWithArg(
        cb: AESNDAudioCallbackArg,
        cbArg: *mut ::libc::c_void,
    ) -> AESNDAudioCallbackArg;
}
extern "C" {
    pub fn AESND_AllocateVoiceWithArg(
        cb: AESNDVoiceCallbackArg,
        cbArg: *mut ::libc::c_void,
    ) -> *mut AESNDPB;
}
extern "C" {
    pub fn AESND_FreeVoice(pb: *mut AESNDPB);
}
extern "C" {
    pub fn AESND_SetVoiceStop(pb: *mut AESNDPB, stop: bool);
}
extern "C" {
    pub fn AESND_SetVoiceMute(pb: *mut AESNDPB, mute: bool);
}
extern "C" {
    pub fn AESND_SetVoiceLoop(pb: *mut AESNDPB, loop_: bool);
}
extern "C" {
    pub fn AESND_SetVoiceFormat(pb: *mut AESNDPB, format: u32_);
}
extern "C" {
    pub fn AESND_SetVoiceStream(pb: *mut AESNDPB, stream: bool);
}
extern "C" {
    pub fn AESND_SetVoiceFrequency(pb: *mut AESNDPB, freq: f32_);
}
extern "C" {
    pub fn AESND_SetVoiceVolume(pb: *mut AESNDPB, volume_l: u16_, volume_r: u16_);
}
extern "C" {
    pub fn AESND_SetVoiceDelay(pb: *mut AESNDPB, delay: u32_);
}
extern "C" {
    pub fn AESND_SetVoiceBuffer(pb: *mut AESNDPB, buffer: *const ::libc::c_void, len: u32_);
}
extern "C" {
    pub fn AESND_PlayVoice(
        pb: *mut AESNDPB,
        format: u32_,
        buffer: *const ::libc::c_void,
        len: u32_,
        freq: f32_,
        delay: u32_,
        looped: bool,
    );
}
extern "C" {
    pub fn AESND_RegisterVoiceCallbackWithArg(
        pb: *mut AESNDPB,
        cb: AESNDVoiceCallbackArg,
        cbArg: *mut ::libc::c_void,
    ) -> AESNDVoiceCallbackArg;
}
extern "C" {
    pub static mad_version: [s8; 0usize];
}
extern "C" {
    pub static mad_copyright: [s8; 0usize];
}
extern "C" {
    pub static mad_author: [s8; 0usize];
}
extern "C" {
    pub static mad_build: [s8; 0usize];
}
pub type mad_fixed_t = s32;
pub type mad_fixed64hi_t = s32;
pub type mad_fixed64lo_t = u32_;
pub type mad_sample_t = mad_fixed_t;
extern "C" {
    pub fn mad_f_abs(arg1: mad_fixed_t) -> mad_fixed_t;
}
extern "C" {
    pub fn mad_f_div(arg1: mad_fixed_t, arg2: mad_fixed_t) -> mad_fixed_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_bitptr {
    pub byte: *const u8_,
    pub cache: u16_,
    pub left: u16_,
}
extern "C" {
    pub fn mad_bit_init(arg1: *mut mad_bitptr, arg2: *const u8_);
}
extern "C" {
    pub fn mad_bit_length(arg1: *const mad_bitptr, arg2: *const mad_bitptr) -> u32_;
}
extern "C" {
    pub fn mad_bit_nextbyte(arg1: *const mad_bitptr) -> *const u8_;
}
extern "C" {
    pub fn mad_bit_skip(arg1: *mut mad_bitptr, arg2: u32_);
}
extern "C" {
    pub fn mad_bit_read(arg1: *mut mad_bitptr, arg2: u32_) -> u32_;
}
extern "C" {
    pub fn mad_bit_write(arg1: *mut mad_bitptr, arg2: u32_, arg3: u32_);
}
extern "C" {
    pub fn mad_bit_crc(arg1: mad_bitptr, arg2: u32_, arg3: u16_) -> u16_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_timer_t {
    pub seconds: ::libc::c_long,
    pub fraction: u32_,
}
extern "C" {
    pub static mad_timer_zero: mad_timer_t;
}
pub const MAD_UNITS_HOURS: mad_units = -2;
pub const MAD_UNITS_MINUTES: mad_units = -1;
pub const MAD_UNITS_SECONDS: mad_units = 0;
pub const MAD_UNITS_DECISECONDS: mad_units = 10;
pub const MAD_UNITS_CENTISECONDS: mad_units = 100;
pub const MAD_UNITS_MILLISECONDS: mad_units = 1000;
pub const MAD_UNITS_8000_HZ: mad_units = 8000;
pub const MAD_UNITS_11025_HZ: mad_units = 11025;
pub const MAD_UNITS_12000_HZ: mad_units = 12000;
pub const MAD_UNITS_16000_HZ: mad_units = 16000;
pub const MAD_UNITS_22050_HZ: mad_units = 22050;
pub const MAD_UNITS_24000_HZ: mad_units = 24000;
pub const MAD_UNITS_32000_HZ: mad_units = 32000;
pub const MAD_UNITS_44100_HZ: mad_units = 44100;
pub const MAD_UNITS_48000_HZ: mad_units = 48000;
pub const MAD_UNITS_24_FPS: mad_units = 24;
pub const MAD_UNITS_25_FPS: mad_units = 25;
pub const MAD_UNITS_30_FPS: mad_units = 30;
pub const MAD_UNITS_48_FPS: mad_units = 48;
pub const MAD_UNITS_50_FPS: mad_units = 50;
pub const MAD_UNITS_60_FPS: mad_units = 60;
pub const MAD_UNITS_75_FPS: mad_units = 75;
pub const MAD_UNITS_23_976_FPS: mad_units = -24;
pub const MAD_UNITS_24_975_FPS: mad_units = -25;
pub const MAD_UNITS_29_97_FPS: mad_units = -30;
pub const MAD_UNITS_47_952_FPS: mad_units = -48;
pub const MAD_UNITS_49_95_FPS: mad_units = -50;
pub const MAD_UNITS_59_94_FPS: mad_units = -60;
pub type mad_units = ::libc::c_int;
extern "C" {
    pub fn mad_timer_compare(arg1: mad_timer_t, arg2: mad_timer_t) -> s32;
}
extern "C" {
    pub fn mad_timer_negate(arg1: *mut mad_timer_t);
}
extern "C" {
    pub fn mad_timer_abs(arg1: mad_timer_t) -> mad_timer_t;
}
extern "C" {
    pub fn mad_timer_set(arg1: *mut mad_timer_t, arg2: u32_, arg3: u32_, arg4: u32_);
}
extern "C" {
    pub fn mad_timer_add(arg1: *mut mad_timer_t, arg2: mad_timer_t);
}
extern "C" {
    pub fn mad_timer_multiply(arg1: *mut mad_timer_t, arg2: ::libc::c_long);
}
extern "C" {
    pub fn mad_timer_count(arg1: mad_timer_t, arg2: mad_units) -> ::libc::c_long;
}
extern "C" {
    pub fn mad_timer_fraction(arg1: mad_timer_t, arg2: u32_) -> u32_;
}
extern "C" {
    pub fn mad_timer_string(
        arg1: mad_timer_t,
        arg2: *mut s8,
        arg3: *const s8,
        arg4: mad_units,
        arg5: mad_units,
        arg6: u32_,
    );
}
pub const MAD_ERROR_NONE: mad_error = 0;
pub const MAD_ERROR_BUFLEN: mad_error = 1;
pub const MAD_ERROR_BUFPTR: mad_error = 2;
pub const MAD_ERROR_NOMEM: mad_error = 49;
pub const MAD_ERROR_LOSTSYNC: mad_error = 257;
pub const MAD_ERROR_BADLAYER: mad_error = 258;
pub const MAD_ERROR_BADBITRATE: mad_error = 259;
pub const MAD_ERROR_BADSAMPLERATE: mad_error = 260;
pub const MAD_ERROR_BADEMPHASIS: mad_error = 261;
pub const MAD_ERROR_BADCRC: mad_error = 513;
pub const MAD_ERROR_BADBITALLOC: mad_error = 529;
pub const MAD_ERROR_BADSCALEFACTOR: mad_error = 545;
pub const MAD_ERROR_BADFRAMELEN: mad_error = 561;
pub const MAD_ERROR_BADBIGVALUES: mad_error = 562;
pub const MAD_ERROR_BADBLOCKTYPE: mad_error = 563;
pub const MAD_ERROR_BADSCFSI: mad_error = 564;
pub const MAD_ERROR_BADDATAPTR: mad_error = 565;
pub const MAD_ERROR_BADPART3LEN: mad_error = 566;
pub const MAD_ERROR_BADHUFFTABLE: mad_error = 567;
pub const MAD_ERROR_BADHUFFDATA: mad_error = 568;
pub const MAD_ERROR_BADSTEREO: mad_error = 569;
pub type mad_error = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_stream {
    pub buffer: *const u8_,
    pub bufend: *const u8_,
    pub skiplen: u32_,
    pub sync: s32,
    pub freerate: u32_,
    pub this_frame: *const u8_,
    pub next_frame: *const u8_,
    pub ptr: mad_bitptr,
    pub anc_ptr: mad_bitptr,
    pub anc_bitlen: u32_,
    pub main_data: *mut [u8_; 2567usize],
    pub md_len: u32_,
    pub options: s32,
    pub error: mad_error,
}
pub const MAD_OPTION_IGNORECRC: _bindgen_ty_14 = 1;
pub const MAD_OPTION_HALFSAMPLERATE: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::libc::c_uint;
extern "C" {
    pub fn mad_stream_init(arg1: *mut mad_stream);
}
extern "C" {
    pub fn mad_stream_finish(arg1: *mut mad_stream);
}
extern "C" {
    pub fn mad_stream_buffer(arg1: *mut mad_stream, arg2: *const u8_, arg3: u32_);
}
extern "C" {
    pub fn mad_stream_skip(arg1: *mut mad_stream, arg2: u32_);
}
extern "C" {
    pub fn mad_stream_sync(arg1: *mut mad_stream) -> s32;
}
extern "C" {
    pub fn mad_stream_errorstr(arg1: *const mad_stream) -> *const s8;
}
pub const MAD_LAYER_I: mad_layer = 1;
pub const MAD_LAYER_II: mad_layer = 2;
pub const MAD_LAYER_III: mad_layer = 3;
pub type mad_layer = ::libc::c_uint;
pub const MAD_MODE_SINGLE_CHANNEL: mad_mode = 0;
pub const MAD_MODE_DUAL_CHANNEL: mad_mode = 1;
pub const MAD_MODE_JOINT_STEREO: mad_mode = 2;
pub const MAD_MODE_STEREO: mad_mode = 3;
pub type mad_mode = ::libc::c_uint;
pub const MAD_EMPHASIS_NONE: mad_emphasis = 0;
pub const MAD_EMPHASIS_50_15_US: mad_emphasis = 1;
pub const MAD_EMPHASIS_CCITT_J_17: mad_emphasis = 3;
pub const MAD_EMPHASIS_RESERVED: mad_emphasis = 2;
pub type mad_emphasis = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_header {
    pub layer: mad_layer,
    pub mode: mad_mode,
    pub mode_extension: s32,
    pub emphasis: mad_emphasis,
    pub bitrate: u32_,
    pub samplerate: u32_,
    pub crc_check: u16_,
    pub crc_target: u16_,
    pub flags: s32,
    pub private_bits: s32,
    pub duration: mad_timer_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_frame {
    pub header: mad_header,
    pub options: s32,
    pub sbsample: [[[mad_fixed_t; 32usize]; 36usize]; 2usize],
    pub overlap: *mut [[[mad_fixed_t; 18usize]; 32usize]; 2usize],
}
pub const MAD_FLAG_NPRIVATE_III: _bindgen_ty_15 = 7;
pub const MAD_FLAG_INCOMPLETE: _bindgen_ty_15 = 8;
pub const MAD_FLAG_PROTECTION: _bindgen_ty_15 = 16;
pub const MAD_FLAG_COPYRIGHT: _bindgen_ty_15 = 32;
pub const MAD_FLAG_ORIGINAL: _bindgen_ty_15 = 64;
pub const MAD_FLAG_PADDING: _bindgen_ty_15 = 128;
pub const MAD_FLAG_I_STEREO: _bindgen_ty_15 = 256;
pub const MAD_FLAG_MS_STEREO: _bindgen_ty_15 = 512;
pub const MAD_FLAG_FREEFORMAT: _bindgen_ty_15 = 1024;
pub const MAD_FLAG_LSF_EXT: _bindgen_ty_15 = 4096;
pub const MAD_FLAG_MC_EXT: _bindgen_ty_15 = 8192;
pub const MAD_FLAG_MPEG_2_5_EXT: _bindgen_ty_15 = 16384;
pub type _bindgen_ty_15 = ::libc::c_uint;
pub const MAD_PRIVATE_HEADER: _bindgen_ty_16 = 256;
pub const MAD_PRIVATE_III: _bindgen_ty_16 = 31;
pub type _bindgen_ty_16 = ::libc::c_uint;
extern "C" {
    pub fn mad_header_init(arg1: *mut mad_header);
}
extern "C" {
    pub fn mad_header_decode(arg1: *mut mad_header, arg2: *mut mad_stream) -> s32;
}
extern "C" {
    pub fn mad_frame_init(arg1: *mut mad_frame);
}
extern "C" {
    pub fn mad_frame_finish(arg1: *mut mad_frame);
}
extern "C" {
    pub fn mad_frame_decode(arg1: *mut mad_frame, arg2: *mut mad_stream) -> s32;
}
extern "C" {
    pub fn mad_frame_mute(arg1: *mut mad_frame);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_pcm {
    pub samplerate: u32_,
    pub channels: u16_,
    pub length: u16_,
    pub samples: [[mad_fixed_t; 1152usize]; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_synth {
    pub filter: [[[[[mad_fixed_t; 8usize]; 16usize]; 2usize]; 2usize]; 2usize],
    pub phase: u32_,
    pub pcm: mad_pcm,
}
pub const MAD_PCM_CHANNEL_SINGLE: _bindgen_ty_17 = 0;
pub type _bindgen_ty_17 = ::libc::c_uint;
pub const MAD_PCM_CHANNEL_DUAL_1: _bindgen_ty_18 = 0;
pub const MAD_PCM_CHANNEL_DUAL_2: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::libc::c_uint;
pub const MAD_PCM_CHANNEL_STEREO_LEFT: _bindgen_ty_19 = 0;
pub const MAD_PCM_CHANNEL_STEREO_RIGHT: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::libc::c_uint;
extern "C" {
    pub fn mad_synth_init(arg1: *mut mad_synth);
}
extern "C" {
    pub fn mad_synth_mute(arg1: *mut mad_synth);
}
extern "C" {
    pub fn mad_synth_frame(arg1: *mut mad_synth, arg2: *const mad_frame);
}
pub const MAD_DECODER_MODE_SYNC: mad_decoder_mode = 0;
pub const MAD_DECODER_MODE_ASYNC: mad_decoder_mode = 1;
pub type mad_decoder_mode = ::libc::c_uint;
pub const MAD_FLOW_CONTINUE: mad_flow = 0;
pub const MAD_FLOW_STOP: mad_flow = 16;
pub const MAD_FLOW_BREAK: mad_flow = 17;
pub const MAD_FLOW_IGNORE: mad_flow = 32;
pub type mad_flow = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_decoder {
    pub mode: mad_decoder_mode,
    pub options: s32,
    pub async_: mad_decoder__bindgen_ty_1,
    pub sync: *mut mad_decoder__bindgen_ty_2,
    pub cb_data: *mut ::libc::c_void,
    pub input_func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *mut mad_stream) -> mad_flow,
    >,
    pub header_func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *const mad_header) -> mad_flow,
    >,
    pub filter_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *const mad_stream,
            arg3: *mut mad_frame,
        ) -> mad_flow,
    >,
    pub output_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *const mad_header,
            arg3: *mut mad_pcm,
        ) -> mad_flow,
    >,
    pub error_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *mut mad_stream,
            arg3: *mut mad_frame,
        ) -> mad_flow,
    >,
    pub message_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *mut ::libc::c_void,
            arg3: *mut u32_,
        ) -> mad_flow,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_decoder__bindgen_ty_1 {
    pub pid: ::libc::c_long,
    pub in_: s32,
    pub out: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_decoder__bindgen_ty_2 {
    pub stream: mad_stream,
    pub frame: mad_frame,
    pub synth: mad_synth,
}
extern "C" {
    pub fn mad_decoder_init(
        arg1: *mut mad_decoder,
        arg2: *mut ::libc::c_void,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *mut mad_stream) -> mad_flow,
        >,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *const mad_header) -> mad_flow,
        >,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const mad_stream,
                arg3: *mut mad_frame,
            ) -> mad_flow,
        >,
        arg6: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const mad_header,
                arg3: *mut mad_pcm,
            ) -> mad_flow,
        >,
        arg7: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *mut mad_stream,
                arg3: *mut mad_frame,
            ) -> mad_flow,
        >,
        arg8: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *mut ::libc::c_void,
                arg3: *mut u32_,
            ) -> mad_flow,
        >,
    );
}
extern "C" {
    pub fn mad_decoder_finish(arg1: *mut mad_decoder) -> s32;
}
extern "C" {
    pub fn mad_decoder_run(arg1: *mut mad_decoder, arg2: mad_decoder_mode) -> s32;
}
extern "C" {
    pub fn mad_decoder_message(
        arg1: *mut mad_decoder,
        arg2: *mut ::libc::c_void,
        arg3: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn MP3Player_Init();
}
extern "C" {
    pub fn MP3Player_Stop();
}
extern "C" {
    pub fn MP3Player_IsPlaying() -> bool;
}
extern "C" {
    pub fn MP3Player_Volume(volume: u32_);
}
extern "C" {
    pub fn MP3Player_PlayBuffer(
        buffer: *const ::libc::c_void,
        len: s32,
        filterfunc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut mad_stream, arg2: *mut mad_frame),
        >,
    ) -> s32;
}
extern "C" {
    pub fn MP3Player_PlayFile(
        cb_data: *mut ::libc::c_void,
        reader: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *mut ::libc::c_void,
                arg3: s32,
            ) -> s32,
        >,
        filterfunc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut mad_stream, arg2: *mut mad_frame),
        >,
    ) -> s32;
}
pub const WIIUSE_IR_ABOVE: ir_position_t = 0;
pub const WIIUSE_IR_BELOW: ir_position_t = 1;
pub type ir_position_t = ::libc::c_uint;
pub type ubyte = ::libc::c_uchar;
pub type sbyte = ::libc::c_char;
pub type uword = ::libc::c_ushort;
pub type sword = ::libc::c_short;
pub type sint = ::libc::c_char;
#[doc = "      @brief Callback that handles a read event.\n\n      @param wm               Pointer to a wiimote_t structure.\n      @param data             Pointer to the filled data block.\n      @param len              Length in bytes of the data block.\n\n      @see wiiuse_init()\n\n      A registered function of this type is called automatically by the wiiuse\n      library when the wiimote has returned the full data requested by a previous\n      call to wiiuse_read_data()."]
pub type wiiuse_data_cb = ::core::option::Option<
    unsafe extern "C" fn(wm: *mut wiimote_t, data: *mut ubyte, len: ::libc::c_ushort),
>;
pub const REQ_READY: data_req_s = 0;
pub const REQ_SENT: data_req_s = 1;
pub const REQ_DONE: data_req_s = 2;
pub type data_req_s = ::libc::c_uint;
#[doc = "\t@struct data_req_t\n\t@brief Data read request structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct data_req_t {
    pub node: lwp_node,
    #[doc = "< buffer where read data is written"]
    pub data: [ubyte; 48usize],
    pub len: ::libc::c_uint,
    #[doc = "< set to 1 if not using callback and needs to be cleaned up"]
    pub state: data_req_s,
    #[doc = "< read data callback"]
    pub cb: wiiuse_data_cb,
    pub next: *mut data_req_t,
}
pub type cmd_blk_cb =
    ::core::option::Option<unsafe extern "C" fn(wm: *mut wiimote_t, data: *mut ubyte, len: uword)>;
pub const CMD_READY: cmd_blk_s = 0;
pub const CMD_SENT: cmd_blk_s = 1;
pub const CMD_DONE: cmd_blk_s = 2;
pub type cmd_blk_s = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_blk_t {
    pub node: lwp_node,
    pub data: [ubyte; 48usize],
    pub len: uint,
    pub state: cmd_blk_s,
    pub cb: cmd_blk_cb,
    pub next: *mut cmd_blk_t,
}
#[doc = "\t@struct vec2b_t\n\t@brief Unsigned x,y byte vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec2b_t {
    pub x: ubyte,
    pub y: ubyte,
}
#[doc = "\t@struct vec3b_t\n\t@brief Unsigned x,y,z byte vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec3b_t {
    pub x: ubyte,
    pub y: ubyte,
    pub z: ubyte,
}
#[doc = "\t@struct vec3b_t\n\t@brief Unsigned x,y,z byte vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec3w_t {
    pub x: uword,
    pub y: uword,
    pub z: uword,
}
#[doc = "\t@struct vec3f_t\n\t@brief Signed x,y,z float struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec3f_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[doc = "\t@struct orient_t\n\t@brief Orientation struct.\n\n\tYaw, pitch, and roll range from -180 to 180 degrees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct orient_t {
    #[doc = "< roll, this may be smoothed if enabled"]
    pub roll: f32,
    #[doc = "< pitch, this may be smoothed if enabled"]
    pub pitch: f32,
    pub yaw: f32,
    #[doc = "< absolute roll, unsmoothed"]
    pub a_roll: f32,
    #[doc = "< absolute pitch, unsmoothed"]
    pub a_pitch: f32,
}
#[doc = "\t@struct gforce_t\n\t@brief Gravity force struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gforce_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[doc = "\t@struct accel_t\n\t@brief Accelerometer struct. For any device with an accelerometer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accel_t {
    #[doc = "< zero calibration"]
    pub cal_zero: vec3w_t,
    #[doc = "< 1g difference around 0cal"]
    pub cal_g: vec3w_t,
    #[doc = "< last smoothed roll value"]
    pub st_roll: f32,
    #[doc = "< last smoothed roll pitch"]
    pub st_pitch: f32,
    #[doc = "< alpha value for smoothing [0-1]"]
    pub st_alpha: f32,
}
#[doc = "\t@struct ir_dot_t\n\t@brief A single IR source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_dot_t {
    #[doc = "< if the IR source is visible"]
    pub visible: ubyte,
    #[doc = "< raw X coordinate (0-1023)"]
    pub rx: ::libc::c_short,
    #[doc = "< raw Y coordinate (0-767)"]
    pub ry: ::libc::c_short,
    #[doc = "< size of the IR dot (0-15)"]
    pub size: ubyte,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdot_t {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sb_t {
    pub dots: [fdot_t; 2usize],
    pub acc_dots: [fdot_t; 2usize],
    pub rot_dots: [fdot_t; 2usize],
    pub angle: f32,
    pub off_angle: f32,
    pub score: f32,
}
pub const WIIUSE_ASPECT_4_3: aspect_t = 0;
pub const WIIUSE_ASPECT_16_9: aspect_t = 1;
#[doc = "\t@enum aspect_t\n\t@brief Screen aspect ratio."]
pub type aspect_t = ::libc::c_uint;
#[doc = "\t@struct ir_t\n\t@brief IR struct. Hold all data related to the IR tracking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_t {
    #[doc = "< IR dots"]
    pub dot: [ir_dot_t; 4usize],
    #[doc = "< number of dots at this time"]
    pub num_dots: ubyte,
    #[doc = "< keeps track of the IR state"]
    pub state: ::libc::c_int,
    #[doc = "< is the raw position valid?"]
    pub raw_valid: ::libc::c_int,
    #[doc = "< sensor bar, detected or guessed"]
    pub sensorbar: sb_t,
    #[doc = "< raw X coordinate"]
    pub ax: f32,
    #[doc = "< raw Y coordinate"]
    pub ay: f32,
    #[doc = "< pixel width of the sensor bar"]
    pub distance: f32,
    #[doc = "< calculated distance in meters"]
    pub z: f32,
    #[doc = "< angle of the wiimote to the sensor bar"]
    pub angle: f32,
    #[doc = "< is the smoothed position valid?"]
    pub smooth_valid: ::libc::c_int,
    #[doc = "< smoothed X coordinate"]
    pub sx: f32,
    #[doc = "< smoothed Y coordinate"]
    pub sy: f32,
    #[doc = "< error count, for smoothing algorithm"]
    pub error_cnt: f32,
    #[doc = "< glitch count, same"]
    pub glitch_cnt: f32,
    #[doc = "< is the bounded position valid?"]
    pub valid: ::libc::c_int,
    #[doc = "< bounded X coordinate"]
    pub x: f32,
    #[doc = "< bounded Y coordinate"]
    pub y: f32,
    #[doc = "< aspect ratio of the screen"]
    pub aspect: aspect_t,
    #[doc = "< IR sensor bar position"]
    pub pos: ir_position_t,
    #[doc = "< IR virtual screen resolution"]
    pub vres: [::libc::c_uint; 2usize],
    #[doc = "< IR XY correction offset"]
    pub offset: [::libc::c_int; 2usize],
}
#[doc = "\t@struct joystick_t\n\t@brief Joystick calibration structure.\n\n\tThe angle \\a ang is relative to the positive y-axis into quadrant I\n\tand ranges from 0 to 360 degrees.  So if the joystick is held straight\n\tupwards then angle is 0 degrees.  If it is held to the right it is 90,\n\tdown is 180, and left is 270.\n\n\tThe magnitude \\a mag is the distance from the center to where the\n\tjoystick is being held.  The magnitude ranges from 0 to 1.\n\tIf the joystick is only slightly tilted from the center the magnitude\n\twill be low, but if it is closer to the outter edge the value will\n\tbe higher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct joystick_t {
    #[doc = "< maximum joystick values"]
    pub max: vec2b_t,
    #[doc = "< minimum joystick values"]
    pub min: vec2b_t,
    #[doc = "< center joystick values"]
    pub center: vec2b_t,
    #[doc = "< raw position values"]
    pub pos: vec2b_t,
    #[doc = "< angle the joystick is being held"]
    pub ang: f32,
    #[doc = "< magnitude of the joystick (range 0-1)"]
    pub mag: f32,
}
#[doc = "\t@struct nunchuk_t\n\t@brief Nunchuk expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nunchuk_t {
    #[doc = "< nunchuk accelerometer calibration"]
    pub accel_calib: accel_t,
    #[doc = "< joystick calibration"]
    pub js: joystick_t,
    #[doc = "< options flag (points to wiimote_t.flags)"]
    pub flags: *mut ::libc::c_int,
    #[doc = "< what buttons have just been pressed"]
    pub btns: ubyte,
    #[doc = "< what buttons have just been pressed"]
    pub btns_last: ubyte,
    #[doc = "< what buttons are being held down"]
    pub btns_held: ubyte,
    #[doc = "< what buttons were just released this"]
    pub btns_released: ubyte,
    #[doc = "< current raw acceleration data"]
    pub accel: vec3w_t,
    #[doc = "< current orientation on each axis"]
    pub orient: orient_t,
    #[doc = "< current gravity forces on each axis"]
    pub gforce: gforce_t,
}
#[doc = "\t@struct classic_ctrl_t\n\t@brief Classic controller expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct classic_ctrl_t {
    #[doc = "< what buttons have just been pressed"]
    pub btns: ::libc::c_short,
    #[doc = "< what buttons have just been pressed"]
    pub btns_last: ::libc::c_short,
    #[doc = "< what buttons are being held down"]
    pub btns_held: ::libc::c_short,
    #[doc = "< what buttons were just released this"]
    pub btns_released: ::libc::c_short,
    pub rs_raw: ubyte,
    pub ls_raw: ubyte,
    #[doc = "< right shoulder button (range 0-1)"]
    pub r_shoulder: f32,
    #[doc = "< left shoulder button (range 0-1)"]
    pub l_shoulder: f32,
    #[doc = "< left joystick calibration"]
    pub ljs: joystick_t,
    #[doc = "< right joystick calibration"]
    pub rjs: joystick_t,
    #[doc = "< original, pro, wiiu pro"]
    pub type_: ubyte,
}
#[doc = "\t@struct guitar_hero_3_t\n\t@brief Guitar Hero 3 expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct guitar_hero_3_t {
    #[doc = "< what buttons have just been pressed"]
    pub btns: ::libc::c_short,
    #[doc = "< what buttons have just been pressed"]
    pub btns_last: ::libc::c_short,
    #[doc = "< what buttons are being held down"]
    pub btns_held: ::libc::c_short,
    #[doc = "< what buttons were just released this"]
    pub btns_released: ::libc::c_short,
    pub wb_raw: ubyte,
    #[doc = "< whammy bar (range 0-1)"]
    pub whammy_bar: f32,
    pub tb_raw: ubyte,
    #[doc = "< touch bar"]
    pub touch_bar: ::libc::c_int,
    #[doc = "< joystick calibration"]
    pub js: joystick_t,
}
#[doc = " @struct wii_board_t\n @brief Wii Balance Board expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wii_board_t {
    pub tl: f32,
    pub tr: f32,
    pub bl: f32,
    pub br: f32,
    pub rtl: ::libc::c_short,
    pub rtr: ::libc::c_short,
    pub rbl: ::libc::c_short,
    pub rbr: ::libc::c_short,
    pub ctl: [::libc::c_short; 3usize],
    pub ctr: [::libc::c_short; 3usize],
    pub cbl: [::libc::c_short; 3usize],
    pub cbr: [::libc::c_short; 3usize],
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct motion_plus_t {
    pub rx: ::libc::c_short,
    pub ry: ::libc::c_short,
    pub rz: ::libc::c_short,
    pub status: ubyte,
    pub ext: ubyte,
}
#[doc = "\t@struct expansion_t\n\t@brief Generic expansion device plugged into wiimote."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expansion_t {
    #[doc = "< type of expansion attached"]
    pub type_: ::libc::c_int,
    pub __bindgen_anon_1: expansion_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expansion_t__bindgen_ty_1 {
    pub nunchuk: __BindgenUnionField<nunchuk_t>,
    pub classic: __BindgenUnionField<classic_ctrl_t>,
    pub gh3: __BindgenUnionField<guitar_hero_3_t>,
    pub wb: __BindgenUnionField<wii_board_t>,
    pub mp: __BindgenUnionField<motion_plus_t>,
    pub bindgen_union_field: [u32; 22usize],
}
pub const WIIUSE_STACK_UNKNOWN: win_bt_stack_t = 0;
pub const WIIUSE_STACK_MS: win_bt_stack_t = 1;
pub const WIIUSE_STACK_BLUESOLEIL: win_bt_stack_t = 2;
#[doc = "\t@enum win32_bt_stack_t\n\t@brief\tAvailable bluetooth stacks for Windows."]
pub type win_bt_stack_t = ::libc::c_uint;
#[doc = "\t@struct wiimote_state_t\n\t@brief Significant data from the previous event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiimote_state_t {
    pub btns: ::libc::c_ushort,
    pub ir: ir_t,
    pub accel: vec3w_t,
    pub exp: expansion_t,
}
pub const WIIUSE_NONE: WIIUSE_EVENT_TYPE = 0;
pub const WIIUSE_EVENT: WIIUSE_EVENT_TYPE = 1;
pub const WIIUSE_STATUS: WIIUSE_EVENT_TYPE = 2;
pub const WIIUSE_CONNECT: WIIUSE_EVENT_TYPE = 3;
pub const WIIUSE_DISCONNECT: WIIUSE_EVENT_TYPE = 4;
pub const WIIUSE_UNEXPECTED_DISCONNECT: WIIUSE_EVENT_TYPE = 5;
pub const WIIUSE_READ_DATA: WIIUSE_EVENT_TYPE = 6;
pub const WIIUSE_ACK: WIIUSE_EVENT_TYPE = 7;
pub const WIIUSE_NUNCHUK_INSERTED: WIIUSE_EVENT_TYPE = 8;
pub const WIIUSE_NUNCHUK_REMOVED: WIIUSE_EVENT_TYPE = 9;
pub const WIIUSE_CLASSIC_CTRL_INSERTED: WIIUSE_EVENT_TYPE = 10;
pub const WIIUSE_CLASSIC_CTRL_REMOVED: WIIUSE_EVENT_TYPE = 11;
pub const WIIUSE_GUITAR_HERO_3_CTRL_INSERTED: WIIUSE_EVENT_TYPE = 12;
pub const WIIUSE_GUITAR_HERO_3_CTRL_REMOVED: WIIUSE_EVENT_TYPE = 13;
pub const WIIUSE_WII_BOARD_INSERTED: WIIUSE_EVENT_TYPE = 14;
pub const WIIUSE_WII_BOARD_REMOVED: WIIUSE_EVENT_TYPE = 15;
pub const WIIUSE_MOTION_PLUS_ACTIVATED: WIIUSE_EVENT_TYPE = 16;
pub const WIIUSE_MOTION_PLUS_REMOVED: WIIUSE_EVENT_TYPE = 17;
#[doc = "\t@enum WIIUSE_EVENT_TYPE\n\t@brief Events that wiiuse can generate from a poll."]
pub type WIIUSE_EVENT_TYPE = ::libc::c_uint;
#[doc = "\t@struct wiimote_t\n\t@brief Wiimote structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiimote_t {
    #[doc = "< user specified id"]
    pub unid: ::libc::c_int,
    #[doc = "< various state flags"]
    pub state: ::libc::c_int,
    #[doc = "< currently lit leds"]
    pub leds: ubyte,
    #[doc = "< battery level"]
    pub battery_level: f32,
    #[doc = "< options flag"]
    pub flags: ::libc::c_int,
    #[doc = "< the state of the connection handshake"]
    pub handshake_state: ubyte,
    #[doc = "< the state of the expansion handshake"]
    pub expansion_state: ubyte,
    #[doc = "< list of data read requests"]
    pub data_req: *const data_req_t,
    pub cmd_head: *const cmd_blk_t,
    pub cmd_tail: *const cmd_blk_t,
    #[doc = "< wiimote accelerometer calibration"]
    pub accel_calib: accel_t,
    #[doc = "< wiimote expansion device"]
    pub exp: expansion_t,
    #[doc = "< current raw acceleration data"]
    pub accel: vec3w_t,
    #[doc = "< current orientation on each axis"]
    pub orient: orient_t,
    #[doc = "< current gravity forces on each axis"]
    pub gforce: gforce_t,
    #[doc = "< IR data"]
    pub ir: ir_t,
    #[doc = "< what buttons are down"]
    pub btns: ::libc::c_ushort,
    #[doc = "< what buttons were down before"]
    pub btns_last: ::libc::c_ushort,
    #[doc = "< what buttons are and were held down"]
    pub btns_held: ::libc::c_ushort,
    #[doc = "< what buttons were just released"]
    pub btns_released: ::libc::c_ushort,
    #[doc = "< last saved state"]
    pub lstate: wiimote_state_t,
    #[doc = "< type of event that occured"]
    pub event: WIIUSE_EVENT_TYPE,
    #[doc = "< event buffer"]
    pub event_buf: [ubyte; 32usize],
    pub motion_plus_id: [ubyte; 6usize],
}
#[doc = "\t@struct wiimote_t\n\t@brief Wiimote structure."]
pub type wiimote = wiimote_t;
extern "C" {
    pub fn wiiuse_version() -> *const ::libc::c_char;
}
extern "C" {
    pub fn wiiuse_init(wiimotes: ::libc::c_int) -> *mut *mut wiimote_t;
}
extern "C" {
    pub fn wiiuse_disconnected(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_cleanup(wm: *mut *mut wiimote_t, wiimotes: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_rumble(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_toggle_rumble(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_set_leds(wm: *mut wiimote_t, leds: ::libc::c_int, cb: cmd_blk_cb);
}
extern "C" {
    pub fn wiiuse_motion_sensing(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_read_data(
        wm: *mut wiimote_t,
        buffer: *mut ubyte,
        offset: ::libc::c_uint,
        len: ::libc::c_ushort,
        cb: cmd_blk_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_write_data(
        wm: *mut wiimote_t,
        addr: ::libc::c_uint,
        data: *mut ubyte,
        len: ubyte,
        cb: cmd_blk_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_status(wm: *mut wiimote_t, cb: cmd_blk_cb);
}
extern "C" {
    pub fn wiiuse_get_by_id(
        wm: *mut *mut wiimote_t,
        wiimotes: ::libc::c_int,
        unid: ::libc::c_int,
    ) -> *mut wiimote_t;
}
extern "C" {
    pub fn wiiuse_set_flags(
        wm: *mut wiimote_t,
        enable: ::libc::c_int,
        disable: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_set_smooth_alpha(wm: *mut wiimote_t, alpha: f32) -> f32;
}
extern "C" {
    pub fn wiiuse_set_bluetooth_stack(
        wm: *mut *mut wiimote_t,
        wiimotes: ::libc::c_int,
        type_: win_bt_stack_t,
    );
}
extern "C" {
    pub fn wiiuse_resync(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_set_timeout(
        wm: *mut *mut wiimote_t,
        wiimotes: ::libc::c_int,
        normal_timeout: ubyte,
        exp_timeout: ubyte,
    );
}
extern "C" {
    pub fn wiiuse_write_streamdata(
        wm: *mut wiimote_t,
        data: *mut ubyte,
        len: ubyte,
        cb: cmd_blk_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_find(
        wm: *mut *mut wiimote_t,
        max_wiimotes: ::libc::c_int,
        timeout: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_connect(wm: *mut *mut wiimote_t, wiimotes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_disconnect(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_poll(wm: *mut *mut wiimote_t, wiimotes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_set_ir_mode(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_set_ir(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_set_ir_vres(wm: *mut wiimote_t, x: ::libc::c_uint, y: ::libc::c_uint);
}
extern "C" {
    pub fn wiiuse_set_ir_position(wm: *mut wiimote_t, pos: ir_position_t);
}
extern "C" {
    pub fn wiiuse_set_aspect_ratio(wm: *mut wiimote_t, aspect: aspect_t);
}
extern "C" {
    pub fn wiiuse_set_ir_sensitivity(wm: *mut wiimote_t, level: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_set_motion_plus(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_set_speaker(wm: *mut wiimote_t, status: ::libc::c_int);
}
pub const WPAD_CHAN_ALL: _bindgen_ty_20 = -1;
pub const WPAD_CHAN_0: _bindgen_ty_20 = 0;
pub const WPAD_CHAN_1: _bindgen_ty_20 = 1;
pub const WPAD_CHAN_2: _bindgen_ty_20 = 2;
pub const WPAD_CHAN_3: _bindgen_ty_20 = 3;
pub const WPAD_BALANCE_BOARD: _bindgen_ty_20 = 4;
pub const WPAD_MAX_WIIMOTES: _bindgen_ty_20 = 5;
pub type _bindgen_ty_20 = ::libc::c_int;
pub const WPAD_EXP_NONE: _bindgen_ty_21 = 0;
pub const WPAD_EXP_NUNCHUK: _bindgen_ty_21 = 1;
pub const WPAD_EXP_CLASSIC: _bindgen_ty_21 = 2;
pub const WPAD_EXP_GUITARHERO3: _bindgen_ty_21 = 3;
pub const WPAD_EXP_WIIBOARD: _bindgen_ty_21 = 4;
pub const WPAD_EXP_UNKNOWN: _bindgen_ty_21 = 255;
pub type _bindgen_ty_21 = ::libc::c_uint;
pub const WPAD_FMT_BTNS: _bindgen_ty_22 = 0;
pub const WPAD_FMT_BTNS_ACC: _bindgen_ty_22 = 1;
pub const WPAD_FMT_BTNS_ACC_IR: _bindgen_ty_22 = 2;
pub type _bindgen_ty_22 = ::libc::c_uint;
pub const WPAD_STATE_DISABLED: _bindgen_ty_23 = 0;
pub const WPAD_STATE_ENABLING: _bindgen_ty_23 = 1;
pub const WPAD_STATE_ENABLED: _bindgen_ty_23 = 2;
pub type _bindgen_ty_23 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wpad_data {
    pub err: s16,
    pub data_present: u32_,
    pub battery_level: u8_,
    pub btns_h: u32_,
    pub btns_l: u32_,
    pub btns_d: u32_,
    pub btns_u: u32_,
    pub ir: ir_t,
    pub accel: vec3w_t,
    pub orient: orient_t,
    pub gforce: gforce_t,
    pub exp: expansion_t,
}
pub type WPADData = _wpad_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wpad_encstatus {
    pub data: [u8_; 32usize],
}
pub type WPADEncStatus = _wpad_encstatus;
pub type WPADDataCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: s32, data: *const WPADData)>;
pub type WPADShutdownCallback = ::core::option::Option<unsafe extern "C" fn(chan: s32)>;
extern "C" {
    pub fn WPAD_Init() -> s32;
}
extern "C" {
    pub fn WPAD_ControlSpeaker(chan: s32, enable: s32) -> s32;
}
extern "C" {
    pub fn WPAD_ReadEvent(chan: s32, data: *mut WPADData) -> s32;
}
extern "C" {
    pub fn WPAD_DroppedEvents(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_Flush(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_ReadPending(chan: s32, datacb: WPADDataCallback) -> s32;
}
extern "C" {
    pub fn WPAD_SetDataFormat(chan: s32, fmt: s32) -> s32;
}
extern "C" {
    pub fn WPAD_SetMotionPlus(chan: s32, enable: u8_) -> s32;
}
extern "C" {
    pub fn WPAD_SetVRes(chan: s32, xres: u32_, yres: u32_) -> s32;
}
extern "C" {
    pub fn WPAD_GetStatus() -> s32;
}
extern "C" {
    pub fn WPAD_Probe(chan: s32, type_: *mut u32_) -> s32;
}
extern "C" {
    pub fn WPAD_SetEventBufs(chan: s32, bufs: *mut WPADData, cnt: u32_) -> s32;
}
extern "C" {
    pub fn WPAD_Disconnect(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_IsSpeakerEnabled(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_SendStreamData(chan: s32, buf: *mut ::libc::c_void, len: u32_) -> s32;
}
extern "C" {
    pub fn WPAD_Shutdown();
}
extern "C" {
    pub fn WPAD_SetIdleTimeout(seconds: u32_);
}
extern "C" {
    pub fn WPAD_SetPowerButtonCallback(cb: WPADShutdownCallback);
}
extern "C" {
    pub fn WPAD_SetBatteryDeadCallback(cb: WPADShutdownCallback);
}
extern "C" {
    pub fn WPAD_ScanPads() -> s32;
}
extern "C" {
    pub fn WPAD_Rumble(chan: s32, status: ::libc::c_int) -> s32;
}
extern "C" {
    pub fn WPAD_SetIdleThresholds(
        chan: s32,
        btns: s32,
        ir: s32,
        accel: s32,
        js: s32,
        wb: s32,
        mp: s32,
    ) -> s32;
}
extern "C" {
    pub fn WPAD_EncodeData(
        info: *mut WPADEncStatus,
        flag: u32_,
        pcmSamples: *const s16,
        numSamples: s32,
        encData: *mut u8_,
    );
}
extern "C" {
    pub fn WPAD_Data(chan: ::libc::c_int) -> *mut WPADData;
}
extern "C" {
    pub fn WPAD_BatteryLevel(chan: ::libc::c_int) -> u8_;
}
extern "C" {
    pub fn WPAD_ButtonsUp(chan: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn WPAD_ButtonsDown(chan: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn WPAD_ButtonsHeld(chan: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn WPAD_IR(chan: ::libc::c_int, ir: *mut ir_t);
}
extern "C" {
    pub fn WPAD_Orientation(chan: ::libc::c_int, orient: *mut orient_t);
}
extern "C" {
    pub fn WPAD_GForce(chan: ::libc::c_int, gforce: *mut gforce_t);
}
extern "C" {
    pub fn WPAD_Accel(chan: ::libc::c_int, accel: *mut vec3w_t);
}
extern "C" {
    pub fn WPAD_Expansion(chan: ::libc::c_int, exp: *mut expansion_t);
}
pub type __builtin_va_list = [[u32; 3usize]; 1usize];
