/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.4.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const NULL: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 3412;
pub const BIG_ENDIAN: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const ARGV_MAGIC: u32 = 1600221799;
pub const DSPTASK_INIT: u32 = 0;
pub const DSPTASK_RUN: u32 = 1;
pub const DSPTASK_YIELD: u32 = 2;
pub const DSPTASK_DONE: u32 = 3;
pub const DSPTASK_CLEARALL: u32 = 0;
pub const DSPTASK_ATTACH: u32 = 1;
pub const DSPTASK_CANCEL: u32 = 2;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const AR_MRAMTOARAM: u32 = 0;
pub const AR_ARAMTOMRAM: u32 = 1;
pub const AR_ARAMINTALL: u32 = 0;
pub const AR_ARAMINTUSER: u32 = 1;
pub const ARQ_MRAMTOARAM: u32 = 0;
pub const ARQ_ARAMTOMRAM: u32 = 1;
pub const ARQ_DEF_CHUNK_SIZE: u32 = 4096;
pub const ARQ_PRIO_LO: u32 = 0;
pub const ARQ_PRIO_HI: u32 = 1;
pub const AI_STREAM_STOP: u32 = 0;
pub const AI_STREAM_START: u32 = 1;
pub const AI_SAMPLERATE_32KHZ: u32 = 0;
pub const AI_SAMPLERATE_48KHZ: u32 = 1;
pub const LC_BASEPREFIX: u32 = 57344;
pub const LC_BASE: u32 = 3758096384;
pub const CARD_SLOTA: u32 = 0;
pub const CARD_SLOTB: u32 = 1;
pub const CARD_WORKAREA_SIZE: u32 = 40960;
pub const CARD_READSIZE: u32 = 512;
pub const CARD_FILENAMELEN: u32 = 32;
pub const CARD_MAXFILES: u32 = 127;
pub const CARD_ERROR_UNLOCKED: u32 = 1;
pub const CARD_ERROR_READY: u32 = 0;
pub const CARD_ERROR_BUSY: i32 = -1;
pub const CARD_ERROR_WRONGDEVICE: i32 = -2;
pub const CARD_ERROR_NOCARD: i32 = -3;
pub const CARD_ERROR_NOFILE: i32 = -4;
pub const CARD_ERROR_IOERROR: i32 = -5;
pub const CARD_ERROR_BROKEN: i32 = -6;
pub const CARD_ERROR_EXIST: i32 = -7;
pub const CARD_ERROR_NOENT: i32 = -8;
pub const CARD_ERROR_INSSPACE: i32 = -9;
pub const CARD_ERROR_NOPERM: i32 = -10;
pub const CARD_ERROR_LIMIT: i32 = -11;
pub const CARD_ERROR_NAMETOOLONG: i32 = -12;
pub const CARD_ERROR_ENCODING: i32 = -13;
pub const CARD_ERROR_CANCELED: i32 = -14;
pub const CARD_ERROR_FATAL_ERROR: i32 = -128;
pub const CARD_ATTRIB_PUBLIC: u32 = 4;
pub const CARD_ATTRIB_NOCOPY: u32 = 8;
pub const CARD_ATTRIB_NOMOVE: u32 = 16;
pub const CARD_BANNER_W: u32 = 96;
pub const CARD_BANNER_H: u32 = 32;
pub const CARD_BANNER_NONE: u32 = 0;
pub const CARD_BANNER_CI: u32 = 1;
pub const CARD_BANNER_RGB: u32 = 2;
pub const CARD_BANNER_MASK: u32 = 3;
pub const CARD_MAXICONS: u32 = 8;
pub const CARD_ICON_W: u32 = 32;
pub const CARD_ICON_H: u32 = 32;
pub const CARD_ICON_NONE: u32 = 0;
pub const CARD_ICON_CI: u32 = 1;
pub const CARD_ICON_RGB: u32 = 2;
pub const CARD_ICON_MASK: u32 = 3;
pub const CARD_ANIM_LOOP: u32 = 0;
pub const CARD_ANIM_BOUNCE: u32 = 4;
pub const CARD_ANIM_MASK: u32 = 4;
pub const CARD_SPEED_END: u32 = 0;
pub const CARD_SPEED_FAST: u32 = 1;
pub const CARD_SPEED_MIDDLE: u32 = 2;
pub const CARD_SPEED_SLOW: u32 = 3;
pub const CARD_SPEED_MASK: u32 = 3;
pub const GQR2: u32 = 914;
pub const GQR3: u32 = 915;
pub const GQR4: u32 = 916;
pub const GQR5: u32 = 917;
pub const GQR6: u32 = 918;
pub const GQR7: u32 = 919;
pub const GQR_TYPE_F32: u32 = 0;
pub const GQR_TYPE_U8: u32 = 4;
pub const GQR_TYPE_U16: u32 = 5;
pub const GQR_TYPE_S8: u32 = 6;
pub const GQR_TYPE_S16: u32 = 7;
pub const GQR_CAST_U8: u32 = 2;
pub const GQR_CAST_U16: u32 = 3;
pub const GQR_CAST_S8: u32 = 4;
pub const GQR_CAST_S16: u32 = 5;
pub const COLOR_BLACK: u32 = 276828288;
pub const COLOR_MAROON: u32 = 829239736;
pub const COLOR_GREEN: u32 = 1364939089;
pub const COLOR_OLIVE: u32 = 1900573065;
pub const COLOR_NAVY: u32 = 498605431;
pub const COLOR_PURPLE: u32 = 1034239407;
pub const COLOR_TEAL: u32 = 1569938760;
pub const COLOR_GRAY: u32 = 2122350208;
pub const COLOR_SILVER: u32 = 3045111168;
pub const COLOR_RED: u32 = 1364873712;
pub const COLOR_LIME: u32 = 2436272418;
pub const COLOR_YELLOW: u32 = 3524317842;
pub const COLOR_BLUE: u32 = 703605102;
pub const COLOR_FUCHSIA: u32 = 1791650526;
pub const COLOR_AQUA: u32 = 2863049232;
pub const COLOR_WHITE: u32 = 3951094656;
pub const COLOR_MONEYGREEN: u32 = 3279471478;
pub const COLOR_SKYBLUE: u32 = 3096885357;
pub const COLOR_CREAM: u32 = 3900434563;
pub const COLOR_MEDGRAY: u32 = 2592250496;
pub const FEATURE_MEDIUM_CANREAD: u32 = 1;
pub const FEATURE_MEDIUM_CANWRITE: u32 = 2;
pub const FEATURE_GAMECUBE_SLOTA: u32 = 16;
pub const FEATURE_GAMECUBE_SLOTB: u32 = 32;
pub const FEATURE_GAMECUBE_DVD: u32 = 64;
pub const FEATURE_GAMECUBE_PORT2: u32 = 128;
pub const FEATURE_WII_SD: u32 = 256;
pub const FEATURE_WII_USB: u32 = 512;
pub const FEATURE_WII_DVD: u32 = 1024;
pub const DVD_STATE_FATAL_ERROR: i32 = -1;
pub const DVD_STATE_END: u32 = 0;
pub const DVD_STATE_BUSY: u32 = 1;
pub const DVD_STATE_WAITING: u32 = 2;
pub const DVD_STATE_COVER_CLOSED: u32 = 3;
pub const DVD_STATE_NO_DISK: u32 = 4;
pub const DVD_STATE_COVER_OPEN: u32 = 5;
pub const DVD_STATE_WRONG_DISK: u32 = 6;
pub const DVD_STATE_MOTOR_STOPPED: u32 = 7;
pub const DVD_STATE_IGNORED: u32 = 8;
pub const DVD_STATE_CANCELED: u32 = 10;
pub const DVD_STATE_RETRY: u32 = 11;
pub const DVD_ERROR_OK: u32 = 0;
pub const DVD_ERROR_FATAL: i32 = -1;
pub const DVD_ERROR_IGNORED: i32 = -2;
pub const DVD_ERROR_CANCELED: i32 = -3;
pub const DVD_ERROR_COVER_CLOSED: i32 = -4;
pub const DVD_RESETHARD: u32 = 0;
pub const DVD_RESETSOFT: u32 = 1;
pub const DVD_RESETNONE: u32 = 2;
pub const DVD_SPINMOTOR_DOWN: u32 = 0;
pub const DVD_SPINMOTOR_UP: u32 = 256;
pub const DVD_SPINMOTOR_ACCEPT: u32 = 16384;
pub const DVD_SPINMOTOR_CHECKDISK: u32 = 32768;
pub const EXI_READ: u32 = 0;
pub const EXI_WRITE: u32 = 1;
pub const EXI_READWRITE: u32 = 2;
pub const EXI_CHANNEL_0: u32 = 0;
pub const EXI_CHANNEL_1: u32 = 1;
pub const EXI_CHANNEL_2: u32 = 2;
pub const EXI_CHANNEL_MAX: u32 = 3;
pub const EXI_DEVICE_0: u32 = 0;
pub const EXI_DEVICE_1: u32 = 1;
pub const EXI_DEVICE_2: u32 = 2;
pub const EXI_DEVICE_MAX: u32 = 3;
pub const EXI_SPEED1MHZ: u32 = 0;
pub const EXI_SPEED2MHZ: u32 = 1;
pub const EXI_SPEED4MHZ: u32 = 2;
pub const EXI_SPEED8MHZ: u32 = 3;
pub const EXI_SPEED16MHZ: u32 = 4;
pub const EXI_SPEED32MHZ: u32 = 5;
pub const EXI_FLAG_DMA: u32 = 1;
pub const EXI_FLAG_IMM: u32 = 2;
pub const EXI_FLAG_SELECT: u32 = 4;
pub const EXI_FLAG_ATTACH: u32 = 8;
pub const EXI_FLAG_LOCKED: u32 = 16;
pub const EXI_MEMCARD59: u32 = 4;
pub const EXI_MEMCARD123: u32 = 8;
pub const EXI_MEMCARD251: u32 = 16;
pub const EXI_MEMCARD507: u32 = 32;
pub const EXI_MEMCARD1019: u32 = 64;
pub const EXI_MEMCARD2043: u32 = 128;
pub const M_PI: f64 = 3.141592653589793;
pub const M_DTOR: f64 = 0.017453292519943295;
pub const LWP_CLOSED: i32 = -1;
pub const LWP_SUCCESSFUL: u32 = 0;
pub const LWP_ALREADY_SUSPENDED: u32 = 1;
pub const LWP_NOT_SUSPENDED: u32 = 2;
pub const LWP_PRIO_IDLE: u32 = 0;
pub const LWP_PRIO_HIGHEST: u32 = 127;
pub const LWP_THREAD_NULL: u32 = 4294967295;
pub const LWP_TQUEUE_NULL: u32 = 4294967295;
pub const GX_FALSE: u32 = 0;
pub const GX_TRUE: u32 = 1;
pub const GX_DISABLE: u32 = 0;
pub const GX_ENABLE: u32 = 1;
pub const GX_CLIP_DISABLE: u32 = 1;
pub const GX_CLIP_ENABLE: u32 = 0;
pub const GX_FIFO_MINSIZE: u32 = 65536;
pub const GX_FIFO_HIWATERMARK: u32 = 16384;
pub const GX_FIFO_OBJSIZE: u32 = 128;
pub const GX_PERSPECTIVE: u32 = 0;
pub const GX_ORTHOGRAPHIC: u32 = 1;
pub const GX_MT_NULL: u32 = 0;
pub const GX_MT_XF_FLUSH: u32 = 1;
pub const GX_MT_DL_SAVE_CTX: u32 = 2;
pub const GX_XF_FLUSH_NONE: u32 = 0;
pub const GX_XF_FLUSH_SAFE: u32 = 1;
pub const GX_COLOR0: u32 = 0;
pub const GX_COLOR1: u32 = 1;
pub const GX_ALPHA0: u32 = 2;
pub const GX_ALPHA1: u32 = 3;
pub const GX_COLOR0A0: u32 = 4;
pub const GX_COLOR1A1: u32 = 5;
pub const GX_COLORZERO: u32 = 6;
pub const GX_ALPHA_BUMP: u32 = 7;
pub const GX_ALPHA_BUMPN: u32 = 8;
pub const GX_COLORNULL: u32 = 255;
pub const GX_MTX3x4: u32 = 0;
pub const GX_MTX2x4: u32 = 1;
pub const GX_VTXFMT0: u32 = 0;
pub const GX_VTXFMT1: u32 = 1;
pub const GX_VTXFMT2: u32 = 2;
pub const GX_VTXFMT3: u32 = 3;
pub const GX_VTXFMT4: u32 = 4;
pub const GX_VTXFMT5: u32 = 5;
pub const GX_VTXFMT6: u32 = 6;
pub const GX_VTXFMT7: u32 = 7;
pub const GX_MAXVTXFMT: u32 = 8;
pub const GX_NONE: u32 = 0;
pub const GX_DIRECT: u32 = 1;
pub const GX_INDEX8: u32 = 2;
pub const GX_INDEX16: u32 = 3;
pub const GX_U8: u32 = 0;
pub const GX_S8: u32 = 1;
pub const GX_U16: u32 = 2;
pub const GX_S16: u32 = 3;
pub const GX_F32: u32 = 4;
pub const GX_RGB565: u32 = 0;
pub const GX_RGB8: u32 = 1;
pub const GX_RGBX8: u32 = 2;
pub const GX_RGBA4: u32 = 3;
pub const GX_RGBA6: u32 = 4;
pub const GX_RGBA8: u32 = 5;
pub const GX_POS_XY: u32 = 0;
pub const GX_POS_XYZ: u32 = 1;
pub const GX_NRM_XYZ: u32 = 0;
pub const GX_NRM_NBT: u32 = 1;
pub const GX_NRM_NBT3: u32 = 2;
pub const GX_CLR_RGB: u32 = 0;
pub const GX_CLR_RGBA: u32 = 1;
pub const GX_TEX_S: u32 = 0;
pub const GX_TEX_ST: u32 = 1;
pub const GX_VA_PTNMTXIDX: u32 = 0;
pub const GX_VA_TEX0MTXIDX: u32 = 1;
pub const GX_VA_TEX1MTXIDX: u32 = 2;
pub const GX_VA_TEX2MTXIDX: u32 = 3;
pub const GX_VA_TEX3MTXIDX: u32 = 4;
pub const GX_VA_TEX4MTXIDX: u32 = 5;
pub const GX_VA_TEX5MTXIDX: u32 = 6;
pub const GX_VA_TEX6MTXIDX: u32 = 7;
pub const GX_VA_TEX7MTXIDX: u32 = 8;
pub const GX_VA_POS: u32 = 9;
pub const GX_VA_NRM: u32 = 10;
pub const GX_VA_CLR0: u32 = 11;
pub const GX_VA_CLR1: u32 = 12;
pub const GX_VA_TEX0: u32 = 13;
pub const GX_VA_TEX1: u32 = 14;
pub const GX_VA_TEX2: u32 = 15;
pub const GX_VA_TEX3: u32 = 16;
pub const GX_VA_TEX4: u32 = 17;
pub const GX_VA_TEX5: u32 = 18;
pub const GX_VA_TEX6: u32 = 19;
pub const GX_VA_TEX7: u32 = 20;
pub const GX_POSMTXARRAY: u32 = 21;
pub const GX_NRMMTXARRAY: u32 = 22;
pub const GX_TEXMTXARRAY: u32 = 23;
pub const GX_LIGHTARRAY: u32 = 24;
pub const GX_VA_NBT: u32 = 25;
pub const GX_VA_MAXATTR: u32 = 26;
pub const GX_VA_NULL: u32 = 255;
pub const GX_POINTS: u32 = 184;
pub const GX_LINES: u32 = 168;
pub const GX_LINESTRIP: u32 = 176;
pub const GX_TRIANGLES: u32 = 144;
pub const GX_TRIANGLESTRIP: u32 = 152;
pub const GX_TRIANGLEFAN: u32 = 160;
pub const GX_QUADS: u32 = 128;
pub const GX_SRC_REG: u32 = 0;
pub const GX_SRC_VTX: u32 = 1;
pub const GX_LIGHT0: u32 = 1;
pub const GX_LIGHT1: u32 = 2;
pub const GX_LIGHT2: u32 = 4;
pub const GX_LIGHT3: u32 = 8;
pub const GX_LIGHT4: u32 = 16;
pub const GX_LIGHT5: u32 = 32;
pub const GX_LIGHT6: u32 = 64;
pub const GX_LIGHT7: u32 = 128;
pub const GX_MAXLIGHT: u32 = 256;
pub const GX_LIGHTNULL: u32 = 0;
pub const GX_DF_NONE: u32 = 0;
pub const GX_DF_SIGNED: u32 = 1;
pub const GX_DF_CLAMP: u32 = 2;
pub const GX_AF_SPEC: u32 = 0;
pub const GX_AF_SPOT: u32 = 1;
pub const GX_AF_NONE: u32 = 2;
pub const GX_PNMTX0: u32 = 0;
pub const GX_PNMTX1: u32 = 3;
pub const GX_PNMTX2: u32 = 6;
pub const GX_PNMTX3: u32 = 9;
pub const GX_PNMTX4: u32 = 12;
pub const GX_PNMTX5: u32 = 15;
pub const GX_PNMTX6: u32 = 18;
pub const GX_PNMTX7: u32 = 21;
pub const GX_PNMTX8: u32 = 24;
pub const GX_PNMTX9: u32 = 27;
pub const GX_TEXMTX0: u32 = 30;
pub const GX_TEXMTX1: u32 = 33;
pub const GX_TEXMTX2: u32 = 36;
pub const GX_TEXMTX3: u32 = 39;
pub const GX_TEXMTX4: u32 = 42;
pub const GX_TEXMTX5: u32 = 45;
pub const GX_TEXMTX6: u32 = 48;
pub const GX_TEXMTX7: u32 = 51;
pub const GX_TEXMTX8: u32 = 54;
pub const GX_TEXMTX9: u32 = 57;
pub const GX_IDENTITY: u32 = 60;
pub const GX_DTTMTX0: u32 = 64;
pub const GX_DTTMTX1: u32 = 67;
pub const GX_DTTMTX2: u32 = 70;
pub const GX_DTTMTX3: u32 = 73;
pub const GX_DTTMTX4: u32 = 76;
pub const GX_DTTMTX5: u32 = 79;
pub const GX_DTTMTX6: u32 = 82;
pub const GX_DTTMTX7: u32 = 85;
pub const GX_DTTMTX8: u32 = 88;
pub const GX_DTTMTX9: u32 = 91;
pub const GX_DTTMTX10: u32 = 94;
pub const GX_DTTMTX11: u32 = 97;
pub const GX_DTTMTX12: u32 = 100;
pub const GX_DTTMTX13: u32 = 103;
pub const GX_DTTMTX14: u32 = 106;
pub const GX_DTTMTX15: u32 = 109;
pub const GX_DTTMTX16: u32 = 112;
pub const GX_DTTMTX17: u32 = 115;
pub const GX_DTTMTX18: u32 = 118;
pub const GX_DTTMTX19: u32 = 121;
pub const GX_DTTIDENTITY: u32 = 125;
pub const GX_TEXCOORD0: u32 = 0;
pub const GX_TEXCOORD1: u32 = 1;
pub const GX_TEXCOORD2: u32 = 2;
pub const GX_TEXCOORD3: u32 = 3;
pub const GX_TEXCOORD4: u32 = 4;
pub const GX_TEXCOORD5: u32 = 5;
pub const GX_TEXCOORD6: u32 = 6;
pub const GX_TEXCOORD7: u32 = 7;
pub const GX_MAXCOORD: u32 = 8;
pub const GX_TEXCOORDNULL: u32 = 255;
pub const _GX_TF_ZTF: u32 = 16;
pub const _GX_TF_CTF: u32 = 32;
pub const GX_TF_I4: u32 = 0;
pub const GX_TF_I8: u32 = 1;
pub const GX_TF_IA4: u32 = 2;
pub const GX_TF_IA8: u32 = 3;
pub const GX_TF_RGB565: u32 = 4;
pub const GX_TF_RGB5A3: u32 = 5;
pub const GX_TF_RGBA8: u32 = 6;
pub const GX_TF_CI4: u32 = 8;
pub const GX_TF_CI8: u32 = 9;
pub const GX_TF_CI14: u32 = 10;
pub const GX_TF_CMPR: u32 = 14;
pub const GX_TL_IA8: u32 = 0;
pub const GX_TL_RGB565: u32 = 1;
pub const GX_TL_RGB5A3: u32 = 2;
pub const GX_CTF_R4: u32 = 32;
pub const GX_CTF_RA4: u32 = 34;
pub const GX_CTF_RA8: u32 = 35;
pub const GX_CTF_YUVA8: u32 = 38;
pub const GX_CTF_A8: u32 = 39;
pub const GX_CTF_R8: u32 = 40;
pub const GX_CTF_G8: u32 = 41;
pub const GX_CTF_B8: u32 = 42;
pub const GX_CTF_RG8: u32 = 43;
pub const GX_CTF_GB8: u32 = 44;
pub const GX_TF_Z8: u32 = 17;
pub const GX_TF_Z16: u32 = 19;
pub const GX_TF_Z24X8: u32 = 22;
pub const GX_CTF_Z4: u32 = 48;
pub const GX_CTF_Z8M: u32 = 57;
pub const GX_CTF_Z8L: u32 = 58;
pub const GX_CTF_Z16L: u32 = 60;
pub const GX_TF_A8: u32 = 39;
pub const GX_TLUT_16: u32 = 1;
pub const GX_TLUT_32: u32 = 2;
pub const GX_TLUT_64: u32 = 4;
pub const GX_TLUT_128: u32 = 8;
pub const GX_TLUT_256: u32 = 16;
pub const GX_TLUT_512: u32 = 32;
pub const GX_TLUT_1K: u32 = 64;
pub const GX_TLUT_2K: u32 = 128;
pub const GX_TLUT_4K: u32 = 256;
pub const GX_TLUT_8K: u32 = 512;
pub const GX_TLUT_16K: u32 = 1024;
pub const GX_ZT_DISABLE: u32 = 0;
pub const GX_ZT_ADD: u32 = 1;
pub const GX_ZT_REPLACE: u32 = 2;
pub const GX_MAX_ZTEXOP: u32 = 3;
pub const GX_TG_MTX3x4: u32 = 0;
pub const GX_TG_MTX2x4: u32 = 1;
pub const GX_TG_BUMP0: u32 = 2;
pub const GX_TG_BUMP1: u32 = 3;
pub const GX_TG_BUMP2: u32 = 4;
pub const GX_TG_BUMP3: u32 = 5;
pub const GX_TG_BUMP4: u32 = 6;
pub const GX_TG_BUMP5: u32 = 7;
pub const GX_TG_BUMP6: u32 = 8;
pub const GX_TG_BUMP7: u32 = 9;
pub const GX_TG_SRTG: u32 = 10;
pub const GX_TG_POS: u32 = 0;
pub const GX_TG_NRM: u32 = 1;
pub const GX_TG_BINRM: u32 = 2;
pub const GX_TG_TANGENT: u32 = 3;
pub const GX_TG_TEX0: u32 = 4;
pub const GX_TG_TEX1: u32 = 5;
pub const GX_TG_TEX2: u32 = 6;
pub const GX_TG_TEX3: u32 = 7;
pub const GX_TG_TEX4: u32 = 8;
pub const GX_TG_TEX5: u32 = 9;
pub const GX_TG_TEX6: u32 = 10;
pub const GX_TG_TEX7: u32 = 11;
pub const GX_TG_TEXCOORD0: u32 = 12;
pub const GX_TG_TEXCOORD1: u32 = 13;
pub const GX_TG_TEXCOORD2: u32 = 14;
pub const GX_TG_TEXCOORD3: u32 = 15;
pub const GX_TG_TEXCOORD4: u32 = 16;
pub const GX_TG_TEXCOORD5: u32 = 17;
pub const GX_TG_TEXCOORD6: u32 = 18;
pub const GX_TG_COLOR0: u32 = 19;
pub const GX_TG_COLOR1: u32 = 20;
pub const GX_NEVER: u32 = 0;
pub const GX_LESS: u32 = 1;
pub const GX_EQUAL: u32 = 2;
pub const GX_LEQUAL: u32 = 3;
pub const GX_GREATER: u32 = 4;
pub const GX_NEQUAL: u32 = 5;
pub const GX_GEQUAL: u32 = 6;
pub const GX_ALWAYS: u32 = 7;
pub const GX_CLAMP: u32 = 0;
pub const GX_REPEAT: u32 = 1;
pub const GX_MIRROR: u32 = 2;
pub const GX_MAXTEXWRAPMODE: u32 = 3;
pub const GX_BM_NONE: u32 = 0;
pub const GX_BM_BLEND: u32 = 1;
pub const GX_BM_LOGIC: u32 = 2;
pub const GX_BM_SUBTRACT: u32 = 3;
pub const GX_MAX_BLENDMODE: u32 = 4;
pub const GX_BL_ZERO: u32 = 0;
pub const GX_BL_ONE: u32 = 1;
pub const GX_BL_SRCCLR: u32 = 2;
pub const GX_BL_INVSRCCLR: u32 = 3;
pub const GX_BL_SRCALPHA: u32 = 4;
pub const GX_BL_INVSRCALPHA: u32 = 5;
pub const GX_BL_DSTALPHA: u32 = 6;
pub const GX_BL_INVDSTALPHA: u32 = 7;
pub const GX_BL_DSTCLR: u32 = 2;
pub const GX_BL_INVDSTCLR: u32 = 3;
pub const GX_LO_CLEAR: u32 = 0;
pub const GX_LO_AND: u32 = 1;
pub const GX_LO_REVAND: u32 = 2;
pub const GX_LO_COPY: u32 = 3;
pub const GX_LO_INVAND: u32 = 4;
pub const GX_LO_NOOP: u32 = 5;
pub const GX_LO_XOR: u32 = 6;
pub const GX_LO_OR: u32 = 7;
pub const GX_LO_NOR: u32 = 8;
pub const GX_LO_EQUIV: u32 = 9;
pub const GX_LO_INV: u32 = 10;
pub const GX_LO_REVOR: u32 = 11;
pub const GX_LO_INVCOPY: u32 = 12;
pub const GX_LO_INVOR: u32 = 13;
pub const GX_LO_NAND: u32 = 14;
pub const GX_LO_SET: u32 = 15;
pub const GX_TO_ZERO: u32 = 0;
pub const GX_TO_SIXTEENTH: u32 = 1;
pub const GX_TO_EIGHTH: u32 = 2;
pub const GX_TO_FOURTH: u32 = 3;
pub const GX_TO_HALF: u32 = 4;
pub const GX_TO_ONE: u32 = 5;
pub const GX_MAX_TEXOFFSET: u32 = 6;
pub const GX_MODULATE: u32 = 0;
pub const GX_DECAL: u32 = 1;
pub const GX_BLEND: u32 = 2;
pub const GX_REPLACE: u32 = 3;
pub const GX_PASSCLR: u32 = 4;
pub const GX_CC_CPREV: u32 = 0;
pub const GX_CC_APREV: u32 = 1;
pub const GX_CC_C0: u32 = 2;
pub const GX_CC_A0: u32 = 3;
pub const GX_CC_C1: u32 = 4;
pub const GX_CC_A1: u32 = 5;
pub const GX_CC_C2: u32 = 6;
pub const GX_CC_A2: u32 = 7;
pub const GX_CC_TEXC: u32 = 8;
pub const GX_CC_TEXA: u32 = 9;
pub const GX_CC_RASC: u32 = 10;
pub const GX_CC_RASA: u32 = 11;
pub const GX_CC_ONE: u32 = 12;
pub const GX_CC_HALF: u32 = 13;
pub const GX_CC_KONST: u32 = 14;
pub const GX_CC_ZERO: u32 = 15;
pub const GX_CA_APREV: u32 = 0;
pub const GX_CA_A0: u32 = 1;
pub const GX_CA_A1: u32 = 2;
pub const GX_CA_A2: u32 = 3;
pub const GX_CA_TEXA: u32 = 4;
pub const GX_CA_RASA: u32 = 5;
pub const GX_CA_KONST: u32 = 6;
pub const GX_CA_ZERO: u32 = 7;
pub const GX_TEVSTAGE0: u32 = 0;
pub const GX_TEVSTAGE1: u32 = 1;
pub const GX_TEVSTAGE2: u32 = 2;
pub const GX_TEVSTAGE3: u32 = 3;
pub const GX_TEVSTAGE4: u32 = 4;
pub const GX_TEVSTAGE5: u32 = 5;
pub const GX_TEVSTAGE6: u32 = 6;
pub const GX_TEVSTAGE7: u32 = 7;
pub const GX_TEVSTAGE8: u32 = 8;
pub const GX_TEVSTAGE9: u32 = 9;
pub const GX_TEVSTAGE10: u32 = 10;
pub const GX_TEVSTAGE11: u32 = 11;
pub const GX_TEVSTAGE12: u32 = 12;
pub const GX_TEVSTAGE13: u32 = 13;
pub const GX_TEVSTAGE14: u32 = 14;
pub const GX_TEVSTAGE15: u32 = 15;
pub const GX_MAX_TEVSTAGE: u32 = 16;
pub const GX_TEV_ADD: u32 = 0;
pub const GX_TEV_SUB: u32 = 1;
pub const GX_TEV_COMP_R8_GT: u32 = 8;
pub const GX_TEV_COMP_R8_EQ: u32 = 9;
pub const GX_TEV_COMP_GR16_GT: u32 = 10;
pub const GX_TEV_COMP_GR16_EQ: u32 = 11;
pub const GX_TEV_COMP_BGR24_GT: u32 = 12;
pub const GX_TEV_COMP_BGR24_EQ: u32 = 13;
pub const GX_TEV_COMP_RGB8_GT: u32 = 14;
pub const GX_TEV_COMP_RGB8_EQ: u32 = 15;
pub const GX_TEV_COMP_A8_GT: u32 = 14;
pub const GX_TEV_COMP_A8_EQ: u32 = 15;
pub const GX_TB_ZERO: u32 = 0;
pub const GX_TB_ADDHALF: u32 = 1;
pub const GX_TB_SUBHALF: u32 = 2;
pub const GX_MAX_TEVBIAS: u32 = 3;
pub const GX_TC_LINEAR: u32 = 0;
pub const GX_TC_GE: u32 = 1;
pub const GX_TC_EQ: u32 = 2;
pub const GX_TC_LE: u32 = 3;
pub const GX_MAX_TEVCLAMPMODE: u32 = 4;
pub const GX_CS_SCALE_1: u32 = 0;
pub const GX_CS_SCALE_2: u32 = 1;
pub const GX_CS_SCALE_4: u32 = 2;
pub const GX_CS_DIVIDE_2: u32 = 3;
pub const GX_MAX_TEVSCALE: u32 = 4;
pub const GX_TEVPREV: u32 = 0;
pub const GX_TEVREG0: u32 = 1;
pub const GX_TEVREG1: u32 = 2;
pub const GX_TEVREG2: u32 = 3;
pub const GX_MAX_TEVREG: u32 = 4;
pub const GX_CULL_NONE: u32 = 0;
pub const GX_CULL_FRONT: u32 = 1;
pub const GX_CULL_BACK: u32 = 2;
pub const GX_CULL_ALL: u32 = 3;
pub const GX_TEXMAP0: u32 = 0;
pub const GX_TEXMAP1: u32 = 1;
pub const GX_TEXMAP2: u32 = 2;
pub const GX_TEXMAP3: u32 = 3;
pub const GX_TEXMAP4: u32 = 4;
pub const GX_TEXMAP5: u32 = 5;
pub const GX_TEXMAP6: u32 = 6;
pub const GX_TEXMAP7: u32 = 7;
pub const GX_MAX_TEXMAP: u32 = 8;
pub const GX_TEXMAP_NULL: u32 = 255;
pub const GX_TEXMAP_DISABLE: u32 = 256;
pub const GX_AOP_AND: u32 = 0;
pub const GX_AOP_OR: u32 = 1;
pub const GX_AOP_XOR: u32 = 2;
pub const GX_AOP_XNOR: u32 = 3;
pub const GX_MAX_ALPHAOP: u32 = 4;
pub const GX_KCOLOR0: u32 = 0;
pub const GX_KCOLOR1: u32 = 1;
pub const GX_KCOLOR2: u32 = 2;
pub const GX_KCOLOR3: u32 = 3;
pub const GX_KCOLOR_MAX: u32 = 4;
pub const GX_TEV_KCSEL_1: u32 = 0;
pub const GX_TEV_KCSEL_7_8: u32 = 1;
pub const GX_TEV_KCSEL_3_4: u32 = 2;
pub const GX_TEV_KCSEL_5_8: u32 = 3;
pub const GX_TEV_KCSEL_1_2: u32 = 4;
pub const GX_TEV_KCSEL_3_8: u32 = 5;
pub const GX_TEV_KCSEL_1_4: u32 = 6;
pub const GX_TEV_KCSEL_1_8: u32 = 7;
pub const GX_TEV_KCSEL_K0: u32 = 12;
pub const GX_TEV_KCSEL_K1: u32 = 13;
pub const GX_TEV_KCSEL_K2: u32 = 14;
pub const GX_TEV_KCSEL_K3: u32 = 15;
pub const GX_TEV_KCSEL_K0_R: u32 = 16;
pub const GX_TEV_KCSEL_K1_R: u32 = 17;
pub const GX_TEV_KCSEL_K2_R: u32 = 18;
pub const GX_TEV_KCSEL_K3_R: u32 = 19;
pub const GX_TEV_KCSEL_K0_G: u32 = 20;
pub const GX_TEV_KCSEL_K1_G: u32 = 21;
pub const GX_TEV_KCSEL_K2_G: u32 = 22;
pub const GX_TEV_KCSEL_K3_G: u32 = 23;
pub const GX_TEV_KCSEL_K0_B: u32 = 24;
pub const GX_TEV_KCSEL_K1_B: u32 = 25;
pub const GX_TEV_KCSEL_K2_B: u32 = 26;
pub const GX_TEV_KCSEL_K3_B: u32 = 27;
pub const GX_TEV_KCSEL_K0_A: u32 = 28;
pub const GX_TEV_KCSEL_K1_A: u32 = 29;
pub const GX_TEV_KCSEL_K2_A: u32 = 30;
pub const GX_TEV_KCSEL_K3_A: u32 = 31;
pub const GX_TEV_KASEL_1: u32 = 0;
pub const GX_TEV_KASEL_7_8: u32 = 1;
pub const GX_TEV_KASEL_3_4: u32 = 2;
pub const GX_TEV_KASEL_5_8: u32 = 3;
pub const GX_TEV_KASEL_1_2: u32 = 4;
pub const GX_TEV_KASEL_3_8: u32 = 5;
pub const GX_TEV_KASEL_1_4: u32 = 6;
pub const GX_TEV_KASEL_1_8: u32 = 7;
pub const GX_TEV_KASEL_K0_R: u32 = 16;
pub const GX_TEV_KASEL_K1_R: u32 = 17;
pub const GX_TEV_KASEL_K2_R: u32 = 18;
pub const GX_TEV_KASEL_K3_R: u32 = 19;
pub const GX_TEV_KASEL_K0_G: u32 = 20;
pub const GX_TEV_KASEL_K1_G: u32 = 21;
pub const GX_TEV_KASEL_K2_G: u32 = 22;
pub const GX_TEV_KASEL_K3_G: u32 = 23;
pub const GX_TEV_KASEL_K0_B: u32 = 24;
pub const GX_TEV_KASEL_K1_B: u32 = 25;
pub const GX_TEV_KASEL_K2_B: u32 = 26;
pub const GX_TEV_KASEL_K3_B: u32 = 27;
pub const GX_TEV_KASEL_K0_A: u32 = 28;
pub const GX_TEV_KASEL_K1_A: u32 = 29;
pub const GX_TEV_KASEL_K2_A: u32 = 30;
pub const GX_TEV_KASEL_K3_A: u32 = 31;
pub const GX_TEV_SWAP0: u32 = 0;
pub const GX_TEV_SWAP1: u32 = 1;
pub const GX_TEV_SWAP2: u32 = 2;
pub const GX_TEV_SWAP3: u32 = 3;
pub const GX_MAX_TEVSWAP: u32 = 4;
pub const GX_CH_RED: u32 = 0;
pub const GX_CH_GREEN: u32 = 1;
pub const GX_CH_BLUE: u32 = 2;
pub const GX_CH_ALPHA: u32 = 3;
pub const GX_INDTEXSTAGE0: u32 = 0;
pub const GX_INDTEXSTAGE1: u32 = 1;
pub const GX_INDTEXSTAGE2: u32 = 2;
pub const GX_INDTEXSTAGE3: u32 = 3;
pub const GX_MAX_INDTEXSTAGE: u32 = 4;
pub const GX_ITF_8: u32 = 0;
pub const GX_ITF_5: u32 = 1;
pub const GX_ITF_4: u32 = 2;
pub const GX_ITF_3: u32 = 3;
pub const GX_MAX_ITFORMAT: u32 = 4;
pub const GX_ITB_NONE: u32 = 0;
pub const GX_ITB_S: u32 = 1;
pub const GX_ITB_T: u32 = 2;
pub const GX_ITB_ST: u32 = 3;
pub const GX_ITB_U: u32 = 4;
pub const GX_ITB_SU: u32 = 5;
pub const GX_ITB_TU: u32 = 6;
pub const GX_ITB_STU: u32 = 7;
pub const GX_MAX_ITBIAS: u32 = 8;
pub const GX_ITM_OFF: u32 = 0;
pub const GX_ITM_0: u32 = 1;
pub const GX_ITM_1: u32 = 2;
pub const GX_ITM_2: u32 = 3;
pub const GX_ITM_S0: u32 = 5;
pub const GX_ITM_S1: u32 = 6;
pub const GX_ITM_S2: u32 = 7;
pub const GX_ITM_T0: u32 = 9;
pub const GX_ITM_T1: u32 = 10;
pub const GX_ITM_T2: u32 = 11;
pub const GX_ITW_OFF: u32 = 0;
pub const GX_ITW_256: u32 = 1;
pub const GX_ITW_128: u32 = 2;
pub const GX_ITW_64: u32 = 3;
pub const GX_ITW_32: u32 = 4;
pub const GX_ITW_16: u32 = 5;
pub const GX_ITW_0: u32 = 6;
pub const GX_MAX_ITWRAP: u32 = 7;
pub const GX_ITBA_OFF: u32 = 0;
pub const GX_ITBA_S: u32 = 1;
pub const GX_ITBA_T: u32 = 2;
pub const GX_ITBA_U: u32 = 3;
pub const GX_MAX_ITBALPHA: u32 = 4;
pub const GX_ITS_1: u32 = 0;
pub const GX_ITS_2: u32 = 1;
pub const GX_ITS_4: u32 = 2;
pub const GX_ITS_8: u32 = 3;
pub const GX_ITS_16: u32 = 4;
pub const GX_ITS_32: u32 = 5;
pub const GX_ITS_64: u32 = 6;
pub const GX_ITS_128: u32 = 7;
pub const GX_ITS_256: u32 = 8;
pub const GX_MAX_ITSCALE: u32 = 9;
pub const GX_FOG_NONE: u32 = 0;
pub const GX_FOG_PERSP_LIN: u32 = 2;
pub const GX_FOG_PERSP_EXP: u32 = 4;
pub const GX_FOG_PERSP_EXP2: u32 = 5;
pub const GX_FOG_PERSP_REVEXP: u32 = 6;
pub const GX_FOG_PERSP_REVEXP2: u32 = 7;
pub const GX_FOG_ORTHO_LIN: u32 = 10;
pub const GX_FOG_ORTHO_EXP: u32 = 12;
pub const GX_FOG_ORTHO_EXP2: u32 = 13;
pub const GX_FOG_ORTHO_REVEXP: u32 = 14;
pub const GX_FOG_ORTHO_REVEXP2: u32 = 15;
pub const GX_FOG_LIN: u32 = 2;
pub const GX_FOG_EXP: u32 = 4;
pub const GX_FOG_EXP2: u32 = 5;
pub const GX_FOG_REVEXP: u32 = 6;
pub const GX_FOG_REVEXP2: u32 = 7;
pub const GX_PF_RGB8_Z24: u32 = 0;
pub const GX_PF_RGBA6_Z24: u32 = 1;
pub const GX_PF_RGB565_Z16: u32 = 2;
pub const GX_PF_Z24: u32 = 3;
pub const GX_PF_Y8: u32 = 4;
pub const GX_PF_U8: u32 = 5;
pub const GX_PF_V8: u32 = 6;
pub const GX_PF_YUV420: u32 = 7;
pub const GX_ZC_LINEAR: u32 = 0;
pub const GX_ZC_NEAR: u32 = 1;
pub const GX_ZC_MID: u32 = 2;
pub const GX_ZC_FAR: u32 = 3;
pub const GX_CLAMP_NONE: u32 = 0;
pub const GX_CLAMP_TOP: u32 = 1;
pub const GX_CLAMP_BOTTOM: u32 = 2;
pub const GX_GM_1_0: u32 = 0;
pub const GX_GM_1_7: u32 = 1;
pub const GX_GM_2_2: u32 = 2;
pub const GX_COPY_PROGRESSIVE: u32 = 0;
pub const GX_COPY_INTLC_EVEN: u32 = 2;
pub const GX_COPY_INTLC_ODD: u32 = 3;
pub const GX_READ_00: u32 = 0;
pub const GX_READ_FF: u32 = 1;
pub const GX_READ_NONE: u32 = 2;
pub const GX_TEXCACHE_32K: u32 = 0;
pub const GX_TEXCACHE_128K: u32 = 1;
pub const GX_TEXCACHE_512K: u32 = 2;
pub const GX_TEXCACHE_NONE: u32 = 3;
pub const GX_DA_OFF: u32 = 0;
pub const GX_DA_GENTLE: u32 = 1;
pub const GX_DA_MEDIUM: u32 = 2;
pub const GX_DA_STEEP: u32 = 3;
pub const GX_SP_OFF: u32 = 0;
pub const GX_SP_FLAT: u32 = 1;
pub const GX_SP_COS: u32 = 2;
pub const GX_SP_COS2: u32 = 3;
pub const GX_SP_SHARP: u32 = 4;
pub const GX_SP_RING1: u32 = 5;
pub const GX_SP_RING2: u32 = 6;
pub const GX_NEAR: u32 = 0;
pub const GX_LINEAR: u32 = 1;
pub const GX_NEAR_MIP_NEAR: u32 = 2;
pub const GX_LIN_MIP_NEAR: u32 = 3;
pub const GX_NEAR_MIP_LIN: u32 = 4;
pub const GX_LIN_MIP_LIN: u32 = 5;
pub const GX_ANISO_1: u32 = 0;
pub const GX_ANISO_2: u32 = 1;
pub const GX_ANISO_4: u32 = 2;
pub const GX_MAX_ANISOTROPY: u32 = 3;
pub const GX_VC_POS: u32 = 0;
pub const GX_VC_NRM: u32 = 1;
pub const GX_VC_CLR0: u32 = 2;
pub const GX_VC_CLR1: u32 = 3;
pub const GX_VC_TEX0: u32 = 4;
pub const GX_VC_TEX1: u32 = 5;
pub const GX_VC_TEX2: u32 = 6;
pub const GX_VC_TEX3: u32 = 7;
pub const GX_VC_TEX4: u32 = 8;
pub const GX_VC_TEX5: u32 = 9;
pub const GX_VC_TEX6: u32 = 10;
pub const GX_VC_TEX7: u32 = 11;
pub const GX_VC_ALL: u32 = 15;
pub const GX_PERF0_VERTICES: u32 = 0;
pub const GX_PERF0_CLIP_VTX: u32 = 1;
pub const GX_PERF0_CLIP_CLKS: u32 = 2;
pub const GX_PERF0_XF_WAIT_IN: u32 = 3;
pub const GX_PERF0_XF_WAIT_OUT: u32 = 4;
pub const GX_PERF0_XF_XFRM_CLKS: u32 = 5;
pub const GX_PERF0_XF_LIT_CLKS: u32 = 6;
pub const GX_PERF0_XF_BOT_CLKS: u32 = 7;
pub const GX_PERF0_XF_REGLD_CLKS: u32 = 8;
pub const GX_PERF0_XF_REGRD_CLKS: u32 = 9;
pub const GX_PERF0_CLIP_RATIO: u32 = 10;
pub const GX_PERF0_TRIANGLES: u32 = 11;
pub const GX_PERF0_TRIANGLES_CULLED: u32 = 12;
pub const GX_PERF0_TRIANGLES_PASSED: u32 = 13;
pub const GX_PERF0_TRIANGLES_SCISSORED: u32 = 14;
pub const GX_PERF0_TRIANGLES_0TEX: u32 = 15;
pub const GX_PERF0_TRIANGLES_1TEX: u32 = 16;
pub const GX_PERF0_TRIANGLES_2TEX: u32 = 17;
pub const GX_PERF0_TRIANGLES_3TEX: u32 = 18;
pub const GX_PERF0_TRIANGLES_4TEX: u32 = 19;
pub const GX_PERF0_TRIANGLES_5TEX: u32 = 20;
pub const GX_PERF0_TRIANGLES_6TEX: u32 = 21;
pub const GX_PERF0_TRIANGLES_7TEX: u32 = 22;
pub const GX_PERF0_TRIANGLES_8TEX: u32 = 23;
pub const GX_PERF0_TRIANGLES_0CLR: u32 = 24;
pub const GX_PERF0_TRIANGLES_1CLR: u32 = 25;
pub const GX_PERF0_TRIANGLES_2CLR: u32 = 26;
pub const GX_PERF0_QUAD_0CVG: u32 = 27;
pub const GX_PERF0_QUAD_NON0CVG: u32 = 28;
pub const GX_PERF0_QUAD_1CVG: u32 = 29;
pub const GX_PERF0_QUAD_2CVG: u32 = 30;
pub const GX_PERF0_QUAD_3CVG: u32 = 31;
pub const GX_PERF0_QUAD_4CVG: u32 = 32;
pub const GX_PERF0_AVG_QUAD_CNT: u32 = 33;
pub const GX_PERF0_CLOCKS: u32 = 34;
pub const GX_PERF0_NONE: u32 = 35;
pub const GX_PERF1_TEXELS: u32 = 0;
pub const GX_PERF1_TX_IDLE: u32 = 1;
pub const GX_PERF1_TX_REGS: u32 = 2;
pub const GX_PERF1_TX_MEMSTALL: u32 = 3;
pub const GX_PERF1_TC_CHECK1_2: u32 = 4;
pub const GX_PERF1_TC_CHECK3_4: u32 = 5;
pub const GX_PERF1_TC_CHECK5_6: u32 = 6;
pub const GX_PERF1_TC_CHECK7_8: u32 = 7;
pub const GX_PERF1_TC_MISS: u32 = 8;
pub const GX_PERF1_VC_ELEMQ_FULL: u32 = 9;
pub const GX_PERF1_VC_MISSQ_FULL: u32 = 10;
pub const GX_PERF1_VC_MEMREQ_FULL: u32 = 11;
pub const GX_PERF1_VC_STATUS7: u32 = 12;
pub const GX_PERF1_VC_MISSREP_FULL: u32 = 13;
pub const GX_PERF1_VC_STREAMBUF_LOW: u32 = 14;
pub const GX_PERF1_VC_ALL_STALLS: u32 = 15;
pub const GX_PERF1_VERTICES: u32 = 16;
pub const GX_PERF1_FIFO_REQ: u32 = 17;
pub const GX_PERF1_CALL_REQ: u32 = 18;
pub const GX_PERF1_VC_MISS_REQ: u32 = 19;
pub const GX_PERF1_CP_ALL_REQ: u32 = 20;
pub const GX_PERF1_CLOCKS: u32 = 21;
pub const GX_PERF1_NONE: u32 = 22;
pub const GX_TLUT0: u32 = 0;
pub const GX_TLUT1: u32 = 1;
pub const GX_TLUT2: u32 = 2;
pub const GX_TLUT3: u32 = 3;
pub const GX_TLUT4: u32 = 4;
pub const GX_TLUT5: u32 = 5;
pub const GX_TLUT6: u32 = 6;
pub const GX_TLUT7: u32 = 7;
pub const GX_TLUT8: u32 = 8;
pub const GX_TLUT9: u32 = 9;
pub const GX_TLUT10: u32 = 10;
pub const GX_TLUT11: u32 = 11;
pub const GX_TLUT12: u32 = 12;
pub const GX_TLUT13: u32 = 13;
pub const GX_TLUT14: u32 = 14;
pub const GX_TLUT15: u32 = 15;
pub const GX_BIGTLUT0: u32 = 16;
pub const GX_BIGTLUT1: u32 = 17;
pub const GX_BIGTLUT2: u32 = 18;
pub const GX_BIGTLUT3: u32 = 19;
pub const GX_MAX_VTXDESC: u32 = 26;
pub const GX_MAX_VTXDESC_LISTSIZE: u32 = 27;
pub const GX_MAX_VTXATTRFMT: u32 = 26;
pub const GX_MAX_VTXATTRFMT_LISTSIZE: u32 = 27;
pub const GX_MAX_Z24: u32 = 16777215;
pub const SI_CHAN0: u32 = 0;
pub const SI_CHAN1: u32 = 1;
pub const SI_CHAN2: u32 = 2;
pub const SI_CHAN3: u32 = 3;
pub const SI_MAX_CHAN: u32 = 4;
pub const SI_CHAN0_BIT: u32 = 2147483648;
pub const SI_CHAN1_BIT: u32 = 1073741824;
pub const SI_CHAN2_BIT: u32 = 536870912;
pub const SI_CHAN3_BIT: u32 = 268435456;
pub const SI_ERROR_UNDER_RUN: u32 = 1;
pub const SI_ERROR_OVER_RUN: u32 = 2;
pub const SI_ERROR_COLLISION: u32 = 4;
pub const SI_ERROR_NO_RESPONSE: u32 = 8;
pub const SI_ERROR_WRST: u32 = 16;
pub const SI_ERROR_RDST: u32 = 32;
pub const SI_ERROR_UNKNOWN: u32 = 64;
pub const SI_ERROR_BUSY: u32 = 128;
pub const SI_TYPE_MASK: u32 = 402653184;
pub const SI_TYPE_N64: u32 = 0;
pub const SI_TYPE_DOLPHIN: u32 = 134217728;
pub const SI_TYPE_GC: u32 = 134217728;
pub const SI_GC_WIRELESS: u32 = 2147483648;
pub const SI_GC_NOMOTOR: u32 = 536870912;
pub const SI_GC_STANDARD: u32 = 16777216;
pub const SI_WIRELESS_RECEIVED: u32 = 1073741824;
pub const SI_WIRELESS_IR: u32 = 67108864;
pub const SI_WIRELESS_STATE: u32 = 33554432;
pub const SI_WIRELESS_ORIGIN: u32 = 2097152;
pub const SI_WIRELESS_FIX_ID: u32 = 1048576;
pub const SI_WIRELESS_TYPE: u32 = 983040;
pub const SI_WIRELESS_LITE_MASK: u32 = 786432;
pub const SI_WIRELESS_LITE: u32 = 262144;
pub const SI_WIRELESS_CONT_MASK: u32 = 524288;
pub const SI_WIRELESS_CONT: u32 = 0;
pub const SI_WIRELESS_ID: u32 = 12648192;
pub const SI_WIRELESS_TYPE_ID: u32 = 13631232;
pub const SI_N64_CONTROLLER: u32 = 83886080;
pub const SI_N64_MIC: u32 = 65536;
pub const SI_N64_KEYBOARD: u32 = 131072;
pub const SI_N64_MOUSE: u32 = 33554432;
pub const SI_GBA: u32 = 262144;
pub const SI_GC_CONTROLLER: u32 = 150994944;
pub const SI_GC_RECEIVER: u32 = 2281701376;
pub const SI_GC_WAVEBIRD: u32 = 2333081600;
pub const SI_GC_KEYBOARD: u32 = 136314880;
pub const SI_GC_STEERING: u32 = 134217728;
pub const NUM_EXCEPTIONS: u32 = 15;
pub const EX_SYS_RESET: u32 = 0;
pub const EX_MACH_CHECK: u32 = 1;
pub const EX_DSI: u32 = 2;
pub const EX_ISI: u32 = 3;
pub const EX_INT: u32 = 4;
pub const EX_ALIGN: u32 = 5;
pub const EX_PRG: u32 = 6;
pub const EX_FP: u32 = 7;
pub const EX_DEC: u32 = 8;
pub const EX_SYS_CALL: u32 = 9;
pub const EX_TRACE: u32 = 10;
pub const EX_PERF: u32 = 11;
pub const EX_IABR: u32 = 12;
pub const EX_RESV: u32 = 13;
pub const EX_THERM: u32 = 14;
pub const IM_NONE: u32 = 4294967295;
pub const IRQ_MEM0: u32 = 0;
pub const IRQ_MEM1: u32 = 1;
pub const IRQ_MEM2: u32 = 2;
pub const IRQ_MEM3: u32 = 3;
pub const IRQ_MEMADDRESS: u32 = 4;
pub const IRQ_DSP_AI: u32 = 5;
pub const IRQ_DSP_ARAM: u32 = 6;
pub const IRQ_DSP_DSP: u32 = 7;
pub const IRQ_AI: u32 = 8;
pub const IRQ_EXI0_EXI: u32 = 9;
pub const IRQ_EXI0_TC: u32 = 10;
pub const IRQ_EXI0_EXT: u32 = 11;
pub const IRQ_EXI1_EXI: u32 = 12;
pub const IRQ_EXI1_TC: u32 = 13;
pub const IRQ_EXI1_EXT: u32 = 14;
pub const IRQ_EXI2_EXI: u32 = 15;
pub const IRQ_EXI2_TC: u32 = 16;
pub const IRQ_PI_CP: u32 = 17;
pub const IRQ_PI_PETOKEN: u32 = 18;
pub const IRQ_PI_PEFINISH: u32 = 19;
pub const IRQ_PI_SI: u32 = 20;
pub const IRQ_PI_DI: u32 = 21;
pub const IRQ_PI_RSW: u32 = 22;
pub const IRQ_PI_ERROR: u32 = 23;
pub const IRQ_PI_VI: u32 = 24;
pub const IRQ_PI_DEBUG: u32 = 25;
pub const IRQ_PI_HSP: u32 = 26;
pub const IRQ_PI_ACR: u32 = 27;
pub const IRQ_MAX: u32 = 32;
pub const LWP_MUTEX_NULL: u32 = 4294967295;
pub const MQ_BOX_NULL: u32 = 4294967295;
pub const MQ_ERROR_SUCCESSFUL: u32 = 0;
pub const MQ_ERROR_TOOMANY: i32 = -5;
pub const MQ_MSG_BLOCK: u32 = 0;
pub const MQ_MSG_NOBLOCK: u32 = 1;
pub const LWP_SEM_NULL: u32 = 4294967295;
pub const PAD_CHAN0: u32 = 0;
pub const PAD_CHAN1: u32 = 1;
pub const PAD_CHAN2: u32 = 2;
pub const PAD_CHAN3: u32 = 3;
pub const PAD_CHANMAX: u32 = 4;
pub const PAD_MOTOR_STOP: u32 = 0;
pub const PAD_MOTOR_RUMBLE: u32 = 1;
pub const PAD_MOTOR_STOP_HARD: u32 = 2;
pub const PAD_ERR_NONE: u32 = 0;
pub const PAD_ERR_NO_CONTROLLER: i32 = -1;
pub const PAD_ERR_NOT_READY: i32 = -2;
pub const PAD_ERR_TRANSFER: i32 = -3;
pub const PAD_BUTTON_LEFT: u32 = 1;
pub const PAD_BUTTON_RIGHT: u32 = 2;
pub const PAD_BUTTON_DOWN: u32 = 4;
pub const PAD_BUTTON_UP: u32 = 8;
pub const PAD_TRIGGER_Z: u32 = 16;
pub const PAD_TRIGGER_R: u32 = 32;
pub const PAD_TRIGGER_L: u32 = 64;
pub const PAD_BUTTON_A: u32 = 256;
pub const PAD_BUTTON_B: u32 = 512;
pub const PAD_BUTTON_X: u32 = 1024;
pub const PAD_BUTTON_Y: u32 = 2048;
pub const PAD_BUTTON_MENU: u32 = 4096;
pub const PAD_BUTTON_START: u32 = 4096;
pub const PAD_CHAN0_BIT: u32 = 2147483648;
pub const PAD_CHAN1_BIT: u32 = 1073741824;
pub const PAD_CHAN2_BIT: u32 = 536870912;
pub const PAD_CHAN3_BIT: u32 = 268435456;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 4321;
pub const _QUAD_HIGHWORD: u32 = 0;
pub const _QUAD_LOWWORD: u32 = 1;
pub const PDP_ENDIAN: u32 = 3412;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG2STR_MAX: u32 = 17;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SYS_BASE_CACHED: u32 = 2147483648;
pub const SYS_BASE_UNCACHED: u32 = 3221225472;
pub const SYS_WD_NULL: u32 = 4294967295;
pub const SYS_RESTART: u32 = 0;
pub const SYS_HOTRESET: u32 = 1;
pub const SYS_SHUTDOWN: u32 = 2;
pub const SYS_RETURNTOMENU: u32 = 3;
pub const SYS_POWEROFF: u32 = 4;
pub const SYS_POWEROFF_STANDBY: u32 = 5;
pub const SYS_POWEROFF_IDLE: u32 = 6;
pub const SYS_PROTECTCHAN0: u32 = 0;
pub const SYS_PROTECTCHAN1: u32 = 1;
pub const SYS_PROTECTCHAN2: u32 = 2;
pub const SYS_PROTECTCHAN3: u32 = 3;
pub const SYS_PROTECTCHANMAX: u32 = 4;
pub const SYS_PROTECTNONE: u32 = 0;
pub const SYS_PROTECTREAD: u32 = 1;
pub const SYS_PROTECTWRITE: u32 = 2;
pub const SYS_PROTECTRDWR: u32 = 3;
pub const SYS_LANG_ENGLISH: u32 = 0;
pub const SYS_LANG_GERMAN: u32 = 1;
pub const SYS_LANG_FRENCH: u32 = 2;
pub const SYS_LANG_SPANISH: u32 = 3;
pub const SYS_LANG_ITALIAN: u32 = 4;
pub const SYS_LANG_DUTCH: u32 = 5;
pub const SYS_VIDEO_NTSC: u32 = 0;
pub const SYS_VIDEO_PAL: u32 = 1;
pub const SYS_VIDEO_MPAL: u32 = 2;
pub const SYS_SOUND_MONO: u32 = 0;
pub const SYS_SOUND_STEREO: u32 = 1;
pub const SYS_FONTSIZE_ANSI: u32 = 131360;
pub const SYS_FONTSIZE_SJIS: u32 = 1183488;
pub const VI_DISPLAY_PIX_SZ: u32 = 2;
pub const VI_INTERLACE: u32 = 0;
pub const VI_NON_INTERLACE: u32 = 1;
pub const VI_PROGRESSIVE: u32 = 2;
pub const VI_NTSC: u32 = 0;
pub const VI_PAL: u32 = 1;
pub const VI_MPAL: u32 = 2;
pub const VI_DEBUG: u32 = 3;
pub const VI_DEBUG_PAL: u32 = 4;
pub const VI_EURGB60: u32 = 5;
pub const VI_XFBMODE_SF: u32 = 0;
pub const VI_XFBMODE_DF: u32 = 1;
pub const VI_FIELD_ABOVE: u32 = 1;
pub const VI_FIELD_BELOW: u32 = 0;
pub const VI_MAX_WIDTH_NTSC: u32 = 720;
pub const VI_MAX_HEIGHT_NTSC: u32 = 480;
pub const VI_MAX_WIDTH_PAL: u32 = 720;
pub const VI_MAX_HEIGHT_PAL: u32 = 576;
pub const VI_MAX_WIDTH_MPAL: u32 = 720;
pub const VI_MAX_HEIGHT_MPAL: u32 = 480;
pub const VI_MAX_WIDTH_EURGB60: u32 = 720;
pub const VI_MAX_HEIGHT_EURGB60: u32 = 480;
pub const HW_IPC_PPCBASE: u32 = 3439329280;
pub const HW_IPC_PPC_SEND: u32 = 1;
pub const HW_IPC_PPC_MSG_ACK: u32 = 2;
pub const HW_IPC_PPC_CTRL_ACK: u32 = 4;
pub const HW_IPC_PPC_CTRL_REGS: u32 = 6;
pub const IPC_HEAP: i32 = -1;
pub const IPC_OPEN_NONE: u32 = 0;
pub const IPC_OPEN_READ: u32 = 1;
pub const IPC_OPEN_WRITE: u32 = 2;
pub const IPC_OPEN_RW: u32 = 3;
pub const IPC_MAXPATH_LEN: u32 = 64;
pub const IPC_OK: u32 = 0;
pub const IPC_EINVAL: i32 = -4;
pub const IPC_ENOHEAP: i32 = -5;
pub const IPC_ENOENT: i32 = -6;
pub const IPC_EQUEUEFULL: i32 = -8;
pub const IPC_ENOMEM: i32 = -22;
pub const SHA_MSGBLOCK_SIZE: u32 = 65536;
pub const AES_BLOCK_SIZE: u32 = 65536;
pub const ES_EINVAL: i32 = -4100;
pub const ES_ENOMEM: i32 = -4108;
pub const ES_ENOTINIT: i32 = -4352;
pub const ES_EALIGN: i32 = -4353;
pub const ES_SIG_RSA4096: u32 = 65536;
pub const ES_SIG_RSA2048: u32 = 65537;
pub const ES_SIG_ECDSA: u32 = 65538;
pub const ES_CERT_RSA4096: u32 = 0;
pub const ES_CERT_RSA2048: u32 = 1;
pub const ES_CERT_ECDSA: u32 = 2;
pub const ES_KEY_COMMON: u32 = 4;
pub const ES_KEY_SDCARD: u32 = 6;
pub const MAX_NUM_TMD_CONTENTS: u32 = 512;
pub const STM_EVENT_RESET: u32 = 131072;
pub const STM_EVENT_POWER: u32 = 2048;
pub const STM_EINVAL: i32 = -8196;
pub const STM_ENOTINIT: i32 = -8448;
pub const STM_ENOHANDLER: i32 = -8449;
pub const IOS_EINVAL: i32 = -12292;
pub const IOS_EBADVERSION: i32 = -12544;
pub const IOS_ETOOMANYVIEWS: i32 = -12545;
pub const IOS_EMISMATCH: i32 = -12546;
pub const USB_MAXPATH: u32 = 64;
pub const USB_OK: u32 = 0;
pub const USB_FAILED: u32 = 1;
pub const USB_CLASS_HID: u32 = 3;
pub const USB_SUBCLASS_NONE: u32 = 0;
pub const USB_SUBCLASS_BOOT: u32 = 1;
pub const USB_PROTOCOL_NONE: u32 = 0;
pub const USB_PROTOCOL_KEYBOARD: u32 = 1;
pub const USB_PROTOCOL_MOUSE: u32 = 2;
pub const USB_REPTYPE_INPUT: u32 = 1;
pub const USB_REPTYPE_OUTPUT: u32 = 2;
pub const USB_REPTYPE_FEATURE: u32 = 3;
pub const USB_DT_DEVICE: u32 = 1;
pub const USB_DT_CONFIG: u32 = 2;
pub const USB_DT_STRING: u32 = 3;
pub const USB_DT_INTERFACE: u32 = 4;
pub const USB_DT_ENDPOINT: u32 = 5;
pub const USB_DT_DEVICE_QUALIFIER: u32 = 6;
pub const USB_DT_OTHER_SPEED_CONFIG: u32 = 7;
pub const USB_DT_INTERFACE_POWER: u32 = 8;
pub const USB_DT_OTG: u32 = 9;
pub const USB_DT_DEBUG: u32 = 16;
pub const USB_DT_INTERFACE_ASSOCIATION: u32 = 17;
pub const USB_DT_HID: u32 = 33;
pub const USB_DT_REPORT: u32 = 34;
pub const USB_DT_PHYSICAL: u32 = 35;
pub const USB_DT_CLASS_SPECIFIC_INTERFACE: u32 = 36;
pub const USB_DT_CLASS_SPECIFIC_ENDPOINT: u32 = 37;
pub const USB_DT_HUB: u32 = 41;
pub const USB_REQ_GETSTATUS: u32 = 0;
pub const USB_REQ_CLEARFEATURE: u32 = 1;
pub const USB_REQ_SETFEATURE: u32 = 3;
pub const USB_REQ_SETADDRESS: u32 = 5;
pub const USB_REQ_GETDESCRIPTOR: u32 = 6;
pub const USB_REQ_SETDESCRIPTOR: u32 = 7;
pub const USB_REQ_GETCONFIG: u32 = 8;
pub const USB_REQ_SETCONFIG: u32 = 9;
pub const USB_REQ_GETINTERFACE: u32 = 10;
pub const USB_REQ_SETINTERFACE: u32 = 11;
pub const USB_REQ_SYNCFRAME: u32 = 12;
pub const USB_REQ_GETREPORT: u32 = 1;
pub const USB_REQ_GETIDLE: u32 = 2;
pub const USB_REQ_GETPROTOCOL: u32 = 3;
pub const USB_REQ_SETREPORT: u32 = 9;
pub const USB_REQ_SETIDLE: u32 = 10;
pub const USB_REQ_SETPROTOCOL: u32 = 11;
pub const USB_DT_DEVICE_SIZE: u32 = 18;
pub const USB_DT_CONFIG_SIZE: u32 = 9;
pub const USB_DT_INTERFACE_SIZE: u32 = 9;
pub const USB_DT_ENDPOINT_SIZE: u32 = 7;
pub const USB_DT_ENDPOINT_AUDIO_SIZE: u32 = 9;
pub const USB_DT_HID_SIZE: u32 = 9;
pub const USB_DT_MINREPORT_SIZE: u32 = 8;
pub const USB_DT_HUB_NONVAR_SIZE: u32 = 7;
pub const USB_CTRLTYPE_DIR_HOST2DEVICE: u32 = 0;
pub const USB_CTRLTYPE_DIR_DEVICE2HOST: u32 = 128;
pub const USB_CTRLTYPE_TYPE_STANDARD: u32 = 0;
pub const USB_CTRLTYPE_TYPE_CLASS: u32 = 32;
pub const USB_CTRLTYPE_TYPE_VENDOR: u32 = 64;
pub const USB_CTRLTYPE_TYPE_RESERVED: u32 = 96;
pub const USB_CTRLTYPE_REC_DEVICE: u32 = 0;
pub const USB_CTRLTYPE_REC_INTERFACE: u32 = 1;
pub const USB_CTRLTYPE_REC_ENDPOINT: u32 = 2;
pub const USB_CTRLTYPE_REC_OTHER: u32 = 3;
pub const USB_REQTYPE_INTERFACE_GET: u32 = 161;
pub const USB_REQTYPE_INTERFACE_SET: u32 = 33;
pub const USB_REQTYPE_ENDPOINT_GET: u32 = 162;
pub const USB_REQTYPE_ENDPOINT_SET: u32 = 34;
pub const USB_FEATURE_ENDPOINT_HALT: u32 = 0;
pub const USB_ENDPOINT_INTERRUPT: u32 = 3;
pub const USB_ENDPOINT_IN: u32 = 128;
pub const USB_ENDPOINT_OUT: u32 = 0;
pub const USB_OH0_DEVICE_ID: u32 = 0;
pub const USB_OH1_DEVICE_ID: u32 = 2097152;
pub const ISFS_MAXPATH: u32 = 64;
pub const ISFS_OPEN_READ: u32 = 1;
pub const ISFS_OPEN_WRITE: u32 = 2;
pub const ISFS_OPEN_RW: u32 = 3;
pub const ISFS_OK: u32 = 0;
pub const ISFS_ENOMEM: i32 = -22;
pub const ISFS_EINVAL: i32 = -101;
pub const CONF_EBADFILE: i32 = -24577;
pub const CONF_ENOENT: i32 = -24578;
pub const CONF_ETOOBIG: i32 = -24579;
pub const CONF_ENOTINIT: i32 = -24580;
pub const CONF_ENOTIMPL: i32 = -24581;
pub const CONF_EBADVALUE: i32 = -24582;
pub const CONF_ENOMEM: i32 = -24583;
pub const CONF_ERR_OK: u32 = 0;
pub const CONF_PAD_MAX_REGISTERED: u32 = 10;
pub const CONF_PAD_MAX_ACTIVE: u32 = 4;
pub const USBSTORAGE_OK: u32 = 0;
pub const USBSTORAGE_ENOINTERFACE: i32 = -10000;
pub const USBSTORAGE_ESENSE: i32 = -10001;
pub const USBSTORAGE_ESHORTWRITE: i32 = -10002;
pub const USBSTORAGE_ESHORTREAD: i32 = -10003;
pub const USBSTORAGE_ESIGNATURE: i32 = -10004;
pub const USBSTORAGE_ETAG: i32 = -10005;
pub const USBSTORAGE_ESTATUS: i32 = -10006;
pub const USBSTORAGE_EDATARESIDUE: i32 = -10007;
pub const USBSTORAGE_ETIMEDOUT: i32 = -10008;
pub const USBSTORAGE_EINIT: i32 = -10009;
pub const USBSTORAGE_PROCESSING: i32 = -10010;
pub const B_RAW_DEVICE_DATA_IN: u32 = 1;
pub const B_RAW_DEVICE_COMMAND: u32 = 0;
pub const WII_ENOTINIT: i32 = -36865;
pub const WII_EINTERNAL: i32 = -36866;
pub const WII_ECHECKSUM: i32 = -36867;
pub const WII_EINSTALL: i32 = -36868;
pub const WII_E2BIG: i32 = -36869;
pub const SETTINGS_CALENDAR: &[u8; 29] = b"Calendar/Calendar_index.html\0";
pub const SETTINGS_DISPLAY: &[u8; 27] = b"Display/Display_index.html\0";
pub const SETTINGS_SOUND: &[u8; 23] = b"Sound/Sound_index.html\0";
pub const SETTINGS_PARENTAL: &[u8; 45] = b"Parental_Control/Parental_Control_index.html\0";
pub const SETTINGS_INTERNET: &[u8; 29] = b"Internet/Internet_index.html\0";
pub const SETTINGS_WC24: &[u8; 37] = b"WiiConnect24/Wiiconnect24_index.html\0";
pub const SETTINGS_UPDATE: &[u8; 25] = b"Update/Update_index.html\0";
pub const RNC_FILE_IS_NOT_RNC: i32 = -1;
pub const RNC_HUF_DECODE_ERROR: i32 = -2;
pub const RNC_FILE_SIZE_MISMATCH: i32 = -3;
pub const RNC_PACKED_CRC_ERROR: i32 = -4;
pub const RNC_UNPACKED_CRC_ERROR: i32 = -5;
pub const TB_BUS_CLOCK: u32 = 243000000;
pub const TB_CORE_CLOCK: u32 = 729000000;
pub const TB_TIMER_CLOCK: u32 = 60750;
pub const TB_MSPERSEC: u32 = 1000;
pub const TB_USPERSEC: u32 = 1000000;
pub const TB_NSPERSEC: u32 = 1000000000;
pub const TB_NSPERMS: u32 = 1000000;
pub const TB_NSPERUS: u32 = 1000;
pub const TB_USPERTICK: u32 = 10000;
pub const TB_SECSPERMIN: u32 = 60;
pub const TB_MINSPERHR: u32 = 60;
pub const TB_MONSPERYR: u32 = 12;
pub const TB_DAYSPERYR: u32 = 365;
pub const TB_HRSPERDAY: u32 = 24;
pub const TB_SECSPERDAY: u32 = 86400;
pub const TB_SECSPERNYR: u32 = 31536000;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const INVALID_SOCKET: i32 = -1;
pub const SOCKET_ERROR: i32 = -1;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const PF_INET: u32 = 2;
pub const PF_UNSPEC: u32 = 0;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const MSG_DONTWAIT: u32 = 64;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const O_NONBLOCK: u32 = 2048;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_KEEPALIVE: u32 = 2;
pub const POLLRDNORM: u32 = 1;
pub const POLLRDBAND: u32 = 2;
pub const POLLPRI: u32 = 4;
pub const POLLWRNORM: u32 = 8;
pub const POLLWRBAND: u32 = 16;
pub const POLLERR: u32 = 32;
pub const POLLHUP: u32 = 64;
pub const POLLNVAL: u32 = 128;
pub const POLLIN: u32 = 3;
pub const POLLOUT: u32 = 8;
pub const GDBSTUB_DEVICE_USB: u32 = 0;
pub const GDBSTUB_DEVICE_TCP: u32 = 1;
pub const GDBSTUB_DEF_CHANNEL: u32 = 0;
pub const GDBSTUB_DEF_TCPPORT: u32 = 2828;
pub const ASND_LIB: u32 = 256;
pub const SND_LIB: u32 = 258;
pub const MAX_SND_VOICES: u32 = 16;
pub const SND_OK: u32 = 0;
pub const SND_INVALID: i32 = -1;
pub const SND_ISNOTASONGVOICE: i32 = -2;
pub const SND_BUSY: u32 = 1;
pub const SND_UNUSED: u32 = 0;
pub const SND_WORKING: u32 = 1;
pub const SND_WAITING: u32 = 2;
pub const VOICE_MONO_8BIT: u32 = 0;
pub const VOICE_MONO_16BIT: u32 = 1;
pub const VOICE_MONO_16BIT_BE: u32 = 1;
pub const VOICE_STEREO_8BIT: u32 = 2;
pub const VOICE_STEREO_16BIT: u32 = 3;
pub const VOICE_STEREO_16BIT_BE: u32 = 3;
pub const VOICE_MONO_8BIT_U: u32 = 4;
pub const VOICE_MONO_16BIT_LE: u32 = 5;
pub const VOICE_STEREO_8BIT_U: u32 = 6;
pub const VOICE_STEREO_16BIT_LE: u32 = 7;
pub const MIN_VOLUME: u32 = 0;
pub const MID_VOLUME: u32 = 127;
pub const MAX_VOLUME: u32 = 255;
pub const MIN_PITCH: u32 = 1;
pub const F44100HZ_PITCH: u32 = 44100;
pub const MAX_PITCH: u32 = 144000;
pub const MAX_VOICES: u32 = 32;
pub const SND_BUFFERSIZE: u32 = 384;
pub const DSP_STREAMBUFFER_SIZE: u32 = 1152;
pub const DSP_DEFAULT_FREQ: u32 = 48000;
pub const VOICE_STATE_STOPPED: u32 = 0;
pub const VOICE_STATE_RUNNING: u32 = 1;
pub const VOICE_STATE_STREAM: u32 = 2;
pub const VOICE_MONO8: u32 = 0;
pub const VOICE_STEREO8: u32 = 1;
pub const VOICE_MONO16: u32 = 2;
pub const VOICE_STEREO16: u32 = 3;
pub const VOICE_MONO8_UNSIGNED: u32 = 4;
pub const VOICE_STEREO8_UNSIGNED: u32 = 5;
pub const VOICE_MONO16_UNSIGNED: u32 = 6;
pub const VOICE_STEREO16_UNSIGNED: u32 = 7;
pub const VOICE_FREQ32KHZ: u32 = 32000;
pub const VOICE_FREQ48KHZ: u32 = 48000;
pub const SIZEOF_INT: u32 = 4;
pub const SIZEOF_LONG: u32 = 4;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const MAD_VERSION_MAJOR: u32 = 0;
pub const MAD_VERSION_MINOR: u32 = 15;
pub const MAD_VERSION_PATCH: u32 = 0;
pub const MAD_VERSION_EXTRA: &[u8; 8] = b" (beta)\0";
pub const MAD_PUBLISHYEAR: &[u8; 10] = b"2000-2003\0";
pub const MAD_AUTHOR: &[u8; 28] = b"Underbit Technologies, Inc.\0";
pub const MAD_EMAIL: &[u8; 18] = b"info@underbit.com\0";
pub const MAD_F_FRACBITS: u32 = 28;
pub const MAD_F_SCALEBITS: u32 = 28;
pub const MAD_TIMER_RESOLUTION: u32 = 352800000;
pub const MAD_BUFFER_GUARD: u32 = 8;
pub const MAD_BUFFER_MDLEN: u32 = 2567;
pub const WIIMOTE_LED_NONE: u32 = 0;
pub const WIIMOTE_LED_1: u32 = 16;
pub const WIIMOTE_LED_2: u32 = 32;
pub const WIIMOTE_LED_3: u32 = 64;
pub const WIIMOTE_LED_4: u32 = 128;
pub const WIIMOTE_BUTTON_TWO: u32 = 1;
pub const WIIMOTE_BUTTON_ONE: u32 = 2;
pub const WIIMOTE_BUTTON_B: u32 = 4;
pub const WIIMOTE_BUTTON_A: u32 = 8;
pub const WIIMOTE_BUTTON_MINUS: u32 = 16;
pub const WIIMOTE_BUTTON_ZACCEL_BIT6: u32 = 32;
pub const WIIMOTE_BUTTON_ZACCEL_BIT7: u32 = 64;
pub const WIIMOTE_BUTTON_HOME: u32 = 128;
pub const WIIMOTE_BUTTON_LEFT: u32 = 256;
pub const WIIMOTE_BUTTON_RIGHT: u32 = 512;
pub const WIIMOTE_BUTTON_DOWN: u32 = 1024;
pub const WIIMOTE_BUTTON_UP: u32 = 2048;
pub const WIIMOTE_BUTTON_PLUS: u32 = 4096;
pub const WIIMOTE_BUTTON_ZACCEL_BIT4: u32 = 8192;
pub const WIIMOTE_BUTTON_ZACCEL_BIT5: u32 = 16384;
pub const WIIMOTE_BUTTON_UNKNOWN: u32 = 32768;
pub const WIIMOTE_BUTTON_ALL: u32 = 8095;
pub const NUNCHUK_BUTTON_Z: u32 = 1;
pub const NUNCHUK_BUTTON_C: u32 = 2;
pub const NUNCHUK_BUTTON_ALL: u32 = 3;
pub const CLASSIC_CTRL_BUTTON_UP: u32 = 1;
pub const CLASSIC_CTRL_BUTTON_LEFT: u32 = 2;
pub const CLASSIC_CTRL_BUTTON_ZR: u32 = 4;
pub const CLASSIC_CTRL_BUTTON_X: u32 = 8;
pub const CLASSIC_CTRL_BUTTON_A: u32 = 16;
pub const CLASSIC_CTRL_BUTTON_Y: u32 = 32;
pub const CLASSIC_CTRL_BUTTON_B: u32 = 64;
pub const CLASSIC_CTRL_BUTTON_ZL: u32 = 128;
pub const CLASSIC_CTRL_BUTTON_FULL_R: u32 = 512;
pub const CLASSIC_CTRL_BUTTON_PLUS: u32 = 1024;
pub const CLASSIC_CTRL_BUTTON_HOME: u32 = 2048;
pub const CLASSIC_CTRL_BUTTON_MINUS: u32 = 4096;
pub const CLASSIC_CTRL_BUTTON_FULL_L: u32 = 8192;
pub const CLASSIC_CTRL_BUTTON_DOWN: u32 = 16384;
pub const CLASSIC_CTRL_BUTTON_RIGHT: u32 = 32768;
pub const CLASSIC_CTRL_BUTTON_ALL: u32 = 65279;
pub const GUITAR_HERO_3_BUTTON_STRUM_UP: u32 = 1;
pub const GUITAR_HERO_3_BUTTON_YELLOW: u32 = 8;
pub const GUITAR_HERO_3_BUTTON_GREEN: u32 = 16;
pub const GUITAR_HERO_3_BUTTON_BLUE: u32 = 32;
pub const GUITAR_HERO_3_BUTTON_RED: u32 = 64;
pub const GUITAR_HERO_3_BUTTON_ORANGE: u32 = 128;
pub const GUITAR_HERO_3_BUTTON_PLUS: u32 = 1024;
pub const GUITAR_HERO_3_BUTTON_MINUS: u32 = 4096;
pub const GUITAR_HERO_3_BUTTON_STRUM_DOWN: u32 = 16384;
pub const GUITAR_HERO_3_BUTTON_ALL: u32 = 65279;
pub const GUITAR_HERO_3_TOUCH_AVAILABLE: u32 = 4096;
pub const GUITAR_HERO_3_TOUCH_GREEN: u32 = 4097;
pub const GUITAR_HERO_3_TOUCH_RED: u32 = 4098;
pub const GUITAR_HERO_3_TOUCH_YELLOW: u32 = 4100;
pub const GUITAR_HERO_3_TOUCH_BLUE: u32 = 4104;
pub const GUITAR_HERO_3_TOUCH_ORANGE: u32 = 4112;
pub const WIIUSE_SMOOTHING: u32 = 1;
pub const WIIUSE_CONTINUOUS: u32 = 2;
pub const WIIUSE_ACCEL_THRESH: u32 = 4;
pub const WIIUSE_IR_THRESH: u32 = 8;
pub const WIIUSE_JS_THRESH: u32 = 16;
pub const WIIUSE_INIT_FLAGS: u32 = 1;
pub const WIIUSE_ORIENT_PRECISION: f64 = 100.0;
pub const EXP_NONE: u32 = 0;
pub const EXP_NUNCHUK: u32 = 1;
pub const EXP_CLASSIC: u32 = 2;
pub const EXP_GUITAR_HERO_3: u32 = 3;
pub const EXP_WII_BOARD: u32 = 4;
pub const EXP_MOTION_PLUS: u32 = 5;
pub const MAX_PAYLOAD: u32 = 32;
pub const WPAD_MAX_IR_DOTS: u32 = 4;
pub const WPAD_BUTTON_2: u32 = 1;
pub const WPAD_BUTTON_1: u32 = 2;
pub const WPAD_BUTTON_B: u32 = 4;
pub const WPAD_BUTTON_A: u32 = 8;
pub const WPAD_BUTTON_MINUS: u32 = 16;
pub const WPAD_BUTTON_HOME: u32 = 128;
pub const WPAD_BUTTON_LEFT: u32 = 256;
pub const WPAD_BUTTON_RIGHT: u32 = 512;
pub const WPAD_BUTTON_DOWN: u32 = 1024;
pub const WPAD_BUTTON_UP: u32 = 2048;
pub const WPAD_BUTTON_PLUS: u32 = 4096;
pub const WPAD_NUNCHUK_BUTTON_Z: u32 = 65536;
pub const WPAD_NUNCHUK_BUTTON_C: u32 = 131072;
pub const WPAD_CLASSIC_BUTTON_UP: u32 = 65536;
pub const WPAD_CLASSIC_BUTTON_LEFT: u32 = 131072;
pub const WPAD_CLASSIC_BUTTON_ZR: u32 = 262144;
pub const WPAD_CLASSIC_BUTTON_X: u32 = 524288;
pub const WPAD_CLASSIC_BUTTON_A: u32 = 1048576;
pub const WPAD_CLASSIC_BUTTON_Y: u32 = 2097152;
pub const WPAD_CLASSIC_BUTTON_B: u32 = 4194304;
pub const WPAD_CLASSIC_BUTTON_ZL: u32 = 8388608;
pub const WPAD_CLASSIC_BUTTON_FULL_R: u32 = 33554432;
pub const WPAD_CLASSIC_BUTTON_PLUS: u32 = 67108864;
pub const WPAD_CLASSIC_BUTTON_HOME: u32 = 134217728;
pub const WPAD_CLASSIC_BUTTON_MINUS: u32 = 268435456;
pub const WPAD_CLASSIC_BUTTON_FULL_L: u32 = 536870912;
pub const WPAD_CLASSIC_BUTTON_DOWN: u32 = 1073741824;
pub const WPAD_CLASSIC_BUTTON_RIGHT: u32 = 2147483648;
pub const WPAD_GUITAR_HERO_3_BUTTON_STRUM_UP: u32 = 65536;
pub const WPAD_GUITAR_HERO_3_BUTTON_YELLOW: u32 = 524288;
pub const WPAD_GUITAR_HERO_3_BUTTON_GREEN: u32 = 1048576;
pub const WPAD_GUITAR_HERO_3_BUTTON_BLUE: u32 = 2097152;
pub const WPAD_GUITAR_HERO_3_BUTTON_RED: u32 = 4194304;
pub const WPAD_GUITAR_HERO_3_BUTTON_ORANGE: u32 = 8388608;
pub const WPAD_GUITAR_HERO_3_BUTTON_PLUS: u32 = 67108864;
pub const WPAD_GUITAR_HERO_3_BUTTON_MINUS: u32 = 268435456;
pub const WPAD_GUITAR_HERO_3_BUTTON_STRUM_DOWN: u32 = 1073741824;
pub const WPAD_ERR_NONE: u32 = 0;
pub const WPAD_ERR_NO_CONTROLLER: i32 = -1;
pub const WPAD_ERR_NOT_READY: i32 = -2;
pub const WPAD_ERR_TRANSFER: i32 = -3;
pub const WPAD_ERR_NONEREGISTERED: i32 = -4;
pub const WPAD_ERR_UNKNOWN: i32 = -5;
pub const WPAD_ERR_BAD_CHANNEL: i32 = -6;
pub const WPAD_ERR_QUEUE_EMPTY: i32 = -7;
pub const WPAD_ERR_BADVALUE: i32 = -8;
pub const WPAD_ERR_BADCONF: i32 = -9;
pub const WPAD_DATA_BUTTONS: u32 = 1;
pub const WPAD_DATA_ACCEL: u32 = 2;
pub const WPAD_DATA_EXPANSION: u32 = 4;
pub const WPAD_DATA_IR: u32 = 8;
pub const WPAD_ENC_FIRST: u32 = 0;
pub const WPAD_ENC_CONT: u32 = 1;
pub const WPAD_THRESH_IGNORE: i32 = -1;
pub const WPAD_THRESH_ANY: u32 = 0;
pub const WPAD_THRESH_DEFAULT_BUTTONS: u32 = 0;
pub const WPAD_THRESH_DEFAULT_IR: i32 = -1;
pub const WPAD_THRESH_DEFAULT_ACCEL: u32 = 20;
pub const WPAD_THRESH_DEFAULT_JOYSTICK: u32 = 2;
pub const WPAD_THRESH_DEFAULT_BALANCEBOARD: u32 = 60;
pub const WPAD_THRESH_DEFAULT_MOTION_PLUS: u32 = 100;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type sfp16 = s16;
pub type sfp32 = s32;
pub type ufp16 = u16_;
pub type ufp32 = u32_;
pub type f32_ = f32;
pub type f64_ = f64;
pub type vf32 = f32;
pub type vf64 = f64;
#[doc = "!\targv structure\n*!\t__argv\n\nstructure used to set up argc/argv\n\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __argv {
    #[doc = "!< argv magic number, set to 0x5f617267 ('_arg') if valid"]
    pub argvMagic: ::libc::c_int,
    #[doc = "!< base address of command line, set of null terminated strings"]
    pub commandLine: *mut ::libc::c_char,
    #[doc = "!< total length of command line"]
    pub length: ::libc::c_int,
    pub argc: ::libc::c_int,
    pub argv: *mut *mut ::libc::c_char,
    pub endARGV: *mut *mut ::libc::c_char,
}
extern "C" {
    #[doc = "!\tDefault location for the system argv structure."]
    pub static mut __system_argv: *mut __argv;
}
#[doc = "struct _dsp_task dsptask_t\nforward typdef to struct _dsp_task. This struture holds certain DSP task information for execution."]
pub type dsptask_t = _dsp_task;
#[doc = "void (*DSPTaskCallback)(dsptask_t *task)\nfunction pointer typedef for the user's DSP task callbacks\n# Arguments\n\n* `task` (direction in) - pointer to the dsp_task structure."]
pub type DSPTaskCallback = ::core::option::Option<unsafe extern "C" fn(task: *mut dsptask_t)>;
#[doc = "void (*DSPCallback)(void)\nfunction pointer typedef for the user's DSP interrupt callback"]
pub type DSPCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "struct _dsp_task dsptask_t\n# Arguments\n\n* `state` - current task dsp_taskstate \"state\" set\n* `prio` - priority of the task\n* `flags` - currnet task dsp_taskflag \"flag(s)\" set.\n* `init_vec` - initialization vector. depends on the DSP code to execute.\n* `resume_vec` - resume vector. depends on the DSP code to execute.\n* `iram_maddr` - main memory address of i-ram image. NOTE: Has to be aligned on a 32byte boundery!\n* `iram_len` - size of i-ram image. NOTE: Should be a multiple of 32\n* `iram_addr` - DSP i-ram address to load the image to.\n* `dram_maddr` - main memory address of d-ram image. NOTE: Has to be aligned on a 32byte boundery!\n* `dram_len` - size of d-ram image. NOTE: Should be a multiple of 32\n* `dram_addr` - DSP d-ram address to load the image to.\n* `init_cb` - pointer to the user's init callback function. Called durring task initialization.\n* `res_cb` - pointer to the user's resume callback function. Called when the task should resume.\n* `done_cb` - pointer to the user's done callback function. Called when the task has finished.\n* `req_cb` - pointer to the user's request callback function. Used to retrieve data from main application durring execution.\n* `next` - pointer to the next task in the doubly linked list.\n* `prev` - pointer to the previous task in the doubly linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dsp_task {
    pub state: vu32,
    pub prio: vu32,
    pub flags: vu32,
    pub iram_maddr: *mut ::libc::c_void,
    pub iram_len: u32_,
    pub iram_addr: u32_,
    pub dram_maddr: *mut ::libc::c_void,
    pub dram_len: u32_,
    pub dram_addr: u32_,
    pub init_vec: u16_,
    pub resume_vec: u16_,
    pub init_cb: DSPTaskCallback,
    pub res_cb: DSPTaskCallback,
    pub done_cb: DSPTaskCallback,
    pub req_cb: DSPTaskCallback,
    pub next: *mut _dsp_task,
    pub prev: *mut _dsp_task,
}
extern "C" {
    #[doc = "void DSP_Init(void)\nInitialize DSP subsystem.\n\n# Returns\n\nnone"]
    pub fn DSP_Init();
}
extern "C" {
    #[doc = "u32 DSP_CheckMailTo(void)\nCheck if mail was sent to DSP\n\n# Returns\n\n1: mail sent, 0: mail on route"]
    pub fn DSP_CheckMailTo() -> u32_;
}
extern "C" {
    #[doc = "u32 DSP_CheckMailFrom(void)\nCheck for mail from DSP\n\n# Returns\n\n1: has mail, 0: no mail"]
    pub fn DSP_CheckMailFrom() -> u32_;
}
extern "C" {
    #[doc = "u32 DSP_ReadMailFrom(void)\nRead mail from DSP\n\n# Returns\n\nmail value received"]
    pub fn DSP_ReadMailFrom() -> u32_;
}
extern "C" {
    #[doc = "void DSP_AssertInt(void)\nAsserts the processor interface interrupt\n\n# Returns\n\nnone"]
    pub fn DSP_AssertInt();
}
extern "C" {
    #[doc = "void DSP_SendMailTo(u32 mail)\nSend mail to DSP\n# Arguments\n\n* `mail` (direction in) - value to send\n\n# Returns\n\nnone"]
    pub fn DSP_SendMailTo(mail: u32_);
}
extern "C" {
    #[doc = "u32 DSP_ReadCPUtoDSP(void)\nRead back CPU->DSP mailbox\n\n# Returns\n\nmail value received"]
    pub fn DSP_ReadCPUtoDSP() -> u32_;
}
extern "C" {
    #[doc = "dsptask_t* DSP_AddTask(dsptask_t *task)\nAdd a DSP task to the tasklist and start executing if necessary.\n# Arguments\n\n* `task` (direction in) - pointer to a dsptask_t structure which holds all necessary values for DSP task execution.\n\n# Returns\n\ncurrent task"]
    pub fn DSP_AddTask(task: *mut dsptask_t) -> *mut dsptask_t;
}
extern "C" {
    pub fn DSP_AssertTask(task: *mut dsptask_t) -> *mut dsptask_t;
}
extern "C" {
    pub fn DSP_CancelTask(task: *mut dsptask_t);
}
extern "C" {
    pub fn DSP_Reset();
}
extern "C" {
    pub fn DSP_Halt();
}
extern "C" {
    pub fn DSP_Unhalt();
}
extern "C" {
    pub fn DSP_GetDMAStatus() -> u32_;
}
extern "C" {
    #[doc = "DSPCallback DSP_RegisterCallback(DSPCallback usr_cb)\nRegister an user's interrupt callback. This may be used to handle DSP interrupts on its own. By default a system default callback is installed on DSP_Init().\n# Arguments\n\n* `user_cb` (direction in) - pointer to the user's interrupt callback function.\n\n# Returns\n\npointer to old interrupt callback function."]
    pub fn DSP_RegisterCallback(usr_cb: DSPCallback) -> DSPCallback;
}
pub type BOOL = ::libc::c_uint;
#[doc = "void (*ARCallback)(void)\n function pointer typedef for the user's ARAM interrupt callback\n\n # Arguments\n\n* `none` -"]
pub type ARCallback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = "ARCallback AR_RegisterCallback(ARCallback callback)\n Register the given function as a DMA callback\n\n Any existing callback is replaced unconditionally\n\n # Arguments\n\n* `callback` (direction in) - to be invoked upon completion of DMA transaction\n\n # Returns\n\npointer to the previously registered callback and NULL respectively"]
    pub fn AR_RegisterCallback(callback: ARCallback) -> ARCallback;
}
extern "C" {
    #[doc = "u32 AR_GetDMAStatus(void)\n Get current status of DMA\n\n # Returns\n\nzero if DMA is idle, non-zero if a DMA is in progress"]
    pub fn AR_GetDMAStatus() -> u32_;
}
extern "C" {
    #[doc = "u32 AR_Init(u32 *stack_idx_array,u32 num_entries)\n Initializes ARAM subsystem.\n\n Following tasks are performed:\n\n - Disables ARAM DMA\n - Sets DMA callback to NULL\n - Initializes ARAM controller\n - Determines size of ARAM memory\n - Initializes the ARAM stack based memory allocation system<br>\n\n The parameter u32 *stack_idx_array points to an array of u32 integers. The parameter u32 num_entries specifies the number of entries in this array.<br>\n The user application is responsible for determining how many ARAM blocks the device driver can allocate.<br>\n\n As an example, consider:\n #define MAX_NUM_BLOCKS 10\n\n u32 aram_blocks[MAX_NUM_BLOCKS];\n ...\n void func(void)\n {\n AR_Init(aram_blocks, MAX_NUM_BLOCKS);\n }\n Here, we are telling AR that the application will allocate, at most, 10 blocks (of arbitrary size), and that AR should store addresses for those blocks in the array aram_blocks. Note that the array is simply storage supplied by the application so that AR can track the number and size of memory blocks allocated by AR_Alloc().\n AR_Free()also uses this array to release blocks.<br>\n If you do not wish to use AR_Alloc() and AR_Free() and would rather manage ARAM usage within your application, then call AR_Init() like so:<br>\n\n AR_Init(NULL, 0);<br>\n\n The AR_Init() function also calculates the total size of the ARAM aggregate. Note that this procedure is <b><i>destructive</i></b> - i.e., any data stored in ARAM will be corrupted.<br>\n AR_Init()may be invoked multiple times. This function checks the state of an initialization flag; if asserted, this function will simply exit on subsequent calls. To perform another initialization of the ARAM driver, call AR_Reset() before invoking AR_Init() again.\n\n # Arguments\n\n* `stack_idx_array` (direction in) - pointer to an array of u32 integer\n * `num_entries` (direction in) - number of entries in the specified array\n\n # Returns\n\nbase address of the \"user\" ARAM area. As of this writing, the operating system reserves the bottom 16 KB of ARAM. Therefore, AR_Init() returns 0x04000 to indicate the starting location of the ARAM user area."]
    pub fn AR_Init(stack_idx_array: *mut u32_, num_entries: u32_) -> u32_;
}
extern "C" {
    #[doc = "void AR_StartDMA(u32 dir,u32 memaddr,u32 aramaddr,u32 len)\n Initiates a DMA between main memory and ARAM.\n\n This function:\n\n - Does <b><i>not</i></b> perform boundery-checking on addresses and lengths.\n - Will assert failure if a DMA is allready in progress.\n - Is provided for debugging purpose. Application programmers must use the ARQ API in order to access ARAM.\n\n # Arguments\n\n* `dir` (direction in) - specifies the dmamode \"direction\" of transfer.\n * `memaddr` (direction in) - specifies main memory address for the transfer\n * `aramaddr` (direction in) - specifies the ARAM address for the transfer. <b><i>NOTE:</i></b> Addresses are 27bits wide and refer to bytes\n * `len` (direction in) - specifies the length of the block to transfer. <b><i>NOTE:</i></b> Must be in bytes and a multiple of 32\n\n # Returns\n\nnone"]
    pub fn AR_StartDMA(dir: u32_, memaddr: u32_, aramaddr: u32_, len: u32_);
}
extern "C" {
    #[doc = "u32 AR_Alloc(u32 len)\n Allocate a block of memory from ARAM having <i>len</i> bytes.\n\n The <i>len</i> parameter <b><i>must</i></b> be a multiple of 32\n\n # Arguments\n\n* `len` (direction in) - length of the specified block of memory in ARAM\n\n # Returns\n\naddress of the block if successful, otherwise NULL"]
    pub fn AR_Alloc(len: u32_) -> u32_;
}
extern "C" {
    #[doc = "u32 AR_Free(u32 *len)\n Free a block from ARAM\n\n # Arguments\n\n* `len` (direction out) - pointer to receive the length of the free'd ARAM block. This is optional and can be NULL.\n\n # Returns\n\nARAM current baseaddress after free'ing the block"]
    pub fn AR_Free(len: *mut u32_) -> u32_;
}
extern "C" {
    #[doc = "void AR_Clear(u32 flag)\n Clear ARAM memory\n\n # Arguments\n\n* `flag` (direction in) - specifies the region of ARAM to clear\n\n # Returns\n\nnone"]
    pub fn AR_Clear(flag: u32_);
}
extern "C" {
    #[doc = "BOOL AR_CheckInit(void)\n Get the ARAM subsystem initialization flag\n\n # Returns\n\nTRUE if the ARAM subsystem has been initialized(via AR_Init())<br>\n FALSE if the ARAM subsystem has not been initialized, or has been reset(via AR_Reset())"]
    pub fn AR_CheckInit() -> BOOL;
}
extern "C" {
    #[doc = "void AR_Reset(void)\n Clears the ARAM subsystem initialization flag.\n\n Calling AR_Init() after this function will cause a \"real\" initialization of ARAM\n\n # Returns\n\nnone"]
    pub fn AR_Reset();
}
extern "C" {
    #[doc = "u32 AR_GetSize(void)\n Get the total size - in bytes - of ARAM as calculated during AR_Init()\n\n # Returns\n\nsize of the specified ARAM block"]
    pub fn AR_GetSize() -> u32_;
}
extern "C" {
    #[doc = "u32 AR_GetBaseAddress(void)\n Get the baseaddress of ARAM memory\n\n # Returns\n\nARAM memory baseaddress"]
    pub fn AR_GetBaseAddress() -> u32_;
}
extern "C" {
    #[doc = "u32 AR_GetInternalSize(void)\n Get the size of the internal ARAM memory\n\n # Returns\n\nARAM internal memory size"]
    pub fn AR_GetInternalSize() -> u32_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwpnode {
    pub next: *mut _lwpnode,
    pub prev: *mut _lwpnode,
}
pub type lwp_node = _lwpnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lwpqueue {
    pub first: *mut lwp_node,
    pub perm_null: *mut lwp_node,
    pub last: *mut lwp_node,
}
pub type lwp_queue = _lwpqueue;
extern "C" {
    pub fn __lwp_queue_initialize(
        arg1: *mut lwp_queue,
        arg2: *mut ::libc::c_void,
        arg3: u32_,
        arg4: u32_,
    );
}
extern "C" {
    pub fn __lwp_queue_get(arg1: *mut lwp_queue) -> *mut lwp_node;
}
extern "C" {
    pub fn __lwp_queue_append(arg1: *mut lwp_queue, arg2: *mut lwp_node);
}
extern "C" {
    pub fn __lwp_queue_extract(arg1: *mut lwp_node);
}
extern "C" {
    pub fn __lwp_queue_insert(arg1: *mut lwp_node, arg2: *mut lwp_node);
}
pub const ARQ_TASK_READY: _bindgen_ty_1 = 0;
pub const ARQ_TASK_RUNNING: _bindgen_ty_1 = 1;
pub const ARQ_TASK_FINISHED: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::libc::c_uint;
pub type ARQRequest = _arq_request;
pub type ARQCallback = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ARQRequest)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _arq_request {
    pub node: lwp_node,
    pub owner: u32_,
    pub dir: u32_,
    pub prio: u32_,
    pub state: u32_,
    pub aram_addr: u32_,
    pub mram_addr: u32_,
    pub len: u32_,
    pub callback: ARQCallback,
}
extern "C" {
    pub fn ARQ_Init();
}
extern "C" {
    pub fn ARQ_Reset();
}
extern "C" {
    #[doc = "void ARQ_PostRequest(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len)\n Enqueue a ARAM DMA transfer request.\n\n # Arguments\n\n* `req` (direction in) - structure to hold ARAM DMA request informations.\n * `owner` (direction in) - unique owner id.\n * `dir` (direction in) - direction of ARAM DMA transfer.\n * `prio` (direction in) - priority of request.\n * `aram_addr` (direction in) - startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n * `mram_addr` (direction in) - length of data to be pushed onto the queue.\n * `len` (direction in) - startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n * `cb` (direction in) - length of data to be pushed onto the queue.\n\n # Returns\n\nnone"]
    pub fn ARQ_PostRequest(
        req: *mut ARQRequest,
        owner: u32_,
        dir: u32_,
        prio: u32_,
        aram_addr: u32_,
        mram_addr: u32_,
        len: u32_,
    );
}
extern "C" {
    #[doc = "void ARQ_PostRequestAsync(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len,ARQCallback cb)\n Enqueue a ARAM DMA transfer request.\n\n # Arguments\n\n* `req` (direction in) - structure to hold ARAM DMA request informations.\n * `owner` (direction in) - unique owner id.\n * `dir` (direction in) - direction of ARAM DMA transfer.\n * `prio` (direction in) - priority of request.\n * `aram_addr` (direction in) - startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n * `mram_addr` (direction in) - length of data to be pushed onto the queue.\n * `len` (direction in) - startaddress of buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32-bytealigned.\n * `cb` (direction in) - length of data to be pushed onto the queue.\n\n # Returns\n\nnone"]
    pub fn ARQ_PostRequestAsync(
        req: *mut ARQRequest,
        owner: u32_,
        dir: u32_,
        prio: u32_,
        aram_addr: u32_,
        mram_addr: u32_,
        len: u32_,
        cb: ARQCallback,
    );
}
extern "C" {
    pub fn ARQ_RemoveRequest(req: *mut ARQRequest);
}
extern "C" {
    pub fn ARQ_SetChunkSize(size: u32_);
}
extern "C" {
    pub fn ARQ_GetChunkSize() -> u32_;
}
extern "C" {
    pub fn ARQ_FlushQueue();
}
extern "C" {
    pub fn ARQ_RemoveOwnerRequest(owner: u32_) -> u32_;
}
#[doc = "void (*ARQMCallback)(s32 result)\n function pointer typedef for the user's callback when an ARAM operation has completed\n # Arguments\n\n* `result` (direction in) - The result of the ARAM operation."]
pub type ARQMCallback = ::core::option::Option<unsafe extern "C" fn(result: s32)>;
extern "C" {
    #[doc = "void ARQM_Init(u32 arambase,s32 len)\n Initialize the ARAM queue management system\n\n # Arguments\n\n* `arambase` (direction in) - ARAM startaddress to take for the queue stack\n * `len` (direction in) - maximum amount of memory to be reserved from the ARAM for the queue management\n\n # Returns\n\nnone"]
    pub fn ARQM_Init(arambase: u32_, len: s32);
}
extern "C" {
    #[doc = "u32 ARQM_PushData(void *buffer,s32 len)\n Push the data onto the ARAM queue\n\n # Arguments\n\n* `buffer` (direction in) - starting address of a buffer to be pushed onto the queue. <b><i>NOTE:</i></b> Must be 32 byte aligned.\n * `len` (direction in) - length of data to be pushed onto the queue.\n\n # Returns\n\nThe ARAM starting address for the pushed data."]
    pub fn ARQM_PushData(buffer: *mut ::libc::c_void, len: s32) -> u32_;
}
extern "C" {
    pub fn ARQM_Pop();
}
extern "C" {
    #[doc = "u32 ARQM_GetZeroBuffer(void)\n Returns ARAM address of 'zero buffer'\n\n # Returns\n\nSee description"]
    pub fn ARQM_GetZeroBuffer() -> u32_;
}
extern "C" {
    #[doc = "u32 ARQM_GetStackPointer(void)\n Return the ARAM address of the next free stack pointer\n\n # Returns\n\nSee description"]
    pub fn ARQM_GetStackPointer() -> u32_;
}
extern "C" {
    #[doc = "u32 ARQM_GetFreeSize(void)\n Return Returns remaining number of bytes on stack\n\n # Returns\n\nSee description"]
    pub fn ARQM_GetFreeSize() -> u32_;
}
#[doc = "void (*AIDCallback)(void)\n function pointer typedef for the user's Audio DMA interrupt callback\n\n # Arguments\n\n* `none` -"]
pub type AIDCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "void (*AISCallback)(u32 smp_cnt)\n function pointer typedef for the user's Audio Streaming interrupt callback\n\n # Arguments\n\n* `smp_cnt` - AI sample count"]
pub type AISCallback = ::core::option::Option<unsafe extern "C" fn(smp_cnt: u32_)>;
extern "C" {
    #[doc = "AISCallback AUDIO_RegisterStreamCallback(AISCallback callback)\n Register a user callback function for the AUDIO streaming interface\n\n # Arguments\n\n* `callback` (direction in) - pointer to the function which to call when AIS interrupt has triggered.\n\n # Returns\n\npointer to old callback function or NULL respectively."]
    pub fn AUDIO_RegisterStreamCallback(callback: AISCallback) -> AISCallback;
}
extern "C" {
    #[doc = "void AUDIO_Init(u8 *stack)\n Initialize the AUDIO subsystem\n\n # Arguments\n\n* `stack` (direction in) - pointer to a memory area to work as stack when calling the callbacks. May be NULL\n\n # Returns\n\nnone"]
    pub fn AUDIO_Init(stack: *mut u8_);
}
extern "C" {
    #[doc = "void AUDIO_SetStreamVolLeft(u8 vol)\n Set streaming volume on the left channel.\n\n # Arguments\n\n* `vol` (direction in) - level of volume 0<= vol <=255\n\n # Returns\n\nnone"]
    pub fn AUDIO_SetStreamVolLeft(vol: u8_);
}
extern "C" {
    #[doc = "u8 AUDIO_GetStreamVolLeft(void)\n Get streaming volume of the left channel.\n\n # Returns\n\nlevel of volume."]
    pub fn AUDIO_GetStreamVolLeft() -> u8_;
}
extern "C" {
    #[doc = "void AUDIO_SetStreamVolRight(u8 vol)\n set streaming volume of the right channel.\n\n # Arguments\n\n* `vol` (direction in) - level of volume 0<= vol <=255\n\n # Returns\n\nnone"]
    pub fn AUDIO_SetStreamVolRight(vol: u8_);
}
extern "C" {
    #[doc = "u8 AUDIO_GetStreamVolRight(void)\n Get streaming volume of the right channel.\n\n # Returns\n\nlevel of volume."]
    pub fn AUDIO_GetStreamVolRight() -> u8_;
}
extern "C" {
    #[doc = "void AUDIO_SetStreamSampleRate(u32 rate)\n Set streaming sample rate\n\n # Arguments\n\n* `rate` (direction in) - streaming ai_sample_rates \"sample rate\"\n\n # Returns\n\nnone"]
    pub fn AUDIO_SetStreamSampleRate(rate: u32_);
}
extern "C" {
    #[doc = "u32 AUDIO_GetStreamSampleRate(void)\n Get streaming sample rate\n\n # Returns\n\nai_sample_rates \"sample rate\""]
    pub fn AUDIO_GetStreamSampleRate() -> u32_;
}
extern "C" {
    #[doc = "AIDCallback AUDIO_RegisterDMACallback(AIDCallback callback)\n Register a user callback function for the audio DMA interface.\n\n This callback will be called whenever the audio DMA requests new data.<br>\n Internally the DMA buffers are double buffered.\n\n # Arguments\n\n* `callback` (direction in) - pointer to the function which to call when AID interrupt has triggered.\n\n # Returns\n\npointer to old callback function or NULL respectively."]
    pub fn AUDIO_RegisterDMACallback(callback: AIDCallback) -> AIDCallback;
}
extern "C" {
    #[doc = "void AUDIO_InitDMA(u32 startaddr,u32 len)\n Initialize an audio DMA transfer\n\n # Arguments\n\n* `startaddr` (direction in) - start address of the memory region to load into the audio DMA. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery!\n * `len` (direction in) - lenght of data to load into the audio DMA. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn AUDIO_InitDMA(startaddr: u32_, len: u32_);
}
extern "C" {
    #[doc = "u16 AUDIO_GetDMAEnableFlag(void)\n Get the audio DMA flag\n\n # Returns\n\nstate of the current DMA operation."]
    pub fn AUDIO_GetDMAEnableFlag() -> u16_;
}
extern "C" {
    #[doc = "void AUDIO_StartDMA(void)\n Start the audio DMA operation.\n\n Starts to transfer the data from main memory to the audio interface thru DMA.<br>\n This call should follow the call to AUDIO_InitDMA() which is used to initialize DMA transfers.\n\n # Returns\n\nnone"]
    pub fn AUDIO_StartDMA();
}
extern "C" {
    #[doc = "void AUDIO_StopDMA(void)\n Stop the previously started audio DMA operation.\n\n # Returns\n\nnone"]
    pub fn AUDIO_StopDMA();
}
extern "C" {
    #[doc = "u32 AUDIO_GetDMABytesLeft(void)\n Get the count of bytes, left to play, from the audio DMA interface\n\n # Returns\n\ncount of bytes left to play."]
    pub fn AUDIO_GetDMABytesLeft() -> u32_;
}
extern "C" {
    #[doc = "u32 AUDIO_GetDMALength(void)\n Get the DMA transfer length configured in the audio DMA interface.\n\n # Returns\n\nlength of data loaded into the audio DMA interface."]
    pub fn AUDIO_GetDMALength() -> u32_;
}
extern "C" {
    #[doc = "u32 AUDIO_GetDMAStartAddr(void)\n Get the main memory address for the DMA operation.\n\n # Returns\n\nstart address of mainmemory loaded into the audio DMA interface."]
    pub fn AUDIO_GetDMAStartAddr() -> u32_;
}
extern "C" {
    #[doc = "void AUDIO_SetStreamTrigger(u32 cnt)\n Set the sample count for the stream trigger\n\n # Arguments\n\n* `cnt` (direction in) - count of samples when to trigger the audio stream.\n\n # Returns\n\nnone"]
    pub fn AUDIO_SetStreamTrigger(cnt: u32_);
}
extern "C" {
    #[doc = "void AUDIO_ResetStreamSampleCnt(void)\n Reset the stream sample count register.\n\n # Returns\n\nnone"]
    pub fn AUDIO_ResetStreamSampleCnt();
}
extern "C" {
    #[doc = "void AUDIO_SetDSPSampleRate(u8 rate)\n Set the sampling rate for the DSP interface\n\n # Arguments\n\n* `rate` (direction in) - sampling rate to set for the DSP (AI_SAMPLERATE_32KHZ,AI_SAMPLERATE_48KHZ)\n\n # Returns\n\nnone"]
    pub fn AUDIO_SetDSPSampleRate(rate: u8_);
}
extern "C" {
    #[doc = "u32 AUDIO_GetDSPSampleRate(void)\n Get the sampling rate for the DSP interface\n\n # Returns\n\nDSP sampling rate (AI_SAMPLERATE_32KHZ,AI_SAMPLERATE_48KHZ)"]
    pub fn AUDIO_GetDSPSampleRate() -> u32_;
}
extern "C" {
    #[doc = "void AUDIO_SetStreamPlayState(u32 state)\n Set the play state for the streaming audio interface\n\n # Arguments\n\n* `state` (direction in) - playstate of the streaming audio interface (AI_STREAM_STOP,AI_STREAM_START)\n\n # Returns\n\nnone"]
    pub fn AUDIO_SetStreamPlayState(state: u32_);
}
extern "C" {
    #[doc = "u32 AUDIO_GetStreamPlayState(void)\n Get the play state from the streaming audio interface\n\n # Returns\n\nplaystate (AI_STREAM_STOP,AI_STREAM_START)"]
    pub fn AUDIO_GetStreamPlayState() -> u32_;
}
extern "C" {
    #[doc = "void DCEnable(void)\n Enable L1 d-cache\n\n # Returns\n\nnone"]
    pub fn DCEnable();
}
extern "C" {
    #[doc = "void DCDisable(void)\n Disable L1 d-cache\n\n # Returns\n\nnone"]
    pub fn DCDisable();
}
extern "C" {
    #[doc = "void DCFreeze(void)\n Current contents of the L1 d-cache are locked down and will not be cast out.\n\n Hits are still serviced, but misses go straight to L2 or 60x bus. Most cache operations, such as DCFlushRange(), will still execute regardless of whether the cache is frozen.<br>\n\t <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache. We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n # Returns\n\nnone"]
    pub fn DCFreeze();
}
extern "C" {
    #[doc = "void DCUnfreeze(void)\n Undoes actions of DCFreeze().\n\n Old cache blocks will now be cast out on subsequent L1 misses.<br>\n \t <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache. We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n # Returns\n\nnone"]
    pub fn DCUnfreeze();
}
extern "C" {
    #[doc = "void DCFlashInvalidate(void)\n Invalidate L1 d-cache.\n\n An invalidate operation is issued that marks the state of each data cache block as invalid without writing back modified cache blocks to memory.<br>\n Cache access is blocked during this time.Bus accesses to the cache are signaled as a miss during invalidate-all operations.\n\n # Returns\n\nnone"]
    pub fn DCFlashInvalidate();
}
extern "C" {
    #[doc = "void DCInvalidateRange(void *startaddress,u32 len)\n Invalidates a given range of the d-cache.\n\n If any part of the range hits in the d-cache, the corresponding block will be invalidated.\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to invalidate. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of the range to invalidate. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn DCInvalidateRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void DCFlushRange(void *startaddress,u32 len)\n Flushes a given range.\n\n If any part of the range hits in the d-cache the corresponding block will be flushed to main memory and invalidated.<br>\n <b><i>NOTE:</i></b> This function invokes a \"sync\" after flushing the range. This means the function will stall until the CPU knows that the data has been writen to main memory\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to flush. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of range to be flushed. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n# Returns\n\nnone"]
    pub fn DCFlushRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void DCStoreRange(void *startaddress,u32 len)\n Ensures a range of memory is updated with any modified data in the cache.\n\n <b><i>NOTE:</i></b> This function invokes a \"sync\" after storing the range. This means the function will stall until the CPU knows that the data has been writen to main memory\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to store. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of the range to store. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn DCStoreRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void DCFlushRangeNoSync(void *startaddress,u32 len)\n Flushes a given range.\n\n If any part of the range hits in the d-cache the corresponding block will be flushed to main memory and invalidated.<br>\n <b><i>NOTE:</i></b> This routine does not perform a \"sync\" to ensure that the range has been flushed to memory. That is, the cache blocks are sent to the bus interface unit for storage to main memory, but by the time this function returns, you are not guaranteed that the blocks have been written to memory.\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to flush. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of range to be flushed. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn DCFlushRangeNoSync(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void DCStoreRangeNoSync(void *startaddress,u32 len)\n Ensures a range of memory is updated with any modified data in the cache.\n\n <b><i>NOTE:</i></b> This routine does not perform a \"sync\" to ensure that the range has been flushed to memory. That is, the cache blocks are sent to the bus interface unit for storage to main memory, but by the time this function returns, you are not guaranteed that the blocks have been written to memory\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to store. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of the range to store. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn DCStoreRangeNoSync(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void DCZeroRange(void *startaddress,u32 len)\n Loads a range of memory into cache and zeroes all the cache lines.\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to load/zero. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of the range to load/zero. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn DCZeroRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void DCTouchRange(void *startaddress,u32 len)\n Loads a range of memory into cache.\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to load. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of the range to load. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn DCTouchRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    #[doc = "void ICSync(void)\n Performs an instruction cache synchronization.\n\n This ensures that all instructions preceding this instruction have completed before this instruction completes.\n\n # Returns\n\nnone"]
    pub fn ICSync();
}
extern "C" {
    #[doc = "void ICFlashInvalidate(void)\n Invalidate the L1 i-cache.\n\n An invalidate operation is issued that marks the state of each instruction cache block as invalid without writing back modified cache blocks to memory.<br>\n Cache access is blocked during this time. Bus accesses to the cache are signaled as a miss during invalidate-all operations.\n\n # Returns\n\nnone"]
    pub fn ICFlashInvalidate();
}
extern "C" {
    #[doc = "void ICEnable(void)\n Enable L1 i-cache\n\n # Returns\n\nnone"]
    pub fn ICEnable();
}
extern "C" {
    #[doc = "void ICDisable(void)\n Disable L1 i-cache\n\n # Returns\n\nnone"]
    pub fn ICDisable();
}
extern "C" {
    #[doc = "void ICFreeze(void)\n Current contents of the L1 i-cache are locked down and will not be cast out.\n\n Hits are still serviced, but misses go straight to L2 or 60x bus.<br>\n\t <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache. We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n # Returns\n\nnone"]
    pub fn ICFreeze();
}
extern "C" {
    #[doc = "void ICUnfreeze(void)\n Undoes actions of ICFreeze().\n\n Old cache blocks will now be cast out on subsequent L1 misses.<br>\n\t <b><i>NOTE:</i></b> In PowerPC architecture jargon, this feature is referred to as \"locking\" the data cache. We use the word \"freeze\" to distinguish it from the locked cache and DMA features.\n\n # Returns\n\nnone"]
    pub fn ICUnfreeze();
}
extern "C" {
    #[doc = "void ICBlockInvalidate(void *startaddress)\n Invalidates a block in the i-cache.\n\n If the block hits in the i-cache, the corresponding block will be invalidated.\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory block to invalidate. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n\n# Returns\n\nnone"]
    pub fn ICBlockInvalidate(startaddress: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "void ICInvalidateRange(void *startaddress,u32 len)\n Invalidate a range in the L1 i-cache.\n\n If any part of the range hits in the i-cache, the corresponding block will be invalidated.\n\n # Arguments\n\n* `startaddress` (direction in) - pointer to the startaddress of the memory range to invalidate. <b><i>NOTE:</i></b> Has to be aligned on a 32byte boundery\n * `len` (direction in) - length of the range to invalidate. <b><i>NOTE:</i></b> Should be a multiple of 32\n\n # Returns\n\nnone"]
    pub fn ICInvalidateRange(startaddress: *mut ::libc::c_void, len: u32_);
}
extern "C" {
    pub fn L2Enhance();
}
extern "C" {
    pub fn LCEnable();
}
extern "C" {
    pub fn LCDisable();
}
extern "C" {
    pub fn LCLoadBlocks(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_);
}
extern "C" {
    pub fn LCStoreBlocks(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_);
}
extern "C" {
    pub fn LCLoadData(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_) -> u32_;
}
extern "C" {
    pub fn LCStoreData(arg1: *mut ::libc::c_void, arg2: *mut ::libc::c_void, arg3: u32_) -> u32_;
}
extern "C" {
    pub fn LCQueueLength() -> u32_;
}
extern "C" {
    pub fn LCQueueWait(arg1: u32_) -> u32_;
}
extern "C" {
    pub fn LCFlushQueue();
}
extern "C" {
    pub fn LCAlloc(arg1: *mut ::libc::c_void, arg2: u32_);
}
extern "C" {
    pub fn LCAllocNoInvalidate(arg1: *mut ::libc::c_void, arg2: u32_);
}
extern "C" {
    pub fn LCAllocOneTag(arg1: BOOL, arg2: *mut ::libc::c_void);
}
extern "C" {
    pub fn LCAllocTags(arg1: BOOL, arg2: *mut ::libc::c_void, arg3: u32_);
}
#[doc = "struct _card_file card_file\nstructure to hold the fileinformations upon open and for later use.\n# Arguments\n\n* `chn` - CARD slot.\n* `filenum` - file index in the card directory structure.\n* `offset` - offset into the file.\n* `len` - length of file.\n* `iblock` - block index on memory card."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_file {
    pub chn: s32,
    pub filenum: s32,
    pub offset: s32,
    pub len: s32,
    pub iblock: u16_,
}
#[doc = "struct _card_file card_file\nstructure to hold the fileinformations upon open and for later use.\n# Arguments\n\n* `chn` - CARD slot.\n* `filenum` - file index in the card directory structure.\n* `offset` - offset into the file.\n* `len` - length of file.\n* `iblock` - block index on memory card."]
pub type card_file = _card_file;
#[doc = "struct card_dir\nstructure to hold the information of a directory entry\n# Arguments\n\n* `chn` - CARD slot.\n* `fileno` - file index in the card directory structure.\n* `filelen` - length of file.\n* `filename[CARD_FILENAMELEN]` - name of the file on card.\n* `gamecode[4]` - string identifier <=4.\n* `company[2]` - string identifier <=2.\n* `showall` - boolean flag whether to showall entries or ony those identified by card_gamecode and card_company, previously set within the call to CARD_Init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_dir {
    pub chn: s32,
    pub fileno: u32_,
    pub filelen: u32_,
    pub permissions: u8_,
    pub filename: [::libc::c_char; 32usize],
    pub gamecode: [u8_; 4usize],
    pub company: [u8_; 2usize],
    pub showall: bool,
}
#[doc = "struct card_dir\nstructure to hold the information of a directory entry\n# Arguments\n\n* `chn` - CARD slot.\n* `fileno` - file index in the card directory structure.\n* `filelen` - length of file.\n* `filename[CARD_FILENAMELEN]` - name of the file on card.\n* `gamecode[4]` - string identifier <=4.\n* `company[2]` - string identifier <=2.\n* `showall` - boolean flag whether to showall entries or ony those identified by card_gamecode and card_company, previously set within the call to CARD_Init()"]
pub type card_dir = _card_dir;
#[doc = "struct card_direntry\nstructure to hold the information of the save file entry ( aka GCI )\n# Arguments\n\n* `gamecode[4]` - string identifier <=4.\n* `company[2]` - string identifier <=2.\n* `padding` - always 0xFF.\n* `banner_fmt` - format of banner.\n* `filename[CARD_FILENAMELEN]` - name of the file on card.\n* `last_modified` - last time it was modified,in seconds since 1970 in seconds.\n* `icon_addr` - icon image address in file.\n* `icon_fmt` - icon image format.\n* `icon_speed` - speed of an animated icon.\n* `permission` - permissions of the save file.\n* `copy_times` - how many times the save file has been copied.\n* `block` - starting block of the save file.\n* `length` - size of the save file..\n* `padding` - always 0xFFFF.\n* `comment_addr` - address in file of the comment block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_direntry {
    pub gamecode: [u8_; 4usize],
    pub company: [u8_; 2usize],
    pub pad_00: u8_,
    pub banner_fmt: u8_,
    pub filename: [u8_; 32usize],
    pub last_modified: u32_,
    pub icon_addr: u32_,
    pub icon_fmt: u16_,
    pub icon_speed: u16_,
    pub permission: u8_,
    pub copy_times: u8_,
    pub block: u16_,
    pub length: u16_,
    pub pad_01: u16_,
    pub comment_addr: u32_,
}
#[doc = "struct card_direntry\nstructure to hold the information of the save file entry ( aka GCI )\n# Arguments\n\n* `gamecode[4]` - string identifier <=4.\n* `company[2]` - string identifier <=2.\n* `padding` - always 0xFF.\n* `banner_fmt` - format of banner.\n* `filename[CARD_FILENAMELEN]` - name of the file on card.\n* `last_modified` - last time it was modified,in seconds since 1970 in seconds.\n* `icon_addr` - icon image address in file.\n* `icon_fmt` - icon image format.\n* `icon_speed` - speed of an animated icon.\n* `permission` - permissions of the save file.\n* `copy_times` - how many times the save file has been copied.\n* `block` - starting block of the save file.\n* `length` - size of the save file..\n* `padding` - always 0xFFFF.\n* `comment_addr` - address in file of the comment block."]
pub type card_direntry = _card_direntry;
#[doc = "struct card_stat\nstructure to hold the additional statistical informations.\n# Arguments\n\n* `filename[CARD_FILENAMELEN]` - name of the file on card.\n* `len` - length of file.\n* `gamecode[4]` - string identifier <=4.\n* `company[2]` - string identifier <=2.\n* `banner_fmt` - format of banner.\n* `icon_addr` - icon image address in file.\n* `icon_fmt` - icon image format.\n* `icon_speed` - speed of an animated icon.\n* `comment_addr` - address in file of the comment block.\n* `offset_banner` - offset in file to the banner's image data.\n* `offset_banner_tlut` - offset in file to the banner's texture lookup table.\n* `offset_icon[CARD_MAXICONS]` - array of offsets in file to the icon's image data <CARD_MAXICONS.\n* `offset_icon_tlut` - offset in file to the icons's texture lookup table.\n* `offset_data` - offset to additional data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _card_stat {
    pub filename: [::libc::c_char; 32usize],
    pub len: u32_,
    pub time: u32_,
    pub gamecode: [u8_; 4usize],
    pub company: [u8_; 2usize],
    pub banner_fmt: u8_,
    pub icon_addr: u32_,
    pub icon_fmt: u16_,
    pub iconfmt: [u16_; 8usize],
    pub icon_speed: u16_,
    pub iconspeed: [u16_; 8usize],
    pub comment_addr: u32_,
    pub offset_banner: u32_,
    pub offset_banner_tlut: u32_,
    pub offset_icon: [u32_; 8usize],
    pub offset_icon_tlut: [u32_; 8usize],
    pub offset_data: u32_,
}
#[doc = "struct card_stat\nstructure to hold the additional statistical informations.\n# Arguments\n\n* `filename[CARD_FILENAMELEN]` - name of the file on card.\n* `len` - length of file.\n* `gamecode[4]` - string identifier <=4.\n* `company[2]` - string identifier <=2.\n* `banner_fmt` - format of banner.\n* `icon_addr` - icon image address in file.\n* `icon_fmt` - icon image format.\n* `icon_speed` - speed of an animated icon.\n* `comment_addr` - address in file of the comment block.\n* `offset_banner` - offset in file to the banner's image data.\n* `offset_banner_tlut` - offset in file to the banner's texture lookup table.\n* `offset_icon[CARD_MAXICONS]` - array of offsets in file to the icon's image data <CARD_MAXICONS.\n* `offset_icon_tlut` - offset in file to the icons's texture lookup table.\n* `offset_data` - offset to additional data."]
pub type card_stat = _card_stat;
#[doc = "void (*cardcallback)(s32 chan,s32 result)\nfunction pointer typedef for the user's operation callback\n# Arguments\n\n* `chan` - CARD slot\n* `result` - result of operation upon call of callback."]
pub type cardcallback = ::core::option::Option<unsafe extern "C" fn(chan: s32, result: s32)>;
extern "C" {
    #[doc = "s32 CARD_Init(const char *gamecode,const char *company)\nPerforms the initialization of the memory card subsystem\n# Arguments\n\n* `gamecode` (direction in) - pointer to a 4byte long string to specify the vendors game code. May be NULL\n* `company` (direction in) - pointer to a 2byte long string to specify the vendors company code. May be NULL\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Init(gamecode: *const ::libc::c_char, company: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Probe(s32 chn)\nPerforms a check against the desired EXI channel if a device is inserted\n# Arguments\n\n* `chn` (direction in) - CARD slot\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Probe(chn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_ProbeEx(s32 chn,s32 *mem_size,s32 *sect_size)\nPerforms a check against the desired EXI channel if a memory card is inserted or mounted\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `mem_size` (direction out) - pointer to a integer variable, ready to take the resulting value (this param is optional and can be NULL)\n* `sect_size` (direction out) - pointer to a integer variable, ready to take the resulting value (this param is optional and can be NULL)\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_ProbeEx(chn: s32, mem_size: *mut s32, sect_size: *mut s32) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Mount(s32 chn,void *workarea,cardcallback detach_cb)\nMounts the memory card in the slot CHN. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `workarea` (direction in) - pointer to memory area to hold the cards system area. The startaddress of the workdarea should be aligned on a 32byte boundery\n* `detach_cb` (direction in) - pointer to a callback function. This callback function will be called when the card is removed from the slot.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Mount(chn: s32, workarea: *mut ::libc::c_void, detach_cb: cardcallback) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_MountAsync(s32 chn,void *workarea,cardcallback detach_cb,cardcallback attach_cb)\nMounts the memory card in the slot CHN. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `workarea` (direction in) - pointer to memory area to hold the cards system area. The startaddress of the workdarea should be aligned on a 32byte boundery\n* `detach_cb` (direction in) - pointer to a callback function. This callback function will be called when the card is removed from the slot.\n* `attach_cb` (direction in) - pointer to a callback function. This callback function will be called when the mount process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_MountAsync(
        chn: s32,
        workarea: *mut ::libc::c_void,
        detach_cb: cardcallback,
        attach_cb: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Unmount(s32 chn)\nUnmounts the memory card in the slot CHN and releases the EXI bus.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Unmount(chn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Read(card_file *file,void *buffer,u32 len,u32 offset)\nReads the data from the file into the buffer from the given offset with the given length. Synchronous version\n# Arguments\n\n* `file` (direction in) - pointer to the card_file structure. It holds the fileinformations to read from.\n* `buffer` (direction out) - pointer to memory area read-in the data. The startaddress of the buffer should be aligned to a 32byte boundery.\n* `len` (direction in) - length of data to read.\n* `offset` (direction in) - offset into the file to read from.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Read(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_ReadAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback)\nReads the data from the file into the buffer from the given offset with the given length. This function returns immediately. Asynchronous version\n# Arguments\n\n* `file` (direction in) - pointer to the card_file structure. It holds the fileinformations to read from.\n* `buffer` (direction out) - pointer to memory area read-in the data. The startaddress of the buffer should be aligned to a 32byte boundery.\n* `len` (direction in) - length of data to read.\n* `offset` (direction in) - offset into the file to read from.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the read process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_ReadAsync(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Open(s32 chn,const char *filename,card_file *file)\nOpens the file with the given filename and fills in the fileinformations.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `filename` (direction in) - name of the file to open.\n* `file` (direction out) - pointer to the card_file structure. It receives the fileinformations for later usage.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Open(chn: s32, filename: *const ::libc::c_char, file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_OpenEntry(s32 chn,card_dir *entry,card_file *file)\nOpens the file with the given filename and fills in the fileinformations.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `entry` (direction in) - pointer to the directory entry to open.\n* `file` (direction out) - pointer to the card_file structure. It receives the fileinformations for later usage.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_OpenEntry(chn: s32, entry: *mut card_dir, file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Close(card_file *file)\nCloses the file with the given card_file structure and releases the handle.\n# Arguments\n\n* `file` (direction in) - pointer to the card_file structure to close.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Close(file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Create(s32 chn,const char *filename,u32 size,card_file *file)\nCreates a new file with the given filename and fills in the fileinformations. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `filename` (direction in) - name of the file to create.\n* `size` (direction in) - size of the newly created file. This must be a multiple of the memory card's sector size.\n* `file` (direction out) - pointer to the card_file structure. It receives the fileinformations for later usage.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Create(
        chn: s32,
        filename: *const ::libc::c_char,
        size: u32_,
        file: *mut card_file,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_CreateAsync(s32 chn,const char *filename,u32 size,card_file *file,cardcallback callback)\nCreates a new file with the given filename and fills in the fileinformations. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `filename` (direction in) - name of the file to create.\n* `size` (direction in) - size of the newly created file. This must be a multiple of the memory card's sector size.\n* `file` (direction out) - pointer to the card_file structure. It receives the fileinformations for later usage.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the create process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_CreateAsync(
        chn: s32,
        filename: *const ::libc::c_char,
        size: u32_,
        file: *mut card_file,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_CreateEntry(s32 chn,card_dir *entry,card_file *file)\nCreates a new file with the given filename and fills in the fileinformations. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `entry` (direction in) - pointer to the directory entry to create.\n* `file` (direction out) - pointer to the card_file structure. It receives the fileinformations for later usage.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_CreateEntry(chn: s32, direntry: *mut card_dir, file: *mut card_file) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_CreateEntryAsync(s32 chn,card_dir *entry,card_file *file,cardcallback callback)\nCreates a new file with the given filename and fills in the fileinformations. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `entry` (direction in) - pointer to the directory entry to create\n* `file` (direction out) - pointer to the card_file structure. It receives the fileinformations for later usage.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the create process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_CreateEntryAsync(
        chn: s32,
        direntry: *mut card_dir,
        file: *mut card_file,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Delete(s32 chn,const char *filename)\nDeletes a file with the given filename. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `filename` (direction in) - name of the file to delete.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Delete(chn: s32, filename: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_DeleteAsync(s32 chn,const char *filename,cardcallback callback)\nDeletes a file with the given filename. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `filename` (direction in) - name of the file to delete.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the delete process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_DeleteAsync(
        chn: s32,
        filename: *const ::libc::c_char,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_DeleteEntry(s32 chn,card_dir *dir_entry)\nDeletes a file with the given directory entry informations.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `dir_entry` (direction in) - pointer to the card_dir structure which holds the informations for the delete operation.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_DeleteEntry(chn: s32, dir_entry: *mut card_dir) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_DeleteEntryAsync(s32 chn,card_dir *dir_entry,cardcallback callback)\nDeletes a file with the given directory entry informations. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `dir_entry` (direction in) - pointer to the card_dir structure which holds the informations for the delete operation.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the delete process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_DeleteEntryAsync(chn: s32, dir_entry: *mut card_dir, callback: cardcallback)
        -> s32;
}
extern "C" {
    #[doc = "s32 CARD_Write(card_file *file,void *buffer,u32 len,u32 offset)\nWrites the data to the file from the buffer to the given offset with the given length. Synchronous version\n# Arguments\n\n* `file` (direction in) - pointer to the card_file structure which holds the fileinformations.\n* `buffer` (direction in) - pointer to the memory area to read from. The startaddress of the buffer should be aligned on a 32byte boundery.\n* `len` (direction in) - length of data to write.\n* `offset` (direction in) - starting point in the file to start writing.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_Write(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_WriteAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback)\nWrites the data to the file from the buffer to the given offset with the given length. This function returns immediately. Asynchronous version\n# Arguments\n\n* `file` (direction in) - pointer to the card_file structure which holds the fileinformations.\n* `buffer` (direction in) - pointer to the memory area to read from. The startaddress of the buffer should be aligned on a 32byte boundery.\n* `len` (direction in) - length of data to write.\n* `offset` (direction in) - starting point in the file to start writing.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the write process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_WriteAsync(
        file: *mut card_file,
        buffer: *mut ::libc::c_void,
        len: u32_,
        offset: u32_,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetErrorCode(s32 chn)\nReturns the result code from the last operation.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n\n# Returns\n\ncard_errors \"card error codes\" of last operation"]
    pub fn CARD_GetErrorCode(chn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_FindFirst(s32 chn, card_dir *dir, bool showall)\nStart to iterate thru the memory card's directory structure and returns the first directory entry.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `dir` (direction out) - pointer to card_dir structure to receive the result set.\n* `showall` (direction in) - Whether to show all files of the memory card or only those which are identified by the company and gamecode string.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_FindFirst(chn: s32, dir: *mut card_dir, showall: bool) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_FindNext(card_dir *dir)\nReturns the next directory entry from the memory cards directory structure.\n# Arguments\n\n* `dir` (direction out) - pointer to card_dir structure to receive the result set.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_FindNext(dir: *mut card_dir) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetDirectory(s32 chn, card_dir *dir_entries, s32 *count, bool showall)\nReturns the directory entries. size of entries is max. 128.\n# Arguments\n\n* `chn` (direction in) - CARD slot\n* `dir_entries` (direction out) - pointer to card_dir structure to receive the result set.\n* `count` (direction out) - pointer to an integer to receive the counted entries.\n* `showall` (direction in) - Whether to show all files of the memory card or only those which are identified by the company and gamecode string.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_GetDirectory(
        chn: s32,
        dir_entries: *mut card_dir,
        count: *mut s32,
        showall: bool,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetSectorSize(s32 chn,u32 *sector_size)\nReturns the next directory entry from the memory cards directory structure.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `sector_size` (direction out) - pointer to receive the result.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_GetSectorSize(chn: s32, sector_size: *mut u32_) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetBlockCount(s32 chn,u32 *block_count)\nReturns the next directory entry from the memory cards directory structure.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `sector_size` (direction out) - pointer to receive the result.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_GetBlockCount(chn: s32, block_count: *mut u32_) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetStatus(s32 chn,s32 fileno,card_stat *stats)\nGet additional file statistic informations.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `stats` (direction out) - pointer to receive the result set.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_GetStatus(chn: s32, fileno: s32, stats: *mut card_stat) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetStatusEx(s32 chn, s32 fileno, card_direntry *entry)\nGet the directory entry (GCI header)\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `entry` (direction out) - pointer to receive the directory entry.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_GetStatusEx(chn: s32, fileno: s32, entry: *mut card_direntry) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetStatus(s32 chn,s32 fileno,card_stat *stats)\nSet additional file statistic informations. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `stats` (direction out) - pointer which holds the informations to set.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetStatus(chn: s32, fileno: s32, stats: *mut card_stat) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetStatusAsync(s32 chn,s32 fileno,card_stat *stats,cardcallback callback)\nSet additional file statistic informations. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `stats` (direction out) - pointer which holds the informations to set.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the setstatus process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetStatusAsync(
        chn: s32,
        fileno: s32,
        stats: *mut card_stat,
        callback: cardcallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetStatusEx(s32 chn, s32 fileno, card_direntry *entry)\nSet the directory entry (preferably from a GCI header), except block index and lenght\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `entry` (direction out) - pointer to a directory entry structure (or GCI header).\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetStatusEx(chn: s32, fileno: s32, entry: *mut card_direntry) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetAttributes(s32 chn,s32 fileno,u8 *attr)\nGet additional file attributes. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `attr` (direction out) - pointer to receive attribute value.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_GetAttributes(chn: s32, fileno: s32, attr: *mut u8_) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetAttributes(s32 chn,s32 fileno,u8 attr)\nSet additional file attributes. Synchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `attr` (direction in) - attribute value to set.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetAttributes(chn: s32, fileno: s32, attr: u8_) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetAttributesAsync(s32 chn,s32 fileno,u8 attr,cardcallback callback)\nSet additional file attributes. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `fileno` (direction in) - file index. returned by a previous call to CARD_Open().\n* `attr` (direction in) - attribute value to set.\n* `callback` (direction in) - pointer to a callback function. This callback will be called when the setattributes process has finished.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetAttributesAsync(chn: s32, fileno: s32, attr: u8_, callback: cardcallback)
        -> s32;
}
extern "C" {
    #[doc = "Not finished function"]
    pub fn CARD_Format(chn: s32) -> s32;
}
extern "C" {
    #[doc = "Not finished function"]
    pub fn CARD_FormatAsync(chn: s32, callback: cardcallback) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetCompany(const char *company)\nSet additional file attributes. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetCompany(company: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_SetGamecode(const char *gamecode)\nSet additional file attributes. This function returns immediately. Asynchronous version.\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n\n# Returns\n\ncard_errors \"card error codes\""]
    pub fn CARD_SetGamecode(gamecode: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetSerialNo(s32 chn, u32 *serial1, u32 *serial2)\nGet the encrypted serial numbers of the memory card\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `serial1` (direction in) - & serial2 CARD slot.\n# Returns\n\ncard_errors \"card error codes\" or free blocks"]
    pub fn CARD_GetSerialNo(chn: s32, serial1: *mut u32_, serial2: *mut u32_) -> s32;
}
extern "C" {
    #[doc = "s32 CARD_GetFreeBlocks(s32 chn, u16* freeblocks)\nGet the free blocks in memory card\n# Arguments\n\n* `chn` (direction in) - CARD slot.\n* `freeblocks` (direction in) - pointer to receive freeblocks value.\n# Returns\n\ncard_errors \"card error codes\" or free blocks"]
    pub fn CARD_GetFreeBlocks(chn: s32, freeblocks: *mut u16_) -> s32;
}
#[doc = "struct _gx_rmodeobj GXRModeObj\nstructure to hold the selected video and render settings\n# Arguments\n\n* `viTVMode` - mode and type of TV\n* `fbWidth` - width of external framebuffer\n* `efbHeight` - height of embedded framebuffer\n* `xfbHeight` - height of external framebuffer\n* `viXOrigin` - x starting point of first pixel to draw on VI\n* `viYOrigin` - y starting point of first pixel to draw on VI\n* `viWidth` - width of configured VI\n* `viHeight` - height of configured VI"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_rmodeobj {
    pub viTVMode: u32_,
    pub fbWidth: u16_,
    pub efbHeight: u16_,
    pub xfbHeight: u16_,
    pub viXOrigin: u16_,
    pub viYOrigin: u16_,
    pub viWidth: u16_,
    pub viHeight: u16_,
    pub xfbMode: u32_,
    pub field_rendering: u8_,
    pub aa: u8_,
    pub sample_pattern: [[u8_; 2usize]; 12usize],
    pub vfilter: [u8_; 7usize],
}
#[doc = "struct _gx_rmodeobj GXRModeObj\nstructure to hold the selected video and render settings\n# Arguments\n\n* `viTVMode` - mode and type of TV\n* `fbWidth` - width of external framebuffer\n* `efbHeight` - height of embedded framebuffer\n* `xfbHeight` - height of external framebuffer\n* `viXOrigin` - x starting point of first pixel to draw on VI\n* `viYOrigin` - y starting point of first pixel to draw on VI\n* `viWidth` - width of configured VI\n* `viHeight` - height of configured VI"]
pub type GXRModeObj = _gx_rmodeobj;
extern "C" {
    #[doc = "CON_Init(void *framebuffer,int xstart,int ystart,int xres,int yres,int stride)\n Initializes the console subsystem with given parameters\n\n # Arguments\n\n* `framebuffer` (direction in) - pointer to the framebuffer used for drawing the characters\n * `xstart,ystart` (direction in) - start position of the console output in pixel\n * `xres,yres` (direction in) - size of the console in pixel\n * `stride` (direction in) - size of one line of the framebuffer in bytes\n\n # Returns\n\nnone"]
    pub fn CON_Init(
        framebuffer: *mut ::libc::c_void,
        xstart: ::libc::c_int,
        ystart: ::libc::c_int,
        xres: ::libc::c_int,
        yres: ::libc::c_int,
        stride: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "s32 CON_InitEx(GXRModeObj *rmode, s32 conXOrigin,s32 conYOrigin,s32 conWidth,s32 conHeight)\n Initialize stdout console\n # Arguments\n\n* `rmode` (direction in) - pointer to the video/render mode configuration\n * `conXOrigin` (direction in) - starting pixel in X direction of the console output on the external framebuffer\n * `conYOrigin` (direction in) - starting pixel in Y direction of the console output on the external framebuffer\n * `conWidth` (direction in) - width of the console output 'window' to be drawn\n * `conHeight` (direction in) - height of the console output 'window' to be drawn\n\n # Returns\n\n0 on success, <0 on error"]
    pub fn CON_InitEx(
        rmode: *mut GXRModeObj,
        conXOrigin: s32,
        conYOrigin: s32,
        conWidth: s32,
        conHeight: s32,
    ) -> s32;
}
extern "C" {
    #[doc = "CON_GetMetrics(int *cols, int *rows)\n retrieve the columns and rows of the current console\n\n # Arguments\n\n* `cols,rows` (direction out) - number of columns and rows of the current console\n\n # Returns\n\nnone"]
    pub fn CON_GetMetrics(cols: *mut ::libc::c_int, rows: *mut ::libc::c_int);
}
extern "C" {
    #[doc = "CON_GetPosition(int *col, int *row)\n retrieve the current cursor position of the current console\n\n # Arguments\n\n* `col,row` (direction out) - current cursor position\n\n # Returns\n\nnone"]
    pub fn CON_GetPosition(cols: *mut ::libc::c_int, rows: *mut ::libc::c_int);
}
extern "C" {
    #[doc = "CON_EnableGecko(int channel, int safe)\n Enable or disable the USB gecko console.\n\n # Arguments\n\n* `channel` (direction in) - EXI channel, or -1 �to disable the gecko console\n * `safe` (direction in) - If true, use safe mode (wait for peer)\n\n # Returns\n\nnone"]
    pub fn CON_EnableGecko(channel: ::libc::c_int, safe: ::libc::c_int);
}
pub type sec_t = u32;
pub type FN_MEDIUM_STARTUP = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type FN_MEDIUM_ISINSERTED = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type FN_MEDIUM_READSECTORS = ::core::option::Option<
    unsafe extern "C" fn(sector: sec_t, numSectors: sec_t, buffer: *mut ::libc::c_void) -> bool,
>;
pub type FN_MEDIUM_WRITESECTORS = ::core::option::Option<
    unsafe extern "C" fn(sector: sec_t, numSectors: sec_t, buffer: *const ::libc::c_void) -> bool,
>;
pub type FN_MEDIUM_CLEARSTATUS = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type FN_MEDIUM_SHUTDOWN = ::core::option::Option<unsafe extern "C" fn() -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISC_INTERFACE_STRUCT {
    pub ioType: ::libc::c_ulong,
    pub features: ::libc::c_ulong,
    pub startup: FN_MEDIUM_STARTUP,
    pub isInserted: FN_MEDIUM_ISINSERTED,
    pub readSectors: FN_MEDIUM_READSECTORS,
    pub writeSectors: FN_MEDIUM_WRITESECTORS,
    pub clearStatus: FN_MEDIUM_CLEARSTATUS,
    pub shutdown: FN_MEDIUM_SHUTDOWN,
}
pub type DISC_INTERFACE = DISC_INTERFACE_STRUCT;
#[doc = "struct _dvddiskid dvddiskid\n forward typedef for struct _dvddiskid"]
pub type dvddiskid = _dvddiskid;
#[doc = "struct _dvddiskid dvddiskid\n\n This structure holds the game vendors copyright informations.<br>\n Additionally it holds certain parameters for audiocontrol and<br>\n multidisc support.\n\n # Arguments\n\n* `gamename[4]` - vendors game key\n * `company[2]` - vendors company key\n * `disknum` - number of disc when multidisc support is used.\n * `gamever` - version of game\n * `streaming` - flag to control audio streaming\n * `streambufsize` - size of buffer used for audio streaming\n * `pad[22]` - padding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvddiskid {
    pub gamename: [s8; 4usize],
    pub company: [s8; 2usize],
    pub disknum: u8_,
    pub gamever: u8_,
    pub streaming: u8_,
    pub streambufsize: u8_,
    pub pad: [u8_; 22usize],
}
#[doc = "struct _dvdcmdblk dvdcmdblk\n forward typedef for struct _dvdcmdblk"]
pub type dvdcmdblk = _dvdcmdblk;
#[doc = "void (*dvdcbcallback)(s32 result,dvdcmdblk *block)\n function pointer typedef for the user's operations callback"]
pub type dvdcbcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, block: *mut dvdcmdblk)>;
#[doc = "struct _dvdcmdblk dvdcmdblk\n\n This structure is used internally to control the requested operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvdcmdblk {
    pub node: lwp_node,
    pub cmd: u32_,
    pub state: s32,
    pub offset: s64,
    pub len: u32_,
    pub buf: *mut ::libc::c_void,
    pub currtxsize: u32_,
    pub txdsize: u32_,
    pub id: *mut dvddiskid,
    pub cb: dvdcbcallback,
    pub usrdata: *mut ::libc::c_void,
}
#[doc = "struct _dvddrvinfo dvddrvinfo\n forward typedef for struct _dvddrvinfo"]
pub type dvddrvinfo = _dvddrvinfo;
#[doc = "struct _dvddrvinfo dvddrvinfo\n\n This structure structure holds the drive version infromation.<br>\n\t\t Use DVD_Inquiry() to retrieve this information.\n\n # Arguments\n\n* `rev_leve` - revision level\n * `dev_code` - device code\n * `rel_date` - release date\n * `pad[24]` - padding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvddrvinfo {
    pub rev_level: u16_,
    pub dev_code: u16_,
    pub rel_date: u32_,
    pub pad: [u8_; 24usize],
}
#[doc = "struct _dvdfileinfo dvdfileinfo\n forward typedef for struct _dvdfileinfo"]
pub type dvdfileinfo = _dvdfileinfo;
#[doc = "void (*dvdcallback)(s32 result,dvdfileinfo *info)\n function pointer typedef for the user's DVD operation callback\n\n # Arguments\n\n* `result` (direction in) - error code of last operation\n * `info` (direction in) - pointer to user's file info strucutre"]
pub type dvdcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, info: *mut dvdfileinfo)>;
#[doc = "struct _dvdfileinfo dvdfileinfo\n\n This structure is used internally to control the requested file operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _dvdfileinfo {
    pub block: dvdcmdblk,
    pub addr: u32_,
    pub len: u32_,
    pub cb: dvdcallback,
}
extern "C" {
    #[doc = "void DVD_Init(void)\n Initializes the DVD subsystem\n\n You must call this function before calling any other DVD function\n\n # Returns\n\nnone"]
    pub fn DVD_Init();
}
extern "C" {
    pub fn DVD_Pause();
}
extern "C" {
    #[doc = "void DVD_Reset(u32 reset_mode)\n Performs a reset of the drive and FW respectively.\n\n # Arguments\n\n* `reset_mode` (direction in) - dvd_resetmode \"type\" of reset\n\n # Returns\n\nnone"]
    pub fn DVD_Reset(reset_mode: u32_);
}
extern "C" {
    #[doc = "s32 DVD_Mount(void)\n Mounts the DVD drive.\n\n This is a synchronous version of DVD_MountAsync().\n\n # Returns\n\nnone"]
    pub fn DVD_Mount() -> s32;
}
extern "C" {
    pub fn DVD_GetDriveStatus() -> s32;
}
extern "C" {
    #[doc = "s32 DVD_MountAsync(dvdcmdblk *block,dvdcbcallback cb)\n Mounts the DVD drive.\n\n You <b>must</b> call this function in order to access the DVD.\n\n Following tasks are performed:\n - Issue a hard reset to the drive.\n - Turn on drive's debug mode.\n - Patch drive's FW.\n - Enable extensions.\n - Read disc ID\n\n The patch code and procedure was taken from the gc-linux DVD device driver.\n\n # Arguments\n\n* `block` (direction in) - pointer to a dvdcmdblk structure used to process the operation\n * `cb` (direction in) - callback to be invoked upon completion of operation\n\n # Returns\n\nnone"]
    pub fn DVD_MountAsync(block: *mut dvdcmdblk, cb: dvdcbcallback) -> s32;
}
extern "C" {
    #[doc = "s32 DVD_ControlDrive(dvdcmdblk *block,u32 cmd)\n Controls the drive's motor and behavior.\n\n This is a synchronous version of DVD_ControlDriveAsync().\n\n # Arguments\n\n* `block` (direction in) - pointer to a dvdcmdblk structure used to process the operation\n * `cmd` (direction in) - dvd_motorctrlmode \"command\" to control the drive.\n\n # Returns\n\nnone"]
    pub fn DVD_ControlDrive(block: *mut dvdcmdblk, cmd: u32_) -> s32;
}
extern "C" {
    #[doc = "s32 DVD_ControlDriveAsync(dvdcmdblk *block,u32 cmd,dvdcbcallback cb)\n Controls the drive's motor and behavior.\n\n # Arguments\n\n* `block` (direction in) - pointer to a dvdcmdblk structure used to process the operation\n * `cmd` (direction in) - dvd_motorctrlmode \"command\" to control the drive.\n * `cb` (direction in) - callback to be invoked upon completion of operation.\n\n # Returns\n\nnone"]
    pub fn DVD_ControlDriveAsync(block: *mut dvdcmdblk, cmd: u32_, cb: dvdcbcallback) -> s32;
}
extern "C" {
    #[doc = "s32 DVD_SetGCMOffset(dvdcmdblk *block,u32 offset)\n Sets the offset to the GCM. Used for multigame discs.\n\n This is a synchronous version of DVD_SetGCMOffsetAsync().\n\n # Arguments\n\n* `block` (direction in) - pointer to a dvdcmdblk structure used to process the operation\n * `offset` (direction in) - offset to the GCM on disc.\n\n # Returns\n\ndvd_errorcodes \"dvd error code\""]
    pub fn DVD_SetGCMOffset(block: *mut dvdcmdblk, offset: s64) -> s32;
}
extern "C" {
    #[doc = "s32 DVD_SetGCMOffsetAsync(dvdcmdblk *block,u32 offset,dvdcbcallback cb)\n Sets the offset to the GCM. Used for multigame discs.\n\n This is a synchronous version of DVD_SetGCMOffsetAsync().\n\n # Arguments\n\n* `block` (direction in) - pointer to a dvdcmdblk structure used to process the operation\n * `offset` (direction in) - offset to the GCM on disc.\n * `cb` (direction in) - callback to be invoked upon completion of operation.\n\n # Returns\n\ndvd_errorcodes \"dvd error code\""]
    pub fn DVD_SetGCMOffsetAsync(block: *mut dvdcmdblk, offset: s64, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_GetCmdBlockStatus(block: *mut dvdcmdblk) -> s32;
}
extern "C" {
    pub fn DVD_SpinUpDrive(block: *mut dvdcmdblk) -> s32;
}
extern "C" {
    pub fn DVD_SpinUpDriveAsync(block: *mut dvdcmdblk, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_Inquiry(block: *mut dvdcmdblk, info: *mut dvddrvinfo) -> s32;
}
extern "C" {
    pub fn DVD_InquiryAsync(block: *mut dvdcmdblk, info: *mut dvddrvinfo, cb: dvdcbcallback)
        -> s32;
}
extern "C" {
    pub fn DVD_ReadPrio(
        block: *mut dvdcmdblk,
        buf: *mut ::libc::c_void,
        len: u32_,
        offset: s64,
        prio: s32,
    ) -> s32;
}
extern "C" {
    pub fn DVD_ReadAbsAsyncPrio(
        block: *mut dvdcmdblk,
        buf: *mut ::libc::c_void,
        len: u32_,
        offset: s64,
        cb: dvdcbcallback,
        prio: s32,
    ) -> s32;
}
extern "C" {
    pub fn DVD_ReadAbsAsyncForBS(
        block: *mut dvdcmdblk,
        buf: *mut ::libc::c_void,
        len: u32_,
        offset: s64,
        cb: dvdcbcallback,
    ) -> s32;
}
extern "C" {
    pub fn DVD_SeekPrio(block: *mut dvdcmdblk, offset: s64, prio: s32) -> s32;
}
extern "C" {
    pub fn DVD_SeekAbsAsyncPrio(
        block: *mut dvdcmdblk,
        offset: s64,
        cb: dvdcbcallback,
        prio: s32,
    ) -> s32;
}
extern "C" {
    pub fn DVD_CancelAllAsync(cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_StopStreamAtEndAsync(block: *mut dvdcmdblk, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_StopStreamAtEnd(block: *mut dvdcmdblk) -> s32;
}
extern "C" {
    pub fn DVD_ReadDiskID(block: *mut dvdcmdblk, id: *mut dvddiskid, cb: dvdcbcallback) -> s32;
}
extern "C" {
    pub fn DVD_SetAutoInvalidation(auto_inv: u32_) -> u32_;
}
extern "C" {
    pub fn DVD_GetCurrentDiskID() -> *mut dvddiskid;
}
extern "C" {
    pub fn DVD_GetDriveInfo() -> *mut dvddrvinfo;
}
extern "C" {
    pub static __io_gcdvd: DISC_INTERFACE;
}
#[doc = "s32 (*EXICallback)(s32 chn,s32 dev)\nfunction pointer typedef for the user's EXI callback\n# Arguments\n\n* `chn` - EXI channel\n* `dev` - EXI device"]
pub type EXICallback = ::core::option::Option<unsafe extern "C" fn(chn: s32, dev: s32) -> s32>;
extern "C" {
    #[doc = "s32 EXI_ProbeEx(s32 nChn)\nPerforms an extended probe of the EXI channel\n# Arguments\n\n* `nChn` (direction in) - EXI channel to probe\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_ProbeEx(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Probe(s32 nChn)\nProbes the EXI channel\n# Arguments\n\n* `nChn` (direction in) - EXI channel to probe\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Probe(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Lock(s32 nChn,s32 nDev,EXICallback unlockCB)\nTry to lock the desired EXI channel on the given device.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to lock\n* `nDev` (direction in) - EXI device to lock\n* `unlockCB` (direction in) - pointer to callback to call when EXI_Unlock() is called. Thus allowing us a small way of mutual exclusion.\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Lock(nChn: s32, nDev: s32, unlockCB: EXICallback) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Unlock(s32 nChn)\nUnlock the desired EXI channel.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to unlock\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Unlock(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Select(s32 nChn,s32 nDev,s32 nFrq)\nSelects the spedified EXI channel on the given device with the given frequency\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `nDev` (direction in) - EXI device to select\n* `nFrq` (direction in) - EXI frequency to select\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Select(nChn: s32, nDev: s32, nFrq: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_SelectSD(s32 nChn,s32 nDev,s32 nFrq)\nPerforms a special select, for SD cards or adapters respectively, on the given device with the given frequence\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `nDev` (direction in) - EXI device to select\n* `nFrq` (direction in) - EXI frequency to select\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_SelectSD(nChn: s32, nDev: s32, nFrq: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Deselect(s32 nChn)\nDeselects the EXI channel.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to deselect\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Deselect(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Sync(s32 nChn)\nSynchronize or finish respectively the last EXI transfer.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Sync(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Imm(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb)\nInitializes an immediate mode EXI transfer.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `pData` (direction in, out) - pointer to a buffer to read/copy from/to data.\n* `nLen` (direction in) - lenght of data to transfer <=4.\n* `nMode` (direction in) - direction of transferoperation(EXI_READ,EXI_WRITE,EXI_READWRITE)\n* `tc_cb` (direction in) - pointer to a callback to call when transfer has completed. May be NULL.\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Imm(
        nChn: s32,
        pData: *mut ::libc::c_void,
        nLen: u32_,
        nMode: u32_,
        tc_cb: EXICallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_ImmEx(s32 nChn,void *pData,u32 nLen,u32 nMode)\nInitializes an extended immediate mode EXI transfer.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `pData` (direction in, out) - pointer to a buffer to read/copy from/to data.\n* `nLen` (direction in) - lenght of data to transfer.\n* `nMode` (direction in) - direction of transferoperation(EXI_READ,EXI_WRITE,EXI_READWRITE)\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_ImmEx(nChn: s32, pData: *mut ::libc::c_void, nLen: u32_, nMode: u32_) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Dma(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb)\nInitializes a DMA mode EXI transfer.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `pData` (direction in, out) - pointer to a buffer to read/copy from/to data.\n* `nLen` (direction in) - lenght of data to transfer.\n* `nMode` (direction in) - direction of transferoperation(EXI_READ,EXI_WRITE,EXI_READWRITE)\n* `tc_cb` (direction in) - pointer to a callback to call when transfer has completed. May be NULL.\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Dma(
        nChn: s32,
        pData: *mut ::libc::c_void,
        nLen: u32_,
        nMode: u32_,
        tc_cb: EXICallback,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_GetState(s32 nChn)\nGet the EXI state\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n\n# Returns\n\nEXI channels state flag."]
    pub fn EXI_GetState(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_GetID(s32 nChn,s32 nDev,u32 *nId)\nGet the ID of the connected EXI device on the given channel\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `nDev` (direction in) - EXI device to select\n* `nId` (direction out) - EXI device ID to return.\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_GetID(nChn: s32, nDev: s32, nId: *mut u32_) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Attach(s32 nChn,EXICallback ext_cb)\nAttach the device on the given channel\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `ext_cb` (direction in) - pointer to callback to call when device is physically removed.\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Attach(nChn: s32, ext_cb: EXICallback) -> s32;
}
extern "C" {
    #[doc = "s32 EXI_Detach(s32 nChn)\nDetach the device on the given channel\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n\n# Returns\n\n1 on success, <=0 on error"]
    pub fn EXI_Detach(nChn: s32) -> s32;
}
extern "C" {
    #[doc = "void EXI_ProbeReset(void)\nResets certain internal flags and counters and performs a probe on all 3 channels.\n\n# Returns\n\nnothing"]
    pub fn EXI_ProbeReset();
}
extern "C" {
    #[doc = "EXICallback EXI_RegisterEXICallback(s32 nChn,EXICallback exi_cb)\nRegister a callback function in the EXI driver for the EXI interrupt.\n# Arguments\n\n* `nChn` (direction in) - EXI channel to select\n* `exi_cb` (direction in) - pointer to the function which to call when EXI interrupt has triggered.\n\n# Returns\n\nold callback function pointer or NULL"]
    pub fn EXI_RegisterEXICallback(nChn: s32, exi_cb: EXICallback) -> EXICallback;
}
#[doc = "guVector\n 3-element vector with x, y and z components.\n\n \n\nWhen used in 3D transformations, it is treated as a column vector with an implied fourth 'w' coordinate of 1.\n For example, to multiply a vector <i>vOld</i> by a matrix <i>m</i>: <i>vNew</i> = <i>m</i> x <i>vOld</i>. In code:\n\n guVecMultiply( m, &vOld, &vNew ); > **Note:** This is a generic structure which can be used in any situation or function that accepts an array or struct with\n three f32 values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vecf {
    pub x: f32_,
    pub y: f32_,
    pub z: f32_,
}
#[doc = "guVector\n 3-element vector with x, y and z components.\n\n \n\nWhen used in 3D transformations, it is treated as a column vector with an implied fourth 'w' coordinate of 1.\n For example, to multiply a vector <i>vOld</i> by a matrix <i>m</i>: <i>vNew</i> = <i>m</i> x <i>vOld</i>. In code:\n\n guVecMultiply( m, &vOld, &vNew ); > **Note:** This is a generic structure which can be used in any situation or function that accepts an array or struct with\n three f32 values."]
pub type guVector = _vecf;
#[doc = "guQuaternion\n Quaternion type consisting of an (x,y,z) vector component and a (w) scalar component.\n\n \n\nThis struct is used by gu library function such as guQuatMtx(), which generates a rotation matrix from a\n quaternion.\n\n > **Note:** This is a generic structure which can be used in any situation or function that accepts an array or struct with\n four f32 values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _qrtn {
    pub x: f32_,
    pub y: f32_,
    pub z: f32_,
    pub w: f32_,
}
#[doc = "guQuaternion\n Quaternion type consisting of an (x,y,z) vector component and a (w) scalar component.\n\n \n\nThis struct is used by gu library function such as guQuatMtx(), which generates a rotation matrix from a\n quaternion.\n\n > **Note:** This is a generic structure which can be used in any situation or function that accepts an array or struct with\n four f32 values."]
pub type guQuaternion = _qrtn;
#[doc = "f32 Mtx[3][4]\n Standard 3x4 matrix.\n Some functions take the 4x4 matrix type rather than this one, so make sure you don't mix up the two."]
pub type Mtx = [[f32_; 4usize]; 3usize];
pub type MtxP = *mut [f32_; 4usize];
#[doc = "f32 ROMtx[4][3]\n Column-major representation of the standard Mtx structure.\n\n \n\nIt is not a true transpose, as it is a 4x3 matrix. These structures are only accepted by functions that explicitly\n require reordered matrices."]
pub type ROMtx = [[f32_; 3usize]; 4usize];
pub type ROMtxP = *mut [f32_; 3usize];
#[doc = "f32 Mtx33[3][3]\n 3x3 matrix."]
pub type Mtx33 = [[f32_; 3usize]; 3usize];
pub type Mtx33P = *mut [f32_; 3usize];
#[doc = "f32 Mtx44[4][4]\n 4x4 matrix.\n Some functions take this instead of the 3x4 matrix, so make sure you don't mix up the two."]
pub type Mtx44 = [[f32_; 4usize]; 4usize];
pub type Mtx44P = *mut [f32_; 4usize];
extern "C" {
    #[doc = "void guFrustum(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f)\n Sets a 4x4 perspective projection matrix from viewing volume dimensions.\n\n \n\nThis matrix is used by the GX API to transform points to screen space.\n\n For normal perspective projection, the axis of projection is the -z axis, so _t_ = positive, _b_ = -_t,_ _r_ =\n positive, _l_ = -_r._ _n_ and _f_ must both be given as positive distances.\n\n > **Note:** _m_ negates a point's 'z' values, so pre-transformed points should have negative 'z' values in eye space in\n order to be visible after projection.\n\n # Arguments\n\n* `mt` (direction out) - New projection matrix.\n * `t` (direction in) - Top edge of view volume at the near clipping plane.\n * `b` (direction in) - Bottom edge of view volume at the near clipping plane.\n * `l` (direction in) - Left edge of view volume at the near clipping plane.\n * `r` (direction in) - Right edge of view volume at the near clipping plane.\n * `n` (direction in) - Positive distance to the near clipping plane.\n * `f` (direction in) - Positive distance to the far clipping plane.\n\n # Returns\n\nnone"]
    pub fn guFrustum(mt: *mut [f32_; 4usize], t: f32_, b: f32_, l: f32_, r: f32_, n: f32_, f: f32_);
}
extern "C" {
    #[doc = "void guPerspective(Mtx44 mt,f32 fovy,f32 aspect,f32 n,f32 f)\n Sets a 4x4 perspective projection matrix from field of view and aspect ratio parameters.\n\n \n\nThis matrix is used by the GX API to transform points to screen space.\n\n This function generates a projection matrix equivalent to that created by guFrustum() with the axis of projection\n centered around Z. It is included to provide an alternative method of specifying view volume dimensions.\n\n The field of view (_fovy)_ is the total field of view in degrees in the Y-Z plane. _aspect_ is the ratio\n (width/height) of the view window in screen space. _n_ and _f_ must both be given as positive distances.\n\n > **Note:** _m_ negates a point's 'z' values, so pre-transformed points should have negative 'z' values in eye space in order to\n be visible after projection.\n\n # Arguments\n\n* `mt` (direction out) - New perspective projection matrix.\n * `fovy` (direction in) - Total field of view in the Y-Z plane measured in degrees.\n * `aspect` (direction in) - View window aspect ratio (width/height)\n * `n` (direction in) - Positive distance to near clipping plane.\n * `f` (direction in) - Positive distance to far clipping plane.\n\n # Returns\n\nnone"]
    pub fn guPerspective(mt: *mut [f32_; 4usize], fovy: f32_, aspect: f32_, n: f32_, f: f32_);
}
extern "C" {
    #[doc = "void guOrtho(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f)\n Sets a 4x4 matrix for orthographic projection.\n\n \n\nThis matrix is used by the GX API to transform points from eye space to screen space.\n\n For normal parallel projections, the axis of projection is the -z axis, so _t_ = positive, _b_ = -_t,_ _r_ =\n positive, _l_ = -_r._ _n_ and _f_ must both be given as positive distances.\n\n > **Note:** _m_ negates _a_ point's 'z' values, so pre-transformed points should have negative 'z' values in eye space in order\n to be visible after projection.\n\n # Arguments\n\n* `mt` (direction out) - New parallel projection matrix.\n * `t` (direction in) - Top edge of view volume.\n * `b` (direction in) - Bottom edge of view volume.\n * `l` (direction in) - Left edge of view volume.\n * `r` (direction in) - Right edge of view volume.\n * `n` (direction in) - Positive distance to the near clipping plane.\n * `f` (direction in) - Positive distance to the far clipping plane.\n\n # Returns\n\nnone"]
    pub fn guOrtho(mt: *mut [f32_; 4usize], t: f32_, b: f32_, l: f32_, r: f32_, n: f32_, f: f32_);
}
extern "C" {
    #[doc = "void guLightPerspective(Mtx mt,f32 fovY,f32 aspect,f32 scaleS,f32 scaleT,f32 transS,f32 transT)\n Sets a 3x4 perspective projection matrix from field of view and aspect ratio parameters, two scale values, and two\n translation values.\n\n \n\nThis matrix is used to project points into texture space and yield texture coordinates.\n\n This function generates a projection matrix, equivalent to that created by guLightFrustum(), with the axis of projection\n centered around Z. This function is included to provide an alternative method of specifying texture projection volume\n dimensions.\n\n The field of view (_fovy)_ is the total field of view in degrees in the YZ plane. _aspect_ is the ratio (width / height)\n of the view window in screen space.\n\n Standard projection yields values ranging from -1.0 to 1.0 in both dimensions of the front clipping plane. Since texture\n coordinates should usually be within the range of 0.0 to 1.0, we have added a scale and translation value for both S and T.\n The most common way to use these values is to set all of them to 0.5 (so that points in the range of -1.0 to 1.0 are first\n scaled by 0.5) to be in the range of -0.5 to 0.5. Then they are translated by 0.5 to be in the range of 0.0 to 1.0. Other\n values can be used for translation and scale to yield different effects.\n\n # Arguments\n\n* `mt` (direction out) - New projection matrix.\n * `fovy` (direction in) - Total field of view in the YZ plane measured in degrees.\n * `aspect` (direction in) - View window aspect ratio (width / height)\n * `scaleS` (direction in) - Scale in the S direction for projected coordinates (usually 0.5).\n * `scaleT` (direction in) - Scale in the T direction for projected coordinates (usually 0.5).\n * `transS` (direction in) - Translate in the S direction for projected coordinates (usually 0.5).\n * `transT` (direction in) - Translate in the T direction for projected coordinates (usually 0.5).\n\n # Returns\n\nnone"]
    pub fn guLightPerspective(
        mt: *mut [f32_; 4usize],
        fovY: f32_,
        aspect: f32_,
        scaleS: f32_,
        scaleT: f32_,
        transS: f32_,
        transT: f32_,
    );
}
extern "C" {
    #[doc = "void guLightOrtho(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 scaleS,f32 scaleT,f32 transS,f32 transT)\n Sets a 3x4 matrix for orthographic projection.\n\n \n\nUse this matrix to project points into texture space and yield texture coordinates.\n\n For normal parallel projections, the axis of projection is the -z axis, so _t_ = positive, _b_ = -_t,_ _r_ = positive,\n _l_ = -_r._\n\n Standard projection yields values ranging from -1.0 to 1.0 in both dimensions of the front clipping plane. Since texture\n coordinates should usually be within the range of 0.0 to 1.0, we have added a scale and translation value for both S and T.\n The most common way to use these values is to set all of them to 0.5 so that points in the range of -1.0 to 1.0 are first\n scaled by 0.5 (to be in the range of -0.5 to 0.5). Then they are translated by 0.5 to be in the range of 0.0 to 1.0. Other\n values can be used for translation and scale to yield different effects.\n\n # Arguments\n\n* `mt` (direction out) - New parallel projection matrix.\n * `t` (direction in) - Top edge of view volume.\n * `b` (direction in) - Bottom edge of view volume.\n * `l` (direction in) - Left edge of view volume.\n * `r` (direction in) - Right edge of view volume.\n * `scaleS` (direction in) - Scale in the S direction for projected coordinates (usually 0.5).\n * `scaleT` (direction in) - Scale in the T direction for projected coordinates (usually 0.5).\n * `transS` (direction in) - Translate in the S direction for projected coordinates (usually 0.5).\n * `transT` (direction in) - Translate in the T direction for projected coordinates (usually 0.5).\n\n # Returns\n\nnone"]
    pub fn guLightOrtho(
        mt: *mut [f32_; 4usize],
        t: f32_,
        b: f32_,
        l: f32_,
        r: f32_,
        scaleS: f32_,
        scaleT: f32_,
        transS: f32_,
        transT: f32_,
    );
}
extern "C" {
    #[doc = "void guLightFrustum(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 scaleS,f32 scaleT,f32 transS,f32 transT)\n Sets a 3x4 perspective projection matrix from viewing volume dimensions, two scale values, and two translation values.\n\n \n\nThis matrix is used to project points into texture space and yield texture coordinates.\n\n For normal perspective projection, the axis of projection is the -z axis, so _t_ = positive, _b_ = -_t,_ _r_ = positive,\n _l_ = -_r._ _n_ must be given as a positive distance.\n\n Standard projection yields values ranging from -1.0 to 1.0 in both dimensions of the front clipping plane. Since texture\n coordinates usually should be within the range of 0.0 to 1.0, we have added a scale and translation value for both S and T.\n The most common usage of these values is to set all of them to 0.5 so that points in the range of -1.0 to 1.0 are first\n scaled by 0.5 to be in the range of -0.5 to 0.5, and are then translated by 0.5 to be in the range of 0.0 to 1.0. Other\n values can be used for translation and scale to yield different effects.\n\n # Arguments\n\n* `mt` (direction out) - New projection matrix.\n * `t` (direction in) - Top edge of view volume at the near clipping plane.\n * `b` (direction in) - Bottom edge of view volume at the near clipping plane.\n * `l` (direction in) - Left edge of view volume at the near clipping plane.\n * `r` (direction in) - Right edge of view volume at the near clipping plane.\n * `n` (direction in) - Positive distance to the near clipping plane.\n * `scaleS` (direction in) - Scale in the S direction for projected coordinates (usually 0.5).\n * `scaleT` (direction in) - Scale in the T direction for projected coordinates (usually 0.5).\n * `transS` (direction in) - Translate in the S direction for projected coordinates (usually 0.5).\n * `transT` (direction in) - Translate in the T direction for projected coordinates (usually 0.5).\n\n # Returns\n\nnone"]
    pub fn guLightFrustum(
        mt: *mut [f32_; 4usize],
        t: f32_,
        b: f32_,
        l: f32_,
        r: f32_,
        n: f32_,
        scaleS: f32_,
        scaleT: f32_,
        transS: f32_,
        transT: f32_,
    );
}
extern "C" {
    #[doc = "void guLookAt(Mtx mt,guVector *camPos,guVector *camUp,guVector *target)\n Sets a world-space to camera-space transformation matrix.\n\n \n\nCreate the matrix _m_ by specifying a camera position (_camPos),_ a camera \"up\" direction (_camUp),_ and a target\n position (_target)._\n\n The camera's reference viewing direction is the -z axis. The camera's reference 'up' direction is the +y axis.\n\n This function is especially convenient for creating a tethered camera, aiming at an object, panning, or specifying an\n arbitrary view.\n\n # Arguments\n\n* `mt` (direction out) - New viewing matrix.\n * `camPos` (direction in) - Vector giving 3D camera position in world space.\n * `camUp` (direction in) - Vector containing camera \"up\" vector; does not have to be a unit vector.\n * `target` (direction in) - Vector giving 3D target position in world space.\n\n # Returns\n\nnone"]
    pub fn guLookAt(
        mt: *mut [f32_; 4usize],
        camPos: *const guVector,
        camUp: *const guVector,
        target: *const guVector,
    );
}
extern "C" {
    #[doc = "void guVecHalfAngle(guVector *a,guVector *b,guVector *half)\n Computes a vector that lies halfway between _a_ and _b._\n\n \n\nThe halfway vector is useful in specular reflection calculations. It is interpreted as pointing from the reflecting\n surface to the general viewing direction.\n\n _a_ and _b_ do not have to be unit vectors. Both of these vectors are assumed to be pointing towards the surface from the\n light or viewer, respectively. Local copies of these vectors are negated, normalized and added head to tail.\n\n _half_ is computed as a unit vector that points from the surface to halfway between the light and the viewing direction.\n\n # Arguments\n\n* `a` (direction in) - Pointer to incident vector. Must point from the light source to the surface.\n * `b` (direction in) - Pointer to viewing vector. Must point from the viewer to the surface.\n * `half` (direction out) - Pointer to resultant half-angle unit vector; points from the surface to halfway between the light and the viewing direction.\n\n # Returns\n\nnone"]
    pub fn guVecHalfAngle(a: *const guVector, b: *const guVector, half: *mut guVector);
}
extern "C" {
    pub fn c_guVecAdd(a: *const guVector, b: *const guVector, ab: *mut guVector);
}
extern "C" {
    pub fn c_guVecSub(a: *const guVector, b: *const guVector, ab: *mut guVector);
}
extern "C" {
    pub fn c_guVecScale(src: *const guVector, dst: *mut guVector, scale: f32_);
}
extern "C" {
    pub fn c_guVecNormalize(v: *mut guVector);
}
extern "C" {
    pub fn c_guVecMultiply(mt: *mut [f32_; 4usize], src: *const guVector, dst: *mut guVector);
}
extern "C" {
    pub fn c_guVecCross(a: *const guVector, b: *const guVector, axb: *mut guVector);
}
extern "C" {
    pub fn c_guVecMultiplySR(mt: *mut [f32_; 4usize], src: *const guVector, dst: *mut guVector);
}
extern "C" {
    pub fn c_guVecDotProduct(a: *const guVector, b: *const guVector) -> f32_;
}
extern "C" {
    pub fn c_guQuatAdd(a: *const guQuaternion, b: *const guQuaternion, ab: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatSub(a: *const guQuaternion, b: *const guQuaternion, ab: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatMultiply(a: *const guQuaternion, b: *const guQuaternion, ab: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatNormalize(a: *const guQuaternion, d: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatInverse(a: *const guQuaternion, d: *mut guQuaternion);
}
extern "C" {
    pub fn c_guQuatMtx(a: *mut guQuaternion, m: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxIdentity(mt: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxCopy(src: *mut [f32_; 4usize], dst: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxConcat(a: *mut [f32_; 4usize], b: *mut [f32_; 4usize], ab: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxScale(mt: *mut [f32_; 4usize], xS: f32_, yS: f32_, zS: f32_);
}
extern "C" {
    pub fn c_guMtxScaleApply(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xS: f32_,
        yS: f32_,
        zS: f32_,
    );
}
extern "C" {
    pub fn c_guMtxApplyScale(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xS: f32_,
        yS: f32_,
        zS: f32_,
    );
}
extern "C" {
    pub fn c_guMtxTrans(mt: *mut [f32_; 4usize], xT: f32_, yT: f32_, zT: f32_);
}
extern "C" {
    pub fn c_guMtxTransApply(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xT: f32_,
        yT: f32_,
        zT: f32_,
    );
}
extern "C" {
    pub fn c_guMtxApplyTrans(
        src: *mut [f32_; 4usize],
        dst: *mut [f32_; 4usize],
        xT: f32_,
        yT: f32_,
        zT: f32_,
    );
}
extern "C" {
    pub fn c_guMtxInverse(src: *mut [f32_; 4usize], inv: *mut [f32_; 4usize]) -> u32_;
}
extern "C" {
    pub fn c_guMtxInvXpose(src: *mut [f32_; 4usize], xPose: *mut [f32_; 4usize]) -> u32_;
}
extern "C" {
    pub fn c_guMtxTranspose(src: *mut [f32_; 4usize], xPose: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn c_guMtxRotRad(mt: *mut [f32_; 4usize], axis: ::libc::c_char, rad: f32_);
}
extern "C" {
    pub fn c_guMtxRotTrig(mt: *mut [f32_; 4usize], axis: ::libc::c_char, sinA: f32_, cosA: f32_);
}
extern "C" {
    pub fn c_guMtxRotAxisRad(mt: *mut [f32_; 4usize], axis: *mut guVector, rad: f32_);
}
extern "C" {
    pub fn c_guMtxReflect(m: *mut [f32_; 4usize], p: *const guVector, n: *const guVector);
}
extern "C" {
    pub fn c_guMtxQuat(m: *mut [f32_; 4usize], a: *const guQuaternion);
}
extern "C" {
    pub fn c_guMtx44Concat(a: *mut [f32_; 4usize], b: *mut [f32_; 4usize], ab: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn guMtx44Identity(mt: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn guMtx44Copy(src: *mut [f32_; 4usize], dst: *mut [f32_; 4usize]);
}
extern "C" {
    pub fn guMtx44Inverse(src: *mut [f32_; 4usize], inv: *mut [f32_; 4usize]) -> u32_;
}
#[doc = "u32 lwp_t\ntypedef for the thread context handle"]
pub type lwp_t = u32_;
#[doc = "u32 lwpq_t\ntypedef for the thread queue's context handle"]
pub type lwpq_t = u32_;
extern "C" {
    #[doc = "s32 LWP_CreateThread(lwp_t *thethread,void* (*entry)(void *),void *arg,void *stackbase,u32 stack_size,u8 prio)\nSpawn a new thread with the given parameters\n# Arguments\n\n* `thethread` (direction out) - pointer to a lwp_t handle\n* `entry` (direction in) - pointer to the thread's entry function.\n* `arg` (direction in) - pointer to an argument for the thread's entry function.\n* `stackbase` (direction in) - pointer to the threads stackbase address. If NULL, the stack is allocated by the thread system.\n* `stack_size` (direction in) - size of the provided stack. If 0, the default STACKSIZE of 8Kb is taken.\n* `prio` (direction in) - priority on which the newly created thread runs.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_CreateThread(
        thethread: *mut lwp_t,
        entry: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> *mut ::libc::c_void,
        >,
        arg: *mut ::libc::c_void,
        stackbase: *mut ::libc::c_void,
        stack_size: u32_,
        prio: u8_,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_SuspendThread(lwp_t thethread)\nSuspend the given thread.\n# Arguments\n\n* `thethread` (direction in) - handle to the thread context which should be suspended.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_SuspendThread(thethread: lwp_t) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_ResumeThread(lwp_t thethread)\nResume the given thread.\n# Arguments\n\n* `thethread` (direction in) - handle to the thread context which should be resumed.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_ResumeThread(thethread: lwp_t) -> s32;
}
extern "C" {
    #[doc = "BOOL LWP_ThreadIsSuspended(lwp_t thethread)\nTest whether the given thread is suspended or not\n# Arguments\n\n* `thethread` (direction in) - handle to the thread context which should be tested.\n\n# Returns\n\nTRUE or FALSE"]
    pub fn LWP_ThreadIsSuspended(thethread: lwp_t) -> BOOL;
}
extern "C" {
    #[doc = "lwp_t LWP_GetSelf(void)\nReturn the handle to the current thread.\n\n# Returns\n\nthread context handle"]
    pub fn LWP_GetSelf() -> lwp_t;
}
extern "C" {
    #[doc = "void LWP_SetThreadPriority(lwp_t thethread,u32 prio)\nSet the priority of the given thread.\n# Arguments\n\n* `thethread` (direction in) - handle to the thread context whos priority should be changed. If NULL, the current thread will be taken.\n* `prio` (direction in) - new priority to set\n\n# Returns\n\nnone"]
    pub fn LWP_SetThreadPriority(thethread: lwp_t, prio: u32_);
}
extern "C" {
    #[doc = "void LWP_YieldThread(void)\nYield the current thread to another one with higher priority or if not running at the same priority which state is runnable.\n\n# Returns\n\nnone"]
    pub fn LWP_YieldThread();
}
extern "C" {
    #[doc = "void LWP_Reschedule(u32 prio)\nReschedule all threads running at the given priority\n# Arguments\n\n* `prio` (direction in) - priority level to reschedule\n\n# Returns\n\nnone"]
    pub fn LWP_Reschedule(prio: u32_);
}
extern "C" {
    #[doc = "s32 LWP_JoinThread(lwp_t thethread,void **value_ptr)\nJoin the given thread.\n# Arguments\n\n* `thethread` (direction in) - handle to the thread's context which should be joined to wait on termination.\n* `value_ptr` (direction in) - pointer-pointer to a variable to receive the return code of the terminated thread.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_JoinThread(thethread: lwp_t, value_ptr: *mut *mut ::libc::c_void) -> s32;
}
extern "C" {
    #[doc = "void LWP_InitQueue(lwpq_t *thequeue)\nInitialize the thread synchronization queue\n# Arguments\n\n* `thequeue` (direction in) - pointer to a lwpq_t handle.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_InitQueue(thequeue: *mut lwpq_t) -> s32;
}
extern "C" {
    #[doc = "void LWP_CloseQueue(lwpq_t thequeue)\nClose the thread synchronization queue and releas the handle\n# Arguments\n\n* `thequeue` (direction in) - handle to the thread's synchronization queue\n\n# Returns\n\nnone"]
    pub fn LWP_CloseQueue(thequeue: lwpq_t);
}
extern "C" {
    #[doc = "s32 LWP_ThreadSleep(lwpq_t thequeue)\nPushes the current thread onto the given thread synchronization queue and sets the thread state to blocked.\n# Arguments\n\n* `thequeue` (direction in) - handle to the thread's synchronization queue to push the thread on\n\n# Returns\n\nnone"]
    pub fn LWP_ThreadSleep(thequeue: lwpq_t) -> s32;
}
extern "C" {
    #[doc = "void LWP_ThreadSignal(lwpq_t thequeue)\nSignals one thread to be revmoved from the thread synchronization queue and sets it back to running state.\n# Arguments\n\n* `thequeue` (direction in) - handle to the thread's synchronization queue to pop the blocked thread off\n\n# Returns\n\nnone"]
    pub fn LWP_ThreadSignal(thequeue: lwpq_t);
}
extern "C" {
    #[doc = "void LWP_ThreadBroadcast(lwpq_t thequeue)\nRemoves all blocked threads from the thread synchronization queue and sets them back to running state.\n# Arguments\n\n* `thequeue` (direction in) - handle to the thread's synchronization queue to pop the blocked threads off\n\n# Returns\n\nnone"]
    pub fn LWP_ThreadBroadcast(thequeue: lwpq_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wgpipe {
    pub U8: __BindgenUnionField<vu8>,
    pub S8: __BindgenUnionField<vs8>,
    pub U16: __BindgenUnionField<vu16>,
    pub S16: __BindgenUnionField<vs16>,
    pub U32: __BindgenUnionField<vu32>,
    pub S32: __BindgenUnionField<vs32>,
    pub F32: __BindgenUnionField<vf32>,
    pub bindgen_union_field: u32,
}
pub type WGPipe = _wgpipe;
#[doc = "struct _gx_color GXColor\n Structure used to pass colors to some GX functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_color {
    #[doc = "< Red color component."]
    pub r: u8_,
    #[doc = "< Green color component."]
    pub g: u8_,
    #[doc = "< Blue alpha component."]
    pub b: u8_,
    #[doc = "< Alpha component. If a function does not use the alpha value, it is safely ignored."]
    pub a: u8_,
}
#[doc = "struct _gx_color GXColor\n Structure used to pass colors to some GX functions."]
pub type GXColor = _gx_color;
#[doc = "struct _gx_colors10 GXColorS10\n Structure used to pass signed 10-bit colors to some GX functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_colors10 {
    #[doc = "< Red color component."]
    pub r: s16,
    #[doc = "< Green color component."]
    pub g: s16,
    #[doc = "< Blue color component."]
    pub b: s16,
    #[doc = "< Alpha component. If a function does not use the alpha value, it is safely ignored."]
    pub a: s16,
}
#[doc = "struct _gx_colors10 GXColorS10\n Structure used to pass signed 10-bit colors to some GX functions."]
pub type GXColorS10 = _gx_colors10;
#[doc = "struct _gx_texobj GXTexObj\n Object containing information about a texture.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitTexObj*()\n function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTexObj) \n\nbut the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_texobj {
    pub val: [u32_; 8usize],
}
#[doc = "struct _gx_texobj GXTexObj\n Object containing information about a texture.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitTexObj*()\n function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTexObj) \n\nbut the internal data representation is not visible to the application."]
pub type GXTexObj = _gx_texobj;
#[doc = "struct _gx_tlutobj GXTlutObj\n Object containing information on a TLUT.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutObj()\n function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTlutObj) \n\nbut the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_tlutobj {
    pub val: [u32_; 3usize],
}
#[doc = "struct _gx_tlutobj GXTlutObj\n Object containing information on a TLUT.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutObj()\n function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTlutObj) \n\nbut the internal data representation is not visible to the application."]
pub type GXTlutObj = _gx_tlutobj;
#[doc = "struct _gx_texreg GXTexRegion\n Object containing information on a texture cache region.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the\n GX_InitTexCacheRegion() function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTexRegion) \n\nbut the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_texreg {
    pub val: [u32_; 4usize],
}
#[doc = "struct _gx_texreg GXTexRegion\n Object containing information on a texture cache region.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the\n GX_InitTexCacheRegion() function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTexRegion) \n\nbut the internal data representation is not visible to the application."]
pub type GXTexRegion = _gx_texreg;
#[doc = "struct _gx_tlutreg GXTlutRegion\n Object containing information on a TLUT cache region.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutRegion()\n function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTlutRegion) \n\nbut the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_tlutreg {
    pub val: [u32_; 4usize],
}
#[doc = "struct _gx_tlutreg GXTlutRegion\n Object containing information on a TLUT cache region.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitTlutRegion()\n function to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXTlutRegion) \n\nbut the internal data representation is not visible to the application."]
pub type GXTlutRegion = _gx_tlutreg;
#[doc = "_gx_litobj GXLightObj\n Object containing information on a light.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitLight*() functions\n to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXLightObj) \n\nbut the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gx_litobj {
    pub val: [u32_; 16usize],
}
#[doc = "_gx_litobj GXLightObj\n Object containing information on a light.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitLight*() functions\n to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXLightObj) \n\nbut the internal data representation is not visible to the application."]
pub type GXLightObj = _gx_litobj;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vtx {
    pub x: f32_,
    pub y: f32_,
    pub z: f32_,
    pub s: u16_,
    pub t: u16_,
    pub rgba: u32_,
}
pub type Vtx = _vtx;
#[doc = "GXVtxDesc\n Structure describing how a single vertex attribute will be referenced.\n\n \n\nAn array of these structures can be used to describe all the attributes in a vertex. The attribute <tt>GX_VA_NULL</tt> should be\n used to mark the end of the array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXVtxDesc {
    #[doc = "< vtxattr for this element."]
    pub attr: u8_,
    #[doc = "< vtxattrin for this element."]
    pub type_: u8_,
}
#[doc = "GXVtxAttrFmt\n Structure describing the attribute format for one attribute.\n\n \n\nAn array of these structures can be used to describe the format of all attributes in a vertex. The attribute <tt>GX_VA_NULL</tt>\n should be used to mark the end of the array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXVtxAttrFmt {
    #[doc = "< vtxattr for this element."]
    pub vtxattr: u32_,
    #[doc = "< comptype for this element."]
    pub comptype: u32_,
    #[doc = "< compsize for this element."]
    pub compsize: u32_,
    #[doc = "< Number of fractional bits for a fixed-point number."]
    pub frac: u32_,
}
#[doc = "GXFifoObj\n Object describing a graphics FIFO.\n\n \n\nThis structure contains precompiled register state setting commands and data. The application must use the GX_InitFifo*() functions\n to initialize or change this object. The proper size of the object is returned by\n\n sizeof(GXFifoObj) but the internal data representation is not visible to the application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXFifoObj {
    pub pad: [u8_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXTexReg {
    pub dummy: [u8_; 4usize],
}
#[doc = "GXFogAdjTbl\n Fog range adjustment parameter table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GXFogAdjTbl {
    #[doc = "< u4.8 format range parameter."]
    pub r: [u16_; 10usize],
}
#[doc = "void (*GXBreakPtCallback)(void)\n function pointer typedef for the GP breakpoint-token callback"]
pub type GXBreakPtCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "void (*GXDrawDoneCallback)(void)\n function pointer typedef for the GP drawdone-token callback"]
pub type GXDrawDoneCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "void (*GXDrawSyncCallback)(u16 token)\n function pointer typedef for the drawsync-token callback\n # Arguments\n\n* `token` (direction out) - tokenvalue most recently encountered."]
pub type GXDrawSyncCallback = ::core::option::Option<unsafe extern "C" fn(token: u16_)>;
#[doc = "GXTexRegion* (*GXTexRegionCallback)(GXTexObj *obj,u8 mapid)\n function pointer typedef for the texture region callback\n # Arguments\n\n* `token` (direction out) - tokenvalue most recently encountered."]
pub type GXTexRegionCallback = ::core::option::Option<
    unsafe extern "C" fn(obj: *mut GXTexObj, mapid: u8_) -> *mut GXTexRegion,
>;
#[doc = "GXTlutRegion* (*GXTlutRegionCallback)(u32 tlut_name)\n function pointer typedef for the TLUT region callback\n # Arguments\n\n* `token` (direction out) - tokenvalue most recently encountered."]
pub type GXTlutRegionCallback =
    ::core::option::Option<unsafe extern "C" fn(tlut_name: u32_) -> *mut GXTlutRegion>;
extern "C" {
    pub static wgPipe: *mut WGPipe;
}
extern "C" {
    #[doc = "GXFifoObj* GX_Init(void *base,u32 size)\n Initializes the graphics processor to its initial state.\n\n \n\nThis function sets the default state of the graphics processor and should be called before any other GX functions.\n This function sets up an immediate-mode method of communicating graphics commands from the CPU to the Graphics Processor\n (GP). This function will initialize a FIFO and attach it to both the CPU and GP. The CPU will write commands to the FIFO\n and the GP will read the commands. This function returns a pointer to the initialized FIFO. The application must allocate\n the memory for the FIFO. The parameter _base_ is a pointer to the allocated main memory and must be aligned to 32B. _size_\n is the size of the FIFO in bytes and must be a multiple of 32B. Refer to additional notes in GX_InitFifoBase() concerning\n the FIFO memory.\n\n > **Note:** It is also possible to override the default immediate-mode style and instead buffer the graphics for frame <i>n+1</i>\n while the GP is reading the graphics for frame <i>n</i>. See GX_SetCPUFifo() and GX_SetGPFifo() for further information.<br><br>\n\n > **Note:** This function also designates the calling thread as the default GX thread; i.e., it assumes the calling thread is the\n one responsible for generating graphics data. This thread will be the thread to be suspended when the FIFO gets too full.\n The current GX thread can be changed by calling GX_SetCurrentGXThread().\n\n # Arguments\n\n* `base` (direction in) - pointer to the GX FIFO buffer base address. Must be aligned on a 32 Byte boundery.\n * `size` (direction in) - size of buffer. Must be a multiple of 32.\n\n # Returns\n\npointer to the intialized GXFifoObj object."]
    pub fn GX_Init(base: *mut ::libc::c_void, size: u32_) -> *mut GXFifoObj;
}
extern "C" {
    #[doc = "void GX_InitFifoBase(GXFifoObj *fifo,void *base,u32 size)\n Describes the area of main memory that will be used for this _fifo._\n\n The Graphics FIFO is the mechanism used to communicate graphics commands from the CPU to the Graphics Processor (GP). The FIFO\n base pointer should be 32-byte aligned. memalign() can return 32-byte aligned pointers. The size should also be a multiple of\n 32B.\n\n The CPU's write-gather pipe is used to write data to the FIFO. Therefore, the FIFO memory area must be forced out of the CPU\n cache prior to being used. DCInvalidateRange() may be used for this purpose. Due to the mechanics of flushing the write-gather\n pipe, the FIFO memory area should be at least 32 bytes larger than the maximum expected amount of data stored. Up to 32 NOPs\n may be written at the end during flushing.\n\n > **Note:** GX_Init() also takes the arguments _base_ and _size_ and initializes a FIFO using these values and attaches the FIFO\n to both the CPU and GP. The application must allocate the memory for the graphics FIFO before calling GX_Init(). Therefore, it\n is not necessary to call this function unless you want to resize the default FIFO sometime after GX_Init() has been called or\n you are creating a new FIFO. The minimum size is 64kB defined by <tt>GX_FIFO_MINSIZE</tt>.<br><br>\n\n > **Note:** This function will also set the read and write pointers for the FIFO to the base address, so ordinarily it is not\n necessary to call GX_InitFifoPtrs() when initializing the FIFO. In addition, This function sets the FIFO's high water mark to\n (size-16kB) and the low water mark to (size/2), so it is also not necessary to call GX_InitFifoLimits().\n\n # Arguments\n\n* `fifo` (direction in) - the fifo struct to use\n * `base` (direction in) - ptr to the base of allocation; must be 32-byte aligned\n * `size` (direction in) - size of the FIFO in bytes; must be multiple of 32; size must be <tt>GX_FIFO_MINSIZE</tt> or larger\n\n # Returns\n\nnone"]
    pub fn GX_InitFifoBase(fifo: *mut GXFifoObj, base: *mut ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = "void GX_InitFifoLimits(GXFifoObj *fifo,u32 hiwatermark,u32 lowatermark)\n Sets the high and low water mark for the _fifo._\n\n \n\nThe high and low water marks are used in <i>immediate-mode</i>, i.e. when the _fifo_ is attached to both the CPU and\n Graphics Processor (GP) (see GX_SetCPUFifo() and GX_SetGPFifo()).\n\n The hardware keeps track of the number of bytes between the read and write pointers. This number represents how full the FIFO is,\n and when it is greater than or equal to the _hiwatermark,_ the hardware issues an interrupt. The GX API will suspend sending\n graphics to the Graphics FIFO until it has emptied to a certain point. The _lowatermark_ is used to set the point at which the\n FIFO is empty enough to resume sending graphics commands to the FIFO. Both _hiwatermark_ and _lowatermark_ should be in\n multiples of 32B. The count for _lowatermark_ should be less than _hiwatermark._ Of course, _hiwatermark_ and _lowatermark_\n must be less than the size of the FIFO.\n\n > **Note:** When the FIFO is only attached to the CPU or only attached to the GP, the high and low water mark interrupts are disabled.\n\n # Arguments\n\n* `fifo` (direction in) - the fifo struct to use\n * `hiwatermark` (direction in) - number of bytes to be queued before libogc stops writing commands to the FIFO\n * `lowatermark` (direction in) - number of bytes to be queued before libogc resumes writing commands to the FIFO\n\n # Returns\n\nnone"]
    pub fn GX_InitFifoLimits(fifo: *mut GXFifoObj, hiwatermark: u32_, lowatermark: u32_);
}
extern "C" {
    #[doc = "void GX_InitFifoPtrs(GXFifoObj *fifo,void *rd_ptr,void *wt_ptr)\n Sets the _fifo_ read and write pointers.\n\n > **Note:** This is normally done only during initialization of the FIFO. After that, the graphics hardware manages the FIFO pointers.\n\n # Arguments\n\n* `fifo` (direction in) - the fifo struct to use\n * `rd_ptr` (direction in) - the pointer to use for the FIFO read pointer; must be 32-byte aligned\n * `wt_ptr` (direction in) - the pointer to use for the FIFO write pointer; must be 32-byte aligned\n\n # Returns\n\nnone"]
    pub fn GX_InitFifoPtrs(
        fifo: *mut GXFifoObj,
        rd_ptr: *mut ::libc::c_void,
        wt_ptr: *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = "void GX_GetFifoPtrs(const GXFifoObj *fifo,void **rd_ptr,void **wt_ptr)\n Returns the current value of the Graphics FIFO read and write pointers.\n\n > **Note:** See GX_EnableBreakPt() for an example of why you would do this.\n\n # Arguments\n\n* `fifo` (direction in) - pointer to a FIFO struct\n * `rd_ptr` (direction out) - address of the FIFO read pointer\n * `wt_ptr` (direction out) - address of the FIFO write pointer\n\n # Returns\n\nnone"]
    pub fn GX_GetFifoPtrs(
        fifo: *const GXFifoObj,
        rd_ptr: *mut *mut ::libc::c_void,
        wt_ptr: *mut *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = "void GX_SetCPUFifo(GXFifoObj *fifo)\n Attaches a FIFO to the CPU.\n\n > **Note:** If the FIFO being attached is one already attached to the GP, the FIFO can be considered to be in immediate mode. If not,\n the CPU can write commands, and the GP will execute them when the GP attaches to this FIFO (multi-buffered mode).\n\n # Arguments\n\n* `fifo` (direction in) - fifo struct containing info on the FIFO to attach\n\n # Returns\n\nnone"]
    pub fn GX_SetCPUFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = "void GX_SetGPFifo(GXFifoObj *fifo)\n Attaches _fifo_ to the GP.\n\n > **Note:** If the FIFO is also attached to the CPU, the system is in immediate-mode, and the fifo acts like a true FIFO. In immediate-mode,\n graphics commands are fed directly from the CPU to the GP. In immediate-mode the FIFO's high and low water marks are active. The high\n and low water marks implement the flow-control mechanism between the CPU and GP. When the FIFO becomes more full than the high water\n mark, the CPU will stop writing graphics commands into the FIFO. When the FIFO empties to a point lower than the low water mark, the\n CPU will resume writing graphics commands into the FIFO. The high and low water marks are set when intializing the FIFO using\n GX_InitFifoLimits().<br><br>\n\n > **Note:** If the FIFO is only attached to the GP, the FIFO acts like a buffer. In this case, high and low water marks are disabled, and\n the GP reads the FIFO until it is empty. Before attaching a new FIFO to the GP, you should make sure the previous FIFO is empty, using\n the _cmdIdle_ status returned by GX_GetGPStatus().<br><br>\n\n > **Note:** The break point mechanism can be used to force the FIFO to stop reading commands at a certain point; see GX_EnableBreakPt().\n\n # Arguments\n\n* `fifo` (direction in) - struct containing info on the FIFO to attach\n\n # Returns\n\nnone"]
    pub fn GX_SetGPFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = "void GX_GetCPUFifo(GXFifoObj *fifo)\n Copies the information from the currently attached CPU FIFO into _fifo._\n\n # Arguments\n\n* `fifo` (direction out) - the object to copy the current CPU FIFO object data into\n\n # Returns\n\nnone"]
    pub fn GX_GetCPUFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = "void GX_GetGPFifo(GXFifoObj *fifo)\n Copies the information from the currently attached GP FIFO info _fifo._\n\n # Arguments\n\n* `fifo` (direction out) - the object to copy the current GP FIFO object data into\n\n # Returns\n\nnone"]
    pub fn GX_GetGPFifo(fifo: *mut GXFifoObj);
}
extern "C" {
    #[doc = "void* GX_GetFifoBase(const GXFifoObj *fifo)\n Get the base address for a given _fifo._\n\n # Arguments\n\n* `fifo` (direction in) - the object to get the address from\n\n # Returns\n\npointer to the base address of the FIFO in main memory."]
    pub fn GX_GetFifoBase(fifo: *const GXFifoObj) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "u32 GX_GetFifoCount(const GXFifoObj *fifo)\n Returns number of cache lines in the FIFO.\n\n > **Note:** The count is incorrect if an overflow has occurred (i.e. you have written more data than the size of the fifo), as the\n hardware cannot detect an overflow in general.\n\n # Arguments\n\n* `fifo` (direction in) - the FIFO to get the count from\n\n # Returns\n\nnumber of cache lines in the FIFO"]
    pub fn GX_GetFifoCount(fifo: *const GXFifoObj) -> u32_;
}
extern "C" {
    #[doc = "u32 GX_GetFifoSize(const GXFifoObj *fifo)\n Get the size of a given _fifo._\n\n # Arguments\n\n* `fifo` (direction in) - the object to get the size from\n\n # Returns\n\nsize of the FIFO, in bytes"]
    pub fn GX_GetFifoSize(fifo: *const GXFifoObj) -> u32_;
}
extern "C" {
    #[doc = "u8 GX_GetFifoWrap(const GXFifoObj *fifo)\n Returns a non-zero value if the write pointer has passed the TOP of the FIFO.\n\n \n\nReturns true only if the FIFO is attached to the CPU and the FIFO write pointer has passed the top of the FIFO. Use the\n return value to detect whether or not an overflow has occured by initializing the FIFO's write pointer to the base of the FIFO\n before sending any commands to the FIFO.\n\n > **Note:** If the FIFO write pointer is not explicitly set to the base of the FIFO, you cannot rely on this function to detect overflows.\n\n # Arguments\n\n* `fifo` (direction in) - the object to get the wrap status from\n\n # Returns\n\nwrap value"]
    pub fn GX_GetFifoWrap(fifo: *const GXFifoObj) -> u8_;
}
extern "C" {
    #[doc = "GXDrawDoneCallback GX_SetDrawDoneCallback(GXDrawDoneCallback cb)\n Installs a callback that is invoked whenever a DrawDone command is encountered by the GP.\n\n \n\nThe DrawDone command is sent by GX_SetDrawDone().\n\n > **Note:** By the time the callback is invoked, the GP will already have resumed reading from the FIFO, if there are any commands in it.\n\n # Arguments\n\n* `cb` (direction in) - callback to be invoked when DrawDone is encountered\n\n # Returns\n\npointer to the previous callback"]
    pub fn GX_SetDrawDoneCallback(cb: GXDrawDoneCallback) -> GXDrawDoneCallback;
}
extern "C" {
    #[doc = "GXBreakPtCallback GX_SetBreakPtCallback(GXBreakPtCallback cb)\n Registers _cb_ as a function to be invoked when a break point is encountered.\n\n The callback will run with interrupts disabled, so it should terminate as quickly as possible.\n\n # Arguments\n\n* `cb` (direction in) - function to be invoked when the breakpoint is encountered; NULL means no function will run\n\n # Returns\n\npointer to the previous callback function"]
    pub fn GX_SetBreakPtCallback(cb: GXBreakPtCallback) -> GXBreakPtCallback;
}
extern "C" {
    #[doc = "void GX_AbortFrame(void)\n Aborts the current frame.\n\n \n\nThis command will reset the entire graphics pipeline, including any commands in the graphics FIFO.\n\n > **Note:** Texture memory will not be reset, so currently loaded textures will still be valid; however, when loading texture using\n GX_PreloadEntireTexture() or TLUTs using GX_LoadTlut(), you must make sure the command completed. You can use the draw sync mechanism to\n do this; see GX_SetDrawSync() and GX_GetDrawSync().\n\n # Returns\n\nnone"]
    pub fn GX_AbortFrame();
}
extern "C" {
    #[doc = "void GX_Flush(void)\n Flushes all commands to the GP.\n\n \n\nSpecifically, it flushes the write-gather FIFO in the CPU to make sure that all commands are sent to the GP.\n\n # Returns\n\nnone"]
    pub fn GX_Flush();
}
extern "C" {
    #[doc = "void GX_SetMisc(u32 token,u32 value)\n Sets miscellanous settings in the GP.\n\n # Arguments\n\n* `token` (direction in) - setting to change\n * `value` (direction in) - value to change the setting to\n\n # Returns\n\nnone"]
    pub fn GX_SetMisc(token: u32_, value: u32_);
}
extern "C" {
    #[doc = "void GX_SetDrawDone(void)\n Sends a DrawDone command to the GP.\n\n \n\nWhen all previous commands have been processed and the pipeline is empty, a <i>DrawDone</i> status bit will be set,\n and an interrupt will occur. You can receive notification of this event by installing a callback on the interrupt with\n GX_SetDrawDoneCallback(), or you can poll the status bit with GX_WaitDrawDone(). This function also flushes the write-gather\n FIFO in the CPU to make sure that all commands are sent to the graphics processor.\n\n > **Note:** This function is normally used in multibuffer mode (see GX_SetCPUFifo()). In immediate mode, the GX_DrawDone() command\n can be used, which both sends the command and stalls until the DrawDone status is true.\n\n # Returns\n\nnone"]
    pub fn GX_SetDrawDone();
}
extern "C" {
    #[doc = "void GX_WaitDrawDone(void)\n Stalls until <i>DrawDone</i> is encountered by the GP.\n\n \n\nIt means all graphics commands sent before this DrawDone command have executed and the last pixel has been written to\n the frame buffer. You may want to execute some non-graphics operations between executing GX_SetDrawDone() and this function, but\n if you simply want to wait and have nothing to execute, you can use GX_DrawDone().\n\n > **Note:** This function is normally used in immediate mode (see GX_SetCPUFifo()). In multibuffer mode, sending the '<i>done</i>' command is\n separated from polling the '<i>done</i>' status (see GX_SetDrawDone() and GX_WaitDrawDone()).\n\n # Returns\n\nnone"]
    pub fn GX_WaitDrawDone();
}
extern "C" {
    #[doc = "u16 GX_GetDrawSync(void)\n Returns the value of the token register, which is written using the GX_SetDrawSync() function.\n\n # Returns\n\nthe value of the token register."]
    pub fn GX_GetDrawSync() -> u16_;
}
extern "C" {
    #[doc = "void GX_SetDrawSync(u16 token)\n This function sends a token into the command stream.\n\n \n\nWhen the token register is set, an interrupt will also be received by the CPU. You can install a callback on this interrupt\n with GX_SetDrawSyncCallback(). Draw syncs can be used to notify the CPU that the graphics processor is finished using a shared\n resource (a vertex array for instance).\n\n # Arguments\n\n* `token` (direction in) - 16-bit value to write to the token register.\n\n # Returns\n\nnone"]
    pub fn GX_SetDrawSync(token: u16_);
}
extern "C" {
    #[doc = "GXDrawSyncCallback GX_SetDrawSyncCallback(GXDrawSyncCallback cb)\n Installs a callback that is invoked whenever a DrawSync token is encountered by the graphics pipeline.\n\n \n\nThe callback's argument is the value of the token most recently encountered. Since it is possible to\n miss tokens (graphics processing does not stop while the callback is running), your code should be\n capable of deducing if any tokens have been missed.\n\n # Arguments\n\n* `cb` (direction in) - callback to be invoked when the DrawSync tokens are encountered in the graphics pipeline.\n\n # Returns\n\npointer to the previously set callback function."]
    pub fn GX_SetDrawSyncCallback(cb: GXDrawSyncCallback) -> GXDrawSyncCallback;
}
extern "C" {
    #[doc = "void GX_DisableBreakPt(void)\n Allows reads from the FIFO currently attached to the Graphics Processor (GP) to resume.\n\n \n\nSee GX_EnableBreakPt() for an explanation of the FIFO break point feature.\n\n > **Note:** The breakpoint applies to the FIFO currently attached to the Graphics Processor (GP) (see GX_SetGPFifo()).\n\n # Returns\n\nnone"]
    pub fn GX_DisableBreakPt();
}
extern "C" {
    #[doc = "void GX_EnableBreakPt(void *break_pt)\n Sets a breakpoint that causes the GP to halt when encountered.\n\n > **Note:** The break point feature allows the application to have two frames of graphics in the FIFO at the same time, overlapping\n one frame's processing by the graphics processor with another frame's processing by the CPU. For example, suppose you finish\n writing the graphics commands for one frame and are ready to start on the next. First, execute a GX_Flush() command to make\n sure all the data in the CPU write gatherer is flushed into the FIFO. This will also align the FIFO write pointer to a 32B\n boundary. Next, read the value of the current write pointer using GX_GetFifoPtrs(). Write the value of the write pointer as\n the break point address using GX_EnableBreakPt(). When the FIFO read pointer reaches the break point address the hardware\n will disable reads from the FIFO. The status _brkpt,_ returned by GX_GetGPStatus(), can be polled to detect when the break point\n is reached. The application can then decide when to disable the break point, using GX_DisableBreakPt(), which will allow the FIFO\n to resume reading graphics commands.<br><br>\n\n > **Note:** FIFO reads will stall when the GP FIFO read pointer is equal to the break point address _break_pt._ To re-enable reads of\n the GP FIFO, use GX_DisableBreakPt().<br><br>\n\n > **Note:** Use GX_SetBreakPtCallback() to set what function runs when the breakpoint is encountered.\n\n # Arguments\n\n* `break_pt` (direction in) - address for GP to break on when read.\n\n # Returns\n\nnone"]
    pub fn GX_EnableBreakPt(break_pt: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "void GX_DrawDone(void)\n Sends a DrawDone command to the GP and stalls until its subsequent execution.\n\n > **Note:** This function is equivalent to calling GX_SetDrawDone() then GX_WaitDrawDone().\n\n # Returns\n\nnone"]
    pub fn GX_DrawDone();
}
extern "C" {
    #[doc = "void GX_TexModeSync(void)\n Inserts a synchronization command into the graphics FIFO. When the Graphics Processor sees this command, it will\n allow the texture pipeline to flush before continuing.\n\n \n\nThis command is necessary when changing the usage of regions of texture memory from preloaded or TLUT to cached areas.\n It makes sure that the texture pipeline is finished with that area of the texture memory prior to changing its usage.\n This function should be called prior to drawing any primitives that uses the texture memory region in its new mode. It is not\n necessary to call this command when changing texture memory regions from cached to preloaded (or TLUT), since the commands to\n load the regions with data will cause the necessary synchronization to happen automatically.\n\n # Returns\n\nnone"]
    pub fn GX_TexModeSync();
}
extern "C" {
    #[doc = "void GX_InvVtxCache(void)\n Invalidates the vertex cache.\n\n \n\nSpecifically, this functions invalidates the vertex cache tags. This function should be used whenever you relocate or modify\n data that is read by, or may be cached by, the vertex cache. The invalidate is very fast, taking only two Graphics Processor (GP) clock\n cycles to complete.\n\n > **Note:** The vertex cache is used to cache indexed attribute data. Any attribute that is set to <tt>GX_INDEX8</tt> or <tt>GX_INDEX16</tt> in the current\n vertex descriptor (see GX_SetVtxDesc()) is indexed. Direct data bypasses the vertex cache. Direct data is any attribute that is set to\n <tt>GX_DIRECT</tt> in the current vertex descriptor.\n\n # Returns\n\nnone"]
    pub fn GX_InvVtxCache();
}
extern "C" {
    #[doc = "void GX_ClearVtxDesc(void)\n Clears all vertex attributes of the current vertex descriptor to GX_NONE.\n\n > **Note:** The same functionality can be obtained using GX_SetVtxDescv(), however using GX_ClearVtxDesc() is much more efficient.\n\n # Returns\n\nnone"]
    pub fn GX_ClearVtxDesc();
}
extern "C" {
    #[doc = "void GX_LoadProjectionMtx(Mtx44 mt,u8 type)\n Sets the projection matrix.\n\n > **Note:** Only two types of projection matrices are supported: <tt>GX_PERSPECTIVE</tt> or <tt>GX_ORTHOGRAPHIC</tt>.\n\n # Arguments\n\n* `mt` (direction in) - matrix to use for the perspective\n * `type` (direction in) - which perspective type to use\n\n # Returns\n\nnone"]
    pub fn GX_LoadProjectionMtx(mt: *mut [f32_; 4usize], type_: u8_);
}
extern "C" {
    #[doc = "void GX_SetViewport(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ)\n Sets the viewport rectangle in screen coordinates.\n\n \n\nThe screen origin (_xOrig_ = 0.0f, _yOrig_ = 0.0f) is at the top left corner of the display. Floating point arguments allow the\n viewport to be adjusted by 1/2 line for interlaced field rendering modes; see GX_SetViewportJitter(). The viewport depth parameters are normalized coordinates\n from 0.0f - 1.0f. The GX API will convert the depth range values to proper scale values depending on the type and format of the Z-buffer.\n\n > **Note:** You should avoid using negative values for _xOrig_ or _yOrig._ While this may work, it may cause problems with points and lines being clipped incorrectly. If\n you need to shift the viewport up or left, consider using GX_SetScissorBoxOffset() instead.\n\n # Arguments\n\n* `xOrig` (direction in) - left-most X coordinate on the screen\n * `yOrig` (direction in) - top-most Y coordinate on the screen\n * `wd` (direction in) - width of the viewport\n * `ht` (direction in) - height of the viewport\n * `nearZ` (direction in) - value to use for near depth scale\n * `farZ` (direction in) - value to use for far depth scale\n\n # Returns\n\nnone"]
    pub fn GX_SetViewport(xOrig: f32_, yOrig: f32_, wd: f32_, ht: f32_, nearZ: f32_, farZ: f32_);
}
extern "C" {
    #[doc = "void GX_SetViewportJitter(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ,u32 field)\n Sets the viewport and adjusts the viewport's line offset for interlaced field rendering.\n\n \n\nDepending on whether the viewport starts on an even or odd line, and whether the next _field_ to be rendered is\n even or odd, the viewport may be adjusted by half a line. This has the same effect as slightly tilting the camera down and is necessary\n for interlaced rendering. No other camera adjustment (i.e. don't change the projection matrix) is needed for interlaced field rendering.\n\n > **Note:** To set a viewport <i>without</i> jitter, use GX_SetViewport().\n\n # Arguments\n\n* `xOrig` (direction in) - left-most X coordinate on the screen\n * `yOrig` (direction in) - top-most Y coordinate on the screen\n * `wd` (direction in) - width of the viewport\n * `ht` (direction in) - height of the viewport\n * `nearZ` (direction in) - value to use for near depth scale\n * `farZ` (direction in) - value to use for far depth scale\n * `field` (direction in) - whether the next field is even (0) or odd (1)\n\n # Returns\n\nnone"]
    pub fn GX_SetViewportJitter(
        xOrig: f32_,
        yOrig: f32_,
        wd: f32_,
        ht: f32_,
        nearZ: f32_,
        farZ: f32_,
        field: u32_,
    );
}
extern "C" {
    #[doc = "void GX_SetChanCtrl(s32 channel,u8 enable,u8 ambsrc,u8 matsrc,u8 litmask,u8 diff_fn,u8 attn_fn)\n Sets the lighting controls for a particular color channel.\n\n \n\nThe color channel can have one or more (up to 8) lights associated with it, set using _litmask._ The _diff_fn_ and _attn_fn_ parameters\n control the lighting equation for all lights associated with this channel; the _ambsrc_ and _matsrc_ can be used to select whether the input\n source colors come from register colors or vertex colors. When the channel _enable_ is set to <tt>GX_FALSE</tt>, the material color source (set by _matsrc)_\n is passed through as the channel's output color. When the channel _enable_ is <tt>GX_TRUE</tt>, the output color depends on the settings of the other\n controls (i.e., the lighting equation). GX_Init() sets the _enable_ for all channels to <tt>GX_FALSE</tt>. This function only configures the lighting\n channel; to output the result of the channel computation, use GX_SetNumChans().\n\n > **Note:** Even though channels <tt>GX_COLOR0</tt> and <tt>GX_ALPHA0</tt> are controlled separately for lighting, they are rasterized together as one RGBA color, effectively\n <tt>GX_COLOR0A0</tt>. The same is true for <tt>GX_COLOR1</tt> and <tt>GX_ALPHA1</tt>-- effectively, they are rasterized as <tt>GX_COLOR1A1</tt>. Since there is only one rasterizer for\n color in the graphics hardware, you must choose which color to rasterize for each stage in the Texture Environment (TEV) unit. This is accomplished\n using GX_SetTevOrder().<br><br>\n\n > **Note:** In order to use a vertex color in channel <tt>GX_COLOR1A1</tt>, two colors per vertex must be supplied, i.e. both <tt>GX_VA_CLR0</tt> and <tt>GX_VA_CLR1</tt> must be\n enabled in the current vertex descriptor. If only <tt>GX_VA_CLR0</tt> <b>or</b> <tt>GX_VA_CLR1</tt> is enabled in the current vertex descriptor, the vertex color is\n directed to the channel <tt>GX_VA_COLOR0A0</tt>.<br><br>\n\n > **Note:** When _ambsrc_ is set to <tt>GX_SRC_REG</tt>, the color set by GX_SetChanAmbColor() is used as the ambient color. When _matsrc_ is <tt>GX_SRC_REG</tt>, the color set\n by GX_SetChanMatColor() is used as the material color.\n\n # Arguments\n\n* `channel` (direction in) - color channel to use\n * `enable` (direction in) - whether or not to enable lighting for this channel\n * `ambsrc` (direction in) - source for the ambient color\n * `matsrc` (direction in) - source for the material color\n * `litmask` (direction in) - lightid or IDs to associate with this channel\n * `diff_fn` (direction in) - difffn to use\n * `attn_fn` (direction in) - attenfunc to use\n\n # Returns\n\nnone"]
    pub fn GX_SetChanCtrl(
        channel: s32,
        enable: u8_,
        ambsrc: u8_,
        matsrc: u8_,
        litmask: u8_,
        diff_fn: u8_,
        attn_fn: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetChanAmbColor(s32 channel,GXColor color)\n Sets the ambient color register for color channel _chan._\n\n \n\nThis color will be used by the channel as the ambient color if the ambient source, set by GX_SetChanCtrl(), is <tt>GX_SRC_REG</tt>.\n\n # Arguments\n\n* `channel` (direction in) - channel to set\n * `color` (direction in) - color to set it to\n\n # Returns\n\nnone"]
    pub fn GX_SetChanAmbColor(channel: s32, color: GXColor);
}
extern "C" {
    #[doc = "void GX_SetChanMatColor(s32 channel,GXColor color)\n Sets the material color register for color channel _chan._\n\n \n\nThis color will be used by the channel as the material color if the material source, set by GX_SetChanCtrl(), is <tt>GX_SRC_REG</tt>.\n\n # Arguments\n\n* `channel` (direction in) - channel to set\n * `color` (direction in) - color to set it to\n\n # Returns\n\nnone"]
    pub fn GX_SetChanMatColor(channel: s32, color: GXColor);
}
extern "C" {
    #[doc = "void GX_SetArray(u32 attr,void *ptr,u8 stride)\n Sets the array base pointer and stride for a single attribute.\n\n \n\nThe array base and stride are used to compute the address of indexed attribute data using the equation:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>attr_addr</i> = _ptr_ + <i>attr_idx</i> * _stride_\n\n When drawing a graphics primitive that has been enabled to use indexed attributes (see GX_SetVtxDesc()), <i>attr_idx</i> is supplied in the vertex\n data. The format and size of the data in the array must also be described using GX_SetVtxAttrFmt(). You can also index other data, such as\n matrices (see GX_LoadPosMtxIdx(), GX_LoadNrmMtxIdx3x3(), and GX_LoadTexMtxIdx()), and light objects (see GX_LoadLightObjIdx()). In the case\n of matrices and light objects, the size and format of the data to be loaded is implied by the function call.\n\n There is a base pointer, _ptr,_ for each type of attribute as well as for light data and matrices. Each attribute can be stored in its own\n array for maximum data compression (i.e., removal of redundant attribute data). The _stride_ is in byte units and is the distance between\n attributes in the array.\n\n > **Note:** Indexed data is loaded into a vertex cache in the graphics processor. The vertex cache fetches 32B of data for each cache miss;\n therefore, there is a small performance benefit to aligning attribute arrays to 32B, and possibly for arranging vertex data so that it\n doesn't span 32B boundaries. Conveniently enough, memalign() returns 32-byte aligned pointers. For static data arrays, you can use the\n ATTRIBUTE_ALIGN(32) attribute macro to align the _ptr_ to 32B.\n\n # Arguments\n\n* `attr` (direction in) - vtxattr that the array is storing\n * `ptr` (direction in) - pointer to the array itself\n * `stride` (direction in) - stride (in bytes) between each element in the array\n\n # Returns\n\nnone"]
    pub fn GX_SetArray(attr: u32_, ptr: *mut ::libc::c_void, stride: u8_);
}
extern "C" {
    #[doc = "void GX_SetVtxAttrFmt(u8 vtxfmt,u32 vtxattr,u32 comptype,u32 compsize,u32 frac)\n Sets the attribute format (_vtxattr)_ for a single attribute in the Vertex Attribute Table (VAT).\n\n \n\nEach attribute format describes the data type (comptype), number of elements (compsize), and fixed point format (frac), if required. The\n are eight vertex formats available in the VAT. The vertex format describes the format of all attributes in a vertex. The application can pre-program\n all eight vertex formats and then select one of them during the actual drawing of geometry (See GX_Begin()). Note that all vertices used to draw a\n particular graphics primitive will have the same format. The vertex format set using this function, along with the current vertex descriptor set\n using GX_SetVtxDesc(), completely define the vertex data format.\n\n > **Note:** The vertex format allows data to be sent to the graphics processor in its most <i>quantized</i> format. The graphics hardware will <i>inverse-quantize</i>\n the data (into floating point format) before it is used. The vertex attribute format is used to communicate the data quantization format to the hardware.<br><br>\n\n > **Note:** <tt>GX_VA_NRM</tt> and <tt>GX_VA_NBT</tt> attributes share the same type. Also, the frac for these attributes is fixed according to the type. The component count\n (compsize) for <tt>GX_VA_NRM</tt> must be set to <tt>GX_NRM_XYZ</tt>. The component count for <tt>GX_VA_NBT</tt> must be set to <tt>GX_NRM_NBT</tt> or <tt>GX_NRM_NBT3</tt>.\n\n # Arguments\n\n* `vtxfmt` (direction in) - vtxfmt\n * `vtxattr` (direction in) - vtxattr\n * `comptype` (direction in) - comptype\n * `compsize` (direction in) - compsize\n * `frac` (direction in) - number of fractional bits in a fixed-point number\n\n # Returns\n\nnone"]
    pub fn GX_SetVtxAttrFmt(vtxfmt: u8_, vtxattr: u32_, comptype: u32_, compsize: u32_, frac: u32_);
}
extern "C" {
    #[doc = "void GX_SetVtxAttrFmtv(u8 vtxfmt,GXVtxAttrFmt *attr_list)\n Sets multiple attribute formats within a single vertex format.\n\n \n\nThis is useful when you need to set all the attributes in a vertex format at once (e.g., during graphics initialization).\n\n > **Note:** The constant <tt>GX_MAX_VTXATTRFMT_LISTSIZE</tt> should be used to allocate the list. You can get a current vertex format using GX_GetVtxAttrFmtv().\n\n # Arguments\n\n* `vtxfmt` (direction in) - vtxfmt\n * `attr_list` (direction in) - pointer to array of GXVtxAttrFmt structs to draw from\n\n # Returns\n\nnone"]
    pub fn GX_SetVtxAttrFmtv(vtxfmt: u8_, attr_list: *mut GXVtxAttrFmt);
}
extern "C" {
    #[doc = "void GX_SetVtxDesc(u8 attr,u8 type)\n Sets the _type_ of a single attribute (_attr)_ in the current vertex descriptor.\n\n \n\nThe current vertex descriptor defines which attributes are present in a vertex and how each attribute is referenced. The current\n vertex descriptor is used by the Graphics Processor (GP) to interpret the graphics command stream produced by the GX API. In particular,\n the current vertex descriptor is used to parse the vertex data that is present in the command stream.\n\n # Arguments\n\n* `attr` (direction in) - vtxattr\n * `type` (direction in) - vtxattrin\n\n # Returns\n\nnone"]
    pub fn GX_SetVtxDesc(attr: u8_, type_: u8_);
}
extern "C" {
    #[doc = "void GX_SetVtxDescv(GXVtxDesc *attr_list)\n Sets the type of multiple attributes.\n\n \n\nThis function is used when more than one attribute needs to be set (e.g., during initialization of geometry).\n\n > **Note:** The constant <tt>GX_MAX_VTXATTRFMT_LISTSIZE</tt> can be used to allocate memory for _attr_list_\n\n # Arguments\n\n* `attr_list` (direction in) - array of pointers to GXVtxDesc structs; last element of the array should be <tt>GX_VA_NULL</tt>\n\n # Returns\n\nnone"]
    pub fn GX_SetVtxDescv(attr_list: *mut GXVtxDesc);
}
extern "C" {
    #[doc = "void GX_GetVtxDescv(GXVtxDesc *attr_list)\n Gets the type of multiple attributes.\n\n \n\nThis function saves the attributes that are current set. This is usually used in conjunction with GX_SetVtxDescv\n\n > **Note:** The constant <tt>GX_MAX_VTXATTRFMT_LISTSIZE</tt> must be used to allocate memory for _attr_list_\n\n # Arguments\n\n* `attr_list` (direction in) - array of pointers to GXVtxDesc structs\n\n # Returns\n\nnone"]
    pub fn GX_GetVtxDescv(attr_list: *mut GXVtxDesc);
}
extern "C" {
    #[doc = "u32 GX_EndDispList(void)\n Ends a display list and resumes writing graphics commands to the CPU FIFO.\n\n \n\nThis function returns the size of the display list written to the display list buffer since GX_BeginDispList() was called. If\n the display list size exceeds the size of the buffer allocated, a zero length size will be returned. The display list size is a\n multiple of 32B and any unsed commands in the last 32B will be padded with <tt>GX_NOP</tt>. The size returned should be passed to\n GX_CallDispList() when the display list needs to be executed.\n\n > **Note:** Due to the mechanics of flushing the write-gather pipe (which is used to create the display list), the display buffer should be\n at least 32 bytes larger than the maximum expected amount of data stored. This function calls GX_Flush(), and thus it is not necessary\n to call GX_Flush() explicitly after creating the display list.<br><br>\n\n > **Note:** A display list cannot be nested; i.e., no display list functions (GX_BeginDispList(), GX_EndDispList() and GX_CallDispList()) can\n be called between a GX_BeginDispList() and GX_EndDispList() pair.<br><br>\n\n > **Note:** To execute a display list, use GX_CallDispList().\n\n # Returns\n\n0 if display list size exceeds buffer, otherwise gives list size in bytes\n\n Specifying a display list buffer size for GX_BeginDispList() the exact size that the display list will be (after padding) will cause\n this function to return a very large (and very incorrect) value."]
    pub fn GX_EndDispList() -> u32_;
}
extern "C" {
    #[doc = "void GX_Begin(u8 primitve,u8 vtxfmt,u16 vtxcnt)\n Begins drawing of a graphics primitive.\n\n \n\nTo draw a graphics primitive, a stream of vertex data matching the description of both GX_SetVtxDesc() and GX_SetVtxAttrFmt() is\n enclosed between GX_Begin()/GX_End() pairs. The number of vertices between GX_Begin() and GX_End() must match that specified by the _vtxcnt_\n parameter. The type of the primitive will determine the minimum number of vertices required. For example, a <tt>GX_TRIANGLES</tt> primitive must\n have at least 3 vertices.\n\n > **Note:** Primitives in which the vertex order is clockwise to the viewer are considered front-facing (for culling purposes).\n\n # Arguments\n\n* `primitve` (direction in) - primtype to draw\n * `vtxfmt` (direction in) - vtxfmt to use\n * `vtxcnt` (direction in) - number of vertices being drawn; maximum is 65536"]
    pub fn GX_Begin(primitve: u8_, vtxfmt: u8_, vtxcnt: u16_);
}
extern "C" {
    #[doc = "void GX_BeginDispList(void *list,u32 size)\n Begins a display list and disables writes to the FIFO currently attached to the CPU.\n\n \n\nAfter this function is called, GX API functions that normally send command or data into the CPU FIFO will send them to the\n display list buffer instead of the FIFO until GX_EndDispList() is called. Writes to the CPU FIFO will be re-enabled when the function\n GX_EndDispList() executes.\n\n Basically you can put most of GX API commands into a display list. However, since the use of display list can bypass all state\n coherences controlled by GX API in run-time, sometimes it brings some state collisions or incoherences that may lead to unexpected\n behavior or even graphics pipeline hang. The most recommended safe way is putting only primitives (regions enclosed by GX_Begin() and\n GX_End()) that don't cause any state collisions.\n\n > **Note:** The application is expected to allocate the memory for the display list buffer. If the display list exceeds the maximum size\n of the buffer, GX_EndDispList() will return 0. The address of the buffer must be 32-byte aligned; memalign() can return 32-byte-aligned\n pointers. You can use the macro ATTRIBUTE_ALIGN(32) to align statically allocated buffers.<br><br>\n\n > **Note:** The CPU's write-gather pipe is used to write graphics commands to the display list. Therefore, the display list buffer must be\n forced out of the CPU cache prior to being filled. DCInvalidateRange() may be used for this purpose. In addition, due to the mechanics\n of flushing the write-gather pipe, the display list buffer should be at least 63 bytes larger than the maximum expected amount of data\n stored.<br><br>\n\n > **Note:** A display list cannot be nested; i.e., no display list functions (GX_BeginDispList(), GX_EndDispList() and GX_CallDispList()) can\n be called between a GX_BeginDispList() and GX_EndDispList() pair.<br><br>\n\n > **Note:** To execute a display list, use GX_CallDispList().\n\n # Arguments\n\n* `list` (direction in) - 32-byte aligned buffer to hold the list\n * `size` (direction in) - size of the buffer, multiple of 32\n\n # Returns\n\nnone"]
    pub fn GX_BeginDispList(list: *mut ::libc::c_void, size: u32_);
}
extern "C" {
    #[doc = "void GX_CallDispList(void *list,u32 nbytes)\n Causes the GP to execute graphics commands from the display _list_ instead of from the GP FIFO.\n\n \n\nWhen the number of bytes specified by _nbytes_ have been read, the graphics processor will resume executing\n commands from the graphics FIFO. Graphics commands from a display list are prefetched into a separate 4KB FIFO. This prevents\n any data prefetched for the main graphics command stream from being lost during the display list call.\n\n > **Note:** A display list cannot call another display list.<br><br>\n\n > **Note:** The display list must be padded to a length of 32B. All the data in the display list is interpreted by the graphics\n processor, so any unused memory at the end of a display list should be set to GX_NOP. If you create the display list using\n GX_BeginDispList()/GX_EndDispList(), this padding will be inserted automatically.\n\n # Arguments\n\n* `list` (direction in) - 32-byte aligned pointer to the display list buffer\n * `nbytes` (direction in) - number of bytes in the display list. Use the return value of GX_EndDispList() here.\n\n # Returns\n\nnone"]
    pub fn GX_CallDispList(list: *mut ::libc::c_void, nbytes: u32_);
}
extern "C" {
    #[doc = "void GX_AdjustForOverscan(GXRModeObj *rmin,GXRModeObj *rmout,u16 hor,u16 ver)\n Takes a given render mode and returns a version that is reduced in size to account for overscan.\n\n \n\nThe number of pixels specified by _hor_ is subtracted from each side of the screen, and the number of pixels specified\n by _ver_ is subtracted from both the top and the bottom of the screen. The active screen area is centered within what the render\n mode specified before the adjustment.\n\n > **Note:** Due to the wide possibilities of how a render mode may be configured, this function may not work in all cases. For instance,\n if you use Y-scaling to create a size difference between the EFB and XFB, this function may not do the right thing. In such cases,\n you should configure the desired render mode manually (or else call this function and then fix up the results).\n\n # Arguments\n\n* `rmin` (direction in) - rmode that is being copied\n * `rmout` (direction in) - rmode to hold the adjusted version. Needs to be allocated but can be uninitialized.\n * `hor` (direction in) - pixels to trim from each side of the screen\n * `ver` (direction in) - pixels to tim from top and bottom of the screen\n\n # Returns\n\nnone"]
    pub fn GX_AdjustForOverscan(
        rmin: *mut GXRModeObj,
        rmout: *mut GXRModeObj,
        hor: u16_,
        ver: u16_,
    );
}
extern "C" {
    #[doc = "void GX_LoadPosMtxImm(Mtx mt,u32 pnidx)\n Used to load a 3x4 modelview matrix _mt_ into matrix memory at location _pnidx._\n\n \n\nThis matrix can be used to transform positions in model space to view space, either by making the matrix the current one (see\n GX_SetCurrentMtx()), or by setting a matrix _pnidx_ for each vertex. The parameter _mt_ is a pointer to a 3x4 (row x column) matrix. The\n parameter _pnidx_ is used to refer to the matrix location (see pnmtx) in matrix memory.\n\n You can also load a normal matrix (GX_LoadNrmMtxImm() or GX_LoadNrmMtxIdx3x3()) to the same _pnidx._ Generally, the normal matrix\n will be the inverse transpose of the position matrix. The normal matrix is used during vertex lighting. In cases where the modelview\n and inverse transpose of the modelview (excluding translation) are the same, you can load the <i>same</i> matrix for both position and normal\n transforms.\n\n > **Note:** The matrix data is copied from DRAM through the CPU cache into the Graphics FIFO, so matrices loaded using this function are always\n coherent with the CPU cache.\n\n # Arguments\n\n* `mt` (direction in) - the matrix to load\n * `pnidx` (direction in) - pnmtx to load into\n\n # Returns\n\nnone"]
    pub fn GX_LoadPosMtxImm(mt: *mut [f32_; 4usize], pnidx: u32_);
}
extern "C" {
    #[doc = "void GX_LoadPosMtxIdx(u16 mtxidx,u32 pnidx)\n Loads a 3x4 modelview matrix at index _mtxidx_ from the array in main memory.\n\n \n\nThe array is set by GX_SetArray(), and the matrix is loaded into matrix memory at index _pnidx_ (see pnmtx). This\n modelview matrix is used to transform positions in model space to view space, either by making the matrix the current one (see\n GX_SetCurrentMtx()) or by setting a matrix _pnidx_ for each vertex (see GX_SetVtxDesc()). The matrix will be loaded through the vertex cache.\n\n You can also load a normal matrix (GX_LoadNrmMtxImm() or GX_LoadNrmMtxIdx3x3()) to the same _pnidx._ Generally, the normal matrix\n will be the inverse transpose of the position matrix. The normal matrix is used during vertex lighting. In cases where the modelview\n and inverse transpose of the modelview (excluding translation) are the same, you can load the <i>same</i> matrix for both position and normal\n transforms. Since indexed matrix loads are through the vertex cache, you will only incur the main memory bandwidth load of one matrix load.\n\n > **Note:** The matrix is loaded directly from main memory into the matrix memory thrugh the vertex cache, so it is incoherent with the CPU's cache.\n It is the application's responsibility to flush any matrix data from the CPU cache (see DCStoreRange()) before calling this function.\n\n # Arguments\n\n* `mtxidx` (direction in) - index to the matrix array to load\n * `pnidx` (direction in) - pnmtx to load into\n\n # Returns\n\nnone"]
    pub fn GX_LoadPosMtxIdx(mtxidx: u16_, pnidx: u32_);
}
extern "C" {
    #[doc = "void GX_LoadNrmMtxImm(Mtx mt,u32 pnidx)\n Used to load a normal transform matrix into matrix memory at location _pnidx_ from the 4x3 matrix _mt._\n\n \n\nThis matrix is used to transform normals in model space to view space, either by making it the current matrix (see GX_SetCurrentMtx()),\n or by setting a matrix pnidx for each vertex. The parameter _mt_ is a pointer to a 3x4 (row x column) matrix. The translation terms\n in the 3x4 matrix are not needed for normal rotation and are ignored during the load. The parameter _pnidx_ is used to refer to the\n matrix location (see pnmtx) in matrix memory.\n\n > **Note:** You can also load a position matrix (GX_LoadPosMtxImm()) to the same _pnidx._ Normally, the normal matrix will be the inverse transpose of\n the position (modelview) matrix and is used during vertex lighting. In cases where the modelview and the inverse transpose of the modelview\n matrix (excluding translation) are the same, the same matrix can be loaded for both normal and position matrices.<br><br>\n\n > **Note:** The matrix data is copied from main memory or the CPU cache into the Graphics FIFO, so matrices loaded by this function are always coherent\n with the CPU cache.<br><br>\n\n > **Note:** To load a normal matrix from a 3x3 matrix, use GX_LoadNrmMtxImm3x3().\n\n # Arguments\n\n* `mt` (direction in) - the matrix to load\n * `pnidx` (direction in) - pnmtx to load into\n\n # Returns\n\nnone"]
    pub fn GX_LoadNrmMtxImm(mt: *mut [f32_; 4usize], pnidx: u32_);
}
extern "C" {
    #[doc = "void GX_LoadNrmMtxImm3x3(Mtx33 mt,u32 pnidx)\n Used to load a normal transform matrix into matrix memory at location _pnidx_ from the 3x3 matrix _mt._\n\n \n\nThis matrix is used to transform normals in model space to view space, either by making it the current matrix (see GX_SetCurrentMtx()),\n or by setting a matrix pnidx for each vertex. The parameter _mt_ is a pointer to a 3x3 (row x column) matrix. The translation terms\n in the 3x3 matrix are not needed for normal rotation and are ignored during the load. The parameter _pnidx_ is used to refer to the\n matrix location (see pnmtx) in matrix memory.\n\n > **Note:** You can also load a position matrix (GX_LoadPosMtxImm()) to the same _pnidx._ Normally, the normal matrix will be the inverse transpose of\n the position (modelview) matrix and is used during vertex lighting. In cases where the modelview and the inverse transpose of the modelview\n matrix (excluding translation) are the same, the same matrix can be loaded for both normal and position matrices.<br><br>\n\n > **Note:** The matrix data is copied from main memory or the CPU cache into the Graphics FIFO, so matrices loaded by this function are always coherent\n with the CPU cache.<br><br>\n\n # Arguments\n\n* `mt` (direction in) - the matrix to load\n * `pnidx` (direction in) - pnmtx to load into\n\n # Returns\n\nnone"]
    pub fn GX_LoadNrmMtxImm3x3(mt: *mut [f32_; 3usize], pnidx: u32_);
}
extern "C" {
    #[doc = "void GX_LoadNrmMtxIdx3x3(u16 mtxidx,u32 pnidx)\n Loads a 3x3 normal matrix into matrix memory at location _pnidx_ from a 3x3 matrix located at index _mtxidx_\n from the array in main memory.\n\n \n\nThe array is set by set by GX_SetArray(), and the matrix is loaded into matrix memory at index _pnidx._ This matrix can be used to\n transform normals in model space to view space, either by making the matrix the current one (see GX_SetCurrentMtx()), or by setting a\n matrix _pnidx_ for each vertex (see GX_SetVtxDesc()). The matrix will be loaded through the vertex cache. You can also load a position\n matrix (GX_LoadPosMtxImm() or GX_LoadPosMtxIdx()) to the same _pnidx._\n\n > **Note:** You cannot use an indexed load to load a 3x3 matrix from an indexed 3x4 matrix in main memory; you must use GX_LoadNrmMtxImm() for\n this case.<br><br>\n\n > **Note:** The matrix is loaded directly from main memory into the matrix memory through the vertex cache, therefore it is incoherent with the\n CPU's cache. It is the application's responsibility to flush any matrix data from the CPU cache (see DCStoreRange()) before calling this\n function.\n\n # Arguments\n\n* `mtxidx` (direction in) - index to the matrix array to load\n * `pnidx` (direction in) - pnmtx to load into\n\n # Returns\n\nnone"]
    pub fn GX_LoadNrmMtxIdx3x3(mtxidx: u16_, pnidx: u32_);
}
extern "C" {
    #[doc = "void GX_LoadTexMtxImm(Mtx mt,u32 texidx,u8 type)\n Loads a texture matrix _mt_ into the matrix memory at location _texidx._\n\n \n\nThe matrix loaded can be either a 2x4 or 3x4 matrix as indicated by _type._ You can use the loaded matrix to\n transform texture coordinates, or to generate texture coordinates from position or normal vectors. Such generated texture\n coordinates are used for projected textures, reflection mapping, etc. See GX_SetTexCoordGen() for more details.\n\n Texture matrices can be either 2x4 or 3x4. <tt>GX_MTX_2x4</tt> matrices can be used for simple translations and/or rotations of texture\n coordinates. <tt>GX_MTX_3x4</tt> matrices are used when projection is required.\n\n > **Note:** The default matrix memory configuration allows for ten (3x4 or 2x4) texture matrices, and a 3x4 identity matrix. The <tt>GX_IDENTITY</tt>\n matrix is preloaded by GX_Init().<br><br>\n\n > **Note:** This function allows one to load post-transform texture matrices as well. Specifying a texidx in the range of dttmtx will load a\n post-transform texture matrix instead of a regular, first-pass texture matrix. Note that post-transform matrices are always 3x4. Refer to\n GX_SetTexCoordGen2() for information about how to use post-transform texture matrices.\n\n # Arguments\n\n* `mt` (direction in) - the matrix to load\n * `texidx` (direction in) - texmtx\n * `type` (direction in) - mtxtype\n\n # Returns\n\nnone"]
    pub fn GX_LoadTexMtxImm(mt: *mut [f32_; 4usize], texidx: u32_, type_: u8_);
}
extern "C" {
    #[doc = "void GX_LoadTexMtxIdx(u16 mtxidx,u32 texidx,u8 type)\n Loads a texture matrix at index _mtxidx_ from the array in main memory\n\n \n\nThe array is set by GX_SetArray(), and the matrix is loaded into matrix memory at location _texid._ The loaded matrix can be\n either 2x4 or 3x4 as indicated by _type._ This matrix can be used to generate texture coordinates from positions, normals, and input\n texture coordinates (see GX_SetTexCoordGen()). The matrix is loaded through the vertex cache. The size of the matrix to load is indicated by its\n _type._ Texture matrices can be either 2x4 or 3x4. <tt>GX_MTX_2x4</tt> matrices can be used for simple translations and/or rotations of texture\n coordinates; <tt>GX_MTX_3x4</tt> matrices are used when projection is required.\n\n > **Note:** The matrix is loaded directly from main memory into the matrix memory through the vertex cache, so it is incoherent with the CPU's\n cache. It is the application's responsibility to flush any matrix data from the CPU cache (see DCStoreRange()) before calling this function.<br><br>\n\n > **Note:** This function allows one to load post-transform texture matrices as well. Specifying a _texidx_ in the range of dttmtx will load a\n post-transform texture matrix instead of a regular, first-pass texture matrix. Note that post-transform matrices are always 3x4. Refer to\n GX_SetTexCoordGen2() for information about how to use post-transform texture matrices.\n\n # Arguments\n\n* `mtxidx` (direction in) - index to the matrix array to load\n * `texidx` (direction in) - texmtx\n * `type` (direction in) - mtxtype\n\n # Returns\n\nnone"]
    pub fn GX_LoadTexMtxIdx(mtxidx: u16_, texidx: u32_, type_: u8_);
}
extern "C" {
    #[doc = "void GX_SetCurrentMtx(u32 mtx)\n Selects a specific matrix to use for transformations.\n\n \n\nThe matrix _mtx_ specified will be used to select the current modelview transform matrix and normal transform matrix,\n as long as a matrix index is not present in the vertex data (see GX_SetVtxDesc()). If the current vertex descriptor enables <tt>GX_VA_PTNMTXIDX</tt>,\n the matrix _mtx_ specified by this function will be overwritten when the vertices are drawn.\n\n # Arguments\n\n* `mtx` (direction in) - pnmtx\n\n # Returns\n\nnone"]
    pub fn GX_SetCurrentMtx(mtx: u32_);
}
extern "C" {
    #[doc = "void GX_SetTevOp(u8 tevstage,u8 mode)\n Simplified function to set various TEV parameters for this _tevstage_ based on a predefined combiner _mode._\n\n \n\nThis is a convenience function designed to make initial programming of the Texture Environment unit (TEV) easier. This function calls\n GX_SetTevColorIn(), GX_SetTevColorOp(), GX_SetTevAlphaIn() and GX_SetTevAlphaOp() with predefined arguments to implement familiar texture\n combining functions.\n\n > **Note:** To enable a consecutive set of TEV stages, you must call GX_SetNumTevStages().\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage.\n * `mode` (direction in) - tevdefmode\n\n # Returns\n\nnone"]
    pub fn GX_SetTevOp(tevstage: u8_, mode: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevColor(u8 tev_regid,GXColor color)\n Used to set one of the primary color registers in the TEV unit.\n\n \n\nThese registers are available to all TEV stages. At least one of these registers is used to pass the output of one TEV stage to\n the next in a multi-texture configuration. The application is responsible for allocating these registers so that no collisions in usage occur.\n\n > **Note:** This function can only set unsigned 8-bit colors. To set signed, 10-bit colors use GX_SetTevColorS10().\n\n # Arguments\n\n* `tev_regid` (direction in) - tevcoloutreg.\n * `color` (direction in) - Constant color value.\n\n # Returns\n\nnone"]
    pub fn GX_SetTevColor(tev_regid: u8_, color: GXColor);
}
extern "C" {
    #[doc = "void GX_SetTevColorS10(u8 tev_regid,GXColorS10 color)\n Used to set one of the constant color registers in the TEV unit.\n\n \n\nThese registers are available to all TEV stages. At least one of these registers is used to pass the output of one TEV stage to the\n next in a multi-texture configuration. The application is responsible for allocating these registers so that no collisions in usage occur.\n\n > **Note:** This function enables the color components to be signed 10-bit numbers. To set 8-bit unsigned colors (the common case), use GX_SetTevColor().\n\n # Arguments\n\n* `tev_regid` (direction in) - tevcoloutreg.\n * `color` (direction in) - Constant color value in S10 format.\n\n # Returns\n\nnone"]
    pub fn GX_SetTevColorS10(tev_regid: u8_, color: GXColorS10);
}
extern "C" {
    #[doc = "void GX_SetTevColorIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d)\n Sets the color input sources for one _tevstage_ of the Texture Environment (TEV) color combiner.\n\n \n\nThis includes constant (register) colors and alphas, texture color/alpha, rasterized color/alpha (the result of per-vertex lighting),\n and a few useful constants.\n\n > **Note:** The input controls are independent for each TEV stage.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage\n * `a` (direction in) - tevcolorarg\n * `b` (direction in) - tevcolorarg\n * `c` (direction in) - tevcolorarg\n * `d` (direction in) - tevcolorarg\n\n # Returns\n\nnone"]
    pub fn GX_SetTevColorIn(tevstage: u8_, a: u8_, b: u8_, c: u8_, d: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevAlphaIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d)\n Sets the alpha input sources for one _tevstage_ of the Texture Environment (TEV) alpha combiner.\n\n \n\nThere are fewer alpha inputs than color inputs, and there are no color channels available in the alpha combiner.\n\n > **Note:** The input controls are independent for each TEV stage.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage\n * `a` (direction in) - tevalphaarg\n * `b` (direction in) - tevalphaarg\n * `c` (direction in) - tevalphaarg\n * `d` (direction in) - tevalphaarg\n\n # Returns\n\nnone"]
    pub fn GX_SetTevAlphaIn(tevstage: u8_, a: u8_, b: u8_, c: u8_, d: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevColorOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid)\n Sets the _tevop,_ _tevbias,_ _tevscale_ and _clamp-mode_ operation for the color combiner\n for this _tevstage_ of the TEV unit.\n\n \n\nThis function also specifies the register, _tevregid,_ that will contain the result of the color combiner function. The color\n combiner function is:<br><br>\n\n\t\t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tevregid_ = (d (_tevop)_ ((1.0 - c)*a + c*b) + _tevbias)_ * _tevscale;<br><br>_\n\n\n The input sources a,b,c and d are set using GX_SetTevColorIn().\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage.\n * `tevop` (direction in) - tevop\n * `tevbias` (direction in) - tevbias.\n * `tevscale` (direction in) - tevscale.\n * `clamp` (direction in) - Clamp results when <tt>GX_TRUE</tt>.\n * `tevregid` (direction in) - tevcoloutreg\n\n # Returns\n\nnone"]
    pub fn GX_SetTevColorOp(
        tevstage: u8_,
        tevop: u8_,
        tevbias: u8_,
        tevscale: u8_,
        clamp: u8_,
        tevregid: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetTevAlphaOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid)\n Sets the _tevop,_ _tevbias,_ _tevscale_ and _clamp-mode_ operation for the alpha combiner\n for this _tevstage_ of the TEV unit.\n\n \n\nThis function also specifies the register, _tevregid,_ that will contain the result of the alpha combiner function. The alpha\n combiner function is:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tevregid_ = (d (_tevop)_ ((1.0 - c)*a + c*b) + _tevbias)_ * _tevscale;<br><br>_\n\n The input sources a,b,c and d are set using GX_SetTevAlphaIn().\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage.\n * `tevop` (direction in) - tevop\n * `tevbias` (direction in) - tevbias.\n * `tevscale` (direction in) - tevscale.\n * `clamp` (direction in) - Clamp results when <tt>GX_TRUE</tt>.\n * `tevregid` (direction in) - tevcoloutreg\n\n # Returns\n\nnone"]
    pub fn GX_SetTevAlphaOp(
        tevstage: u8_,
        tevop: u8_,
        tevbias: u8_,
        tevscale: u8_,
        clamp: u8_,
        tevregid: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetNumTexGens(u32 nr)\n Sets the number of texture coordinates that are generated and available for use in the Texture Environment TEV stages.\n\n \n\nTexture coordinates are generated from input data as described by GX_SetTexCoordGen(). The generated texture coordinates are linked to\n specific textures and specific TEV stages using GX_SetTevOrder().\n\n > **Note:** A consecutive number of texture coordinates may be generated, starting at <tt>GX_TEXCOORD0</tt>. A maximum of 8 texture coordinates may be generated.\n If _nr_ is set to 0, no texture coordinates will be generated. In this case, at least one color channel must be output (see GX_SetNumChans()).\n\n # Arguments\n\n* `nr` (direction in) - number of tex coords to generate, between 0 and 8 inclusive\n\n # Returns\n\nnone"]
    pub fn GX_SetNumTexGens(nr: u32_);
}
extern "C" {
    #[doc = "void GX_SetTexCoordGen(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc)\n Specifies how texture coordinates are generated.\n\n \n\nOutput texture coordinates are usually the result of some transform of an input attribute; either position, normal, or texture coordinate.\n You can also generate texture coordinates from the output color channel of the per-vertex lighting calculations. In C-language syntax the texture\n coordinate generation function would look like this:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_texcoord_ = _tgen_typ(__tgen_src,_ _mtxsrc);<br><br>_\n\n The current vertex descriptor as set by GX_SetVtxDesc() only describes the data input to the graphics processor. Using this function, you can create\n new output texture coordinates from the input data. The texcoord parameter is used to give the output texture coordinate a name. This texture\n coordinate can be bound to a texture using GX_SetTevOrder(). GX_SetNumTexGens() specifies a consecutive number of texture coordinates, starting at\n <tt>GX_TEXCOORD0</tt>, that are available to GX_SetTevOrder().\n\n texmtx defines a default set of texture matrix names that can be supplied as mtxsrc. The matrix names are actually row addresses (4 floats per\n row) in the matrix memory that indicate the first row of a loaded matrix. The user may define another memory map of matrix memory to suit their\n needs. Keep in mind, however, that modelview matrices (see GX_LoadPosMtxImm() and pnmtx) and texture matrices share matrix memory.\n\n > **Note:** Input texture coordinates must always go through the texture coordinate generation hardware. GX_Init() initializes the hardware (by calling\n this function) so that all texture coordinates are transformed by the <tt>GX_IDENTITY</tt> matrix in order to appear as if input coordinates are passed\n unchanged through to the texture hardware.\n\n There are 8 output texture coordinates that can be referenced in any of the 16 TEV stages. There are a maximum of 8 input texture coordinates.\n\n # Arguments\n\n* `texcoord` (direction in) - texcoordid\n * `tgen_typ` (direction in) - texgentyp\n * `tgen_src` (direction in) - texgensrc\n * `mtxsrc` (direction in) - texmtx\n\n # Returns\n\nnone"]
    pub fn GX_SetTexCoordGen(texcoord: u16_, tgen_typ: u32_, tgen_src: u32_, mtxsrc: u32_);
}
extern "C" {
    #[doc = "void GX_SetTexCoordGen2(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc,u32 normalize,u32 postmtx)\n An extension of GX_SetTexCoordGen(). It allows one to specify additional texgen options.\n\n \n\nThe first four arguments are identical to those for GX_SetTexCoordGen() and function in the same way. All requirements for the first\n four arguments are the same as they are for that function as well. The new options only apply for \"ordinary\" texgens, where the texgen type is\n <tt>GX_TG_MTX2x4</tt> or <tt>GX_TG_MTX3x4</tt>. They do not work for light-based texgens or emboss texgens.\n\n The _normalize_ argument allows the computed texcoord to be normalized after the multiplication by _mtxsrc_ (the first-pass transformation).\n After the optional normalization step, the texcoord is then multiplied by the 3x4 matrix _postmtx._ This matrix is refered to as the\n post-transform matrix.\n\n The result of this step is the texture coordinate that is used to look up the texture.\n\n > **Note:** The post-transform matrices are separate from the first pass matrices. They are stored in a separate memory area in the same format as the\n first pass matrices, except that all matrices have three rows.<br><br>\n\n > **Note:** When a vertex contains only position and one texture coordinate and the texgen type is <tt>GX_TG_MTX2x4</tt>, there are certain limitations. In\n this special performance case, normalization is not performed (even if specified).\n\n # Arguments\n\n* `texcoord` (direction in) - texcoordid\n * `tgen_typ` (direction in) - texgentyp\n * `tgen_src` (direction in) - texgensrc\n * `mtxsrc` (direction in) - texmtx\n * `normalize` (direction in) - if <tt>GX_TRUE</tt>, normalize tex coord after first-pass transform. Only used with <tt>GX_TG_MTX*</tt>.\n * `postmtx` (direction in) - dttmtx\n\n # Returns\n\nnone"]
    pub fn GX_SetTexCoordGen2(
        texcoord: u16_,
        tgen_typ: u32_,
        tgen_src: u32_,
        mtxsrc: u32_,
        normalize: u32_,
        postmtx: u32_,
    );
}
extern "C" {
    #[doc = "void GX_SetZTexture(u8 op,u8 fmt,u32 bias)\n Controls Z texture operations.\n\n \n\nZ textures can be used to implement image-based rendering algorithms. A composite image consisting of color and depth image planes can\n be merged into the Embedded Frame Buffer (EFB).\n\n Normally, the Z for a quad (2x2) of pixels is computed as a reference Z and two slopes. Once Z texturing is enabled, the Z is computed by adding\n a Z texel to the reference Z (_op_ = <tt>GX_ZT_ADD</tt>) or by replacing the reference Z with the Z texel value (_op_ = <tt>GX_ZT_REPLACE</tt>).\n\n Z textures are always the output from the last active Texture Environment (TEV) stage (see GX_SetNumTevStages()) when enabled. When Z texturing is\n enabled, the texture color of the last TEV stage is not available, but all other color inputs and operations are available. The pixel color is\n always output from the last active TEV stage. You cannot use the TEV to operate on the Z texture, it is fed directly into the Z texture logic.\n\n Z texel formats can be unsigned 8-bit (<tt>GX_TF_Z8</tt>), 16-bit (<tt>GX_TF_Z16</tt>), or 24-bit (<tt>GX_TF_Z24X8</tt> (32-bit texture)) are used. The Graphics Processor\n converts the Z-textures to 24-bit values by placing the texel value in the least-significant bits and inserting zero's in the remaining\n most-significant bits. The 24-bit constant _bias_ is added to the Z texture. If the pixel format is GX_PF_RGB565_Z16 the 24-bit result is converted\n to the current 16-bit Z format before comparing with the EFB's Z.\n\n > **Note:** The Z-texture calculation is done before the fog range calculation.<br><br>\n\n > **Note:** GX_Init() disables Z texturing.\n\n # Arguments\n\n* `op` (direction in) - ztexop to perform\n * `fmt` (direction in) - ztexfmt to use\n * `bias` (direction in) - Bias value. Format is 24bit unsigned.\n\n # Returns\n\nnone"]
    pub fn GX_SetZTexture(op: u8_, fmt: u8_, bias: u32_);
}
extern "C" {
    #[doc = "void GX_SetZMode(u8 enable,u8 func,u8 update_enable)\n Sets the Z-buffer compare mode.\n\n \n\nThe result of the Z compare is used to conditionally write color values to the Embedded Frame Buffer (EFB).\n\n When _enable_ is set to <tt>GX_DISABLE</tt>, Z buffering is disabled and the Z buffer is not updated.\n\n The _func_ parameter determines the comparison that is performed. In the comparison function, the newly rasterized Z value is on the left\n while the Z value from the Z buffer is on the right. If the result of the comparison is false, the newly rasterized pixel is discarded.\n\n The parameter _update_enable_ determines whether or not the Z buffer is updated with the new Z value after a comparison is performed. This\n parameter also affects whether the Z buffer is cleared during copy operations (see GX_CopyDisp() and GX_CopyTex()).\n\n # Arguments\n\n* `enable` (direction in) - Enables comparisons with source and destination Z values if <tt>GX_TRUE</tt>; disables compares otherwise.\n * `func` (direction in) - compare\n * `update_enable` (direction in) - Enables Z-buffer updates when <tt>GX_TRUE</tt>; otherwise, Z-buffer updates are disabled, but compares may still be enabled.\n\n # Returns\n\nnone"]
    pub fn GX_SetZMode(enable: u8_, func: u8_, update_enable: u8_);
}
extern "C" {
    #[doc = "void GX_SetZCompLoc(u8 before_tex)\n Sets whether Z buffering happens before or after texturing.\n\n \n\nNormally, Z buffering should happen before texturing, as this enables better performance by not texturing pixels that are not\n visible; however, when alpha compare is used, Z buffering must be done after texturing (see GX_SetAlphaCompare()).\n\n # Arguments\n\n* `before_tex` (direction in) - Enables Z-buffering before texturing when set to <tt>GX_TRUE</tt>; otherwise, Z-buffering takes place after texturing.\n\n # Returns\n\nnone"]
    pub fn GX_SetZCompLoc(before_tex: u8_);
}
extern "C" {
    #[doc = "void GX_SetLineWidth(u8 width,u8 fmt)\n Sets the width of line primitives.\n\n The parameter _fmt_ is added to the texture coordinate to obtain texture coordinates at the other corners of a wide line. The _fmt_\n values are added after the texture coordinate generation operation; see GX_SetTexCoordGen().\n\n # Arguments\n\n* `width` (direction in) - width of the line in 1/16th pixel increments; maximum width is 42.5 px\n * `fmt` (direction in) - texoff\n\n # Returns\n\nnone"]
    pub fn GX_SetLineWidth(width: u8_, fmt: u8_);
}
extern "C" {
    #[doc = "void GX_SetPointSize(u8 width,u8 fmt)\n Sets the size of point primitives.\n\n \n\nThe parameter _fmt_ is added to the texture coordinate(s), if any, to obtain texture coordinates at the other corners of a point. The\n _fmts_ are added after the texture coordinate generation operation; see GX_SetTexCoordGen().\n\n # Arguments\n\n* `width` (direction in) - width of the point in 1/16th pixel increments; maximum width is 42.5 px\n * `fmt` (direction in) - texoff\n\n # Returns\n\nnone"]
    pub fn GX_SetPointSize(width: u8_, fmt: u8_);
}
extern "C" {
    #[doc = "void GX_SetBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op)\n Determines how the source image, generated by the graphics processor, is blended with the Embedded Frame Buffer (EFB).\n\n \n\nWhen _type_ is set to <tt>GX_BM_NONE</tt>, the source data is written directly to the EFB. When _type_ is set to <tt>GX_BM_BLEND</tt>, the source color and EFB\n pixels are blended using the following equation:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>src_pix_clr</i> * _src_fact_ + <i>dst_pix_clr</i> * _dst_fact_\n\n The <tt>GX_BL_DSTALPHA</tt> / <tt>GX_BL_INVDSTALPHA</tt> can be used only when the EFB has <tt>GX_PF_RGBA6_Z24</tt> as the pixel format (see GX_SetPixelFmt()). If the pixel\n format is <tt>GX_PF_RGBA6_Z24</tt> then the _src_fact_ and _dst_fact_ are also applied to the alpha channel. To write the alpha channel to the EFB you must\n call GX_SetAlphaUpdate().\n\n When type is set to <tt>GX_BM_LOGIC</tt>, the source and EFB pixels are blended using logical bitwise operations. When type is set to <tt>GX_BM_SUBTRACT</tt>, the destination\n pixel is computed as follows:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>dst_pix_clr</i> - <i>src_pix_clr [clamped to zero]</i>\n\n Note that _src_fact_ and _dst_fact_ are not part of this equation.\n\n > **Note:** Color updates should be enabled by calling GX_SetColorUpdate().\n\n # Arguments\n\n* `type` (direction in) - blendmode\n * `src_fact` (direction in) - blendfactor\n * `dst_fact` (direction in) - blendfactor\n * `op` (direction in) - logicop\n\n # Returns\n\nnone"]
    pub fn GX_SetBlendMode(type_: u8_, src_fact: u8_, dst_fact: u8_, op: u8_);
}
extern "C" {
    #[doc = "void GX_SetCullMode(u8 mode)\n Enables or disables culling of geometry based on its orientation to the viewer.\n\n \n\nPrimitives in which the vertex order is clockwise to the viewer are considered front-facing.\n\n > **Note:** GX_Init() sets this to <tt>GX_CULL_BACK</tt>.\n\n # Arguments\n\n* `mode` (direction in) - cullmode\n\n # Returns\n\nnone"]
    pub fn GX_SetCullMode(mode: u8_);
}
extern "C" {
    #[doc = "void GX_SetCoPlanar(u8 enable)\n Enables or disables coplanar triangle processing.\n\n \n\nWhile coplanar mode is enabled, all subsequent triangles (called decal triangles) will have the same Z coefficients as the reference\n plane. Coplanar mode should be enabled immediately after a reference triangle is drawn.\n\n > **Note:** The reference triangle can be culled using <tt>GX_SetCullMode(GX_CULL_ALL)</tt> to create an invisible reference plane; however, the reference\n triangle must not be completely out of view, i.e. trivially rejected by clipping.<br><br>\n\n > **Note:** GX_Init() disables coplanar mode.\n\n # Arguments\n\n* `enable` (direction in) - when <tt>GX_ENABLE</tt>, coplanar mode is enabled; <tt>GX_DISABLE</tt> disables this mode\n\n # Returns\n\nnone"]
    pub fn GX_SetCoPlanar(enable: u8_);
}
extern "C" {
    #[doc = "void GX_EnableTexOffsets(u8 coord,u8 line_enable,u8 point_enable)\n Enables a special texture offset feature for points and lines.\n\n \n\nWhen a point's size is defined using GX_SetPointSize() or a line's width is described using GX_SetLineWidth(), you can also specify a second\n parameter. The parameter _fmt_ is added to the texture coordinate(s), if any, to obtain texture coordinates at the other corners of a\n point or line. The _fmts_ are added after the texture coordinate generation operation; see GX_SetTexCoordGen(). This function enables this\n operation for a particular texture coordinate. Offset operations for points and lines are enabled separately. If the enables are false, the same\n texture coordinate is used for every vertex of the line or point.\n\n # Arguments\n\n* `coord` (direction in) - texcoordid\n * `line_enable` (direction in) - enable or disable tex offset calculation for lines\n * `point_enable` (direction in) - enable or disable tex offset calculation for points\n\n # Returns\n\nnone"]
    pub fn GX_EnableTexOffsets(coord: u8_, line_enable: u8_, point_enable: u8_);
}
extern "C" {
    #[doc = "void GX_SetClipMode(u8 mode)\n Enables or disables clipping of geometry.\n\n \n\nThis may help performance issues that occur when objects are far-clipped; however, any near-clipped objects will be rendered incorrectly.\n\n > **Note:** GX_Init() sets this to <tt>GX_CLIP_ENABLE</tt>.\n\n # Arguments\n\n* `mode` (direction in) - clipmode\n\n # Returns\n\nnone"]
    pub fn GX_SetClipMode(mode: u8_);
}
extern "C" {
    #[doc = "void GX_SetScissor(u32 xOrigin,u32 yOrigin,u32 wd,u32 ht)\n Sets the scissor rectangle.\n\n \n\nThe scissor rectangle specifies an area of the screen outside of which all primitives are culled. This function sets the scissor rectangle in\n screen coordinates. The screen origin (_xOrigin=0,_ _yOrigin=0)_ is at the top left corner of the display.\n\n The values may be within the range of 0 - 2047 inclusive. Using values that extend beyond the EFB size is allowable since the scissor box may be\n repositioned within the EFB using GX_SetScissorBoxOffset().\n\n > **Note:** By default, the scissor rectangle is set to match the viewport rectangle. GX_Init() initializes the scissor rectangle to match the viewport\n given the current render mode.\n\n # Arguments\n\n* `xOrigin` (direction in) - left-most coord in screen coordinates\n * `yOrigin` (direction in) - top-most coord in screen coordinates\n * `wd` (direction in) - width of the scissorbox in screen coordinates\n * `ht` (direction in) - height of the scissorbox in screen coordinates\n\n # Returns\n\nnone"]
    pub fn GX_SetScissor(xOrigin: u32_, yOrigin: u32_, wd: u32_, ht: u32_);
}
extern "C" {
    #[doc = "void GX_SetScissorBoxOffset(s32 xoffset,s32 yoffset)\n Repositions the scissorbox rectangle within the Embedded Frame Buffer (EFB) memory space.\n\n \n\nThe offsets are subtracted from the screen coordinates to determine the actual EFB coordinates where the pixels are stored. Thus with\n positive offsets, the scissor box may be shifted left and/or up; and with negative offsets, the scissor box may be shifted right and/or down.\n\n The intended use for this command is to make it easy to do two-pass antialiased rendering. To draw the top half of the screen, the scissor box is set to\n the top and the offset set to zero. To draw the bottom half, the scissor box is set to the bottom, and the offset is set to shift the scissor box back up\n to the top.\n\n Another use for the offset is to displace how an image is rendered with respect to the dither matrix. Since the dither matrix is 4x4, a _yoffset_ of -2\n shifts the image down by 2 lines with respect to the matrix. This can be useful for field-rendering mode.\n\n > **Note:** Achieving an offset of an odd number of lines is possible, but more difficult than just changing the scissor box: one must render and copy 2\n additional lines, then skip one by adjusting the argument of VIDEO_SetNextFrameBuffer().<br><br>\n\n > **Note:** GX_Init() initializes the scissor box offset to zero. Since the GP works on 2x2 regions of pixels, only even offsets are allowed.\n\n # Arguments\n\n* `xoffset` (direction in) - number of pixels to shift the scissorbox left, between -342 - 382 inclusive; must be even\n * `yoffset` (direction in) - number of pixels to shift the scissorbox up, between -342 - 494 inclusive; must be even\n\n # Returns\n\nnone"]
    pub fn GX_SetScissorBoxOffset(xoffset: s32, yoffset: s32);
}
extern "C" {
    #[doc = "void GX_SetNumChans(u8 num)\n Sets the number of color channels that are output to the TEV stages.\n\n \n\nColor channels are the mechanism used to compute per-vertex lighting effects. Color channels are controlled using GX_SetChanCtrl().\n Color channels are linked to specific TEV stages using GX_SetTevOrder().\n\n This function basically defines the number of per-vertex colors that get rasterized. If _num_ is set to 0, then at least one texture coordinate\n must be generated (see GX_SetNumTexGens()). If _num_ is set to 1, then channel <tt>GX_COLOR0A0</tt> will be rasterized. If _num_ is set to 2 (the maximum\n value), then <tt>GX_COLOR0A0</tt> and <tt>GX_COLOR1A1</tt> will be rasterized.\n\n # Arguments\n\n* `num` (direction in) - number of color channels to rasterize; number must be 0, 1 or 2\n\n # Returns\n\nnone"]
    pub fn GX_SetNumChans(num: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevOrder(u8 tevstage,u8 texcoord,u32 texmap,u8 color)\n Specifies the texture and rasterized color that will be available as inputs to this TEV _tevstage._\n\n The texture coordinate _texcoord_ is generated from input attributes using the GX_SetTexCoordGen() function and is used to look up the\n texture map, previously loaded by GX_LoadTexObj(). The _color_ to rasterize for this _tevstage_ is also specified. The color\n is the result of per-vertex lighting which is controlled by GX_SetChanCtrl().\n\n This function will scale the normalized texture coordinates produced by GX_SetTexCoordGen() according to the size of the texture map in the\n function call. For this reason, texture coordinates can only be broadcast to multiple texture maps if and only if the maps are the same size. In\n some cases, you may want to generate a texture coordinate having a certain scale, but disable the texture lookup (this comes up when generating\n texture coordinates for indirect bump mapping). To accomplish this, use the <tt>GX_TEXMAP_DISABLE</tt> flag:\n\n GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP3 | GX_TEXMAP_DISABLE, GX_COLORNULL); \n\nThis will scale <tt>GX_TEXCOORD0</tt> using <tt>GX_TEXMAP3</tt> but disable the lookup of <tt>GX_TEXMAP3</tt>.\n\n > **Note:** This function does not enable the TEV stage. To enable a consecutive number of TEV stages, starting at stage <tt>GX_TEVSTAGE0</tt>, use GX_SetNumTevStages().<br><br>\n\n > **Note:** The operation of each TEV stage is independent. The color operations are controlled by GX_SetTevColorIn() and GX_SetTevColorOp(). The alpha\n operations are controlled by GX_SetTevAlphaIn() and GX_SetTevAlphaOp().<br><br>\n\n > **Note:** The number of texture coordinates available for all the active TEV stages is set using GX_SetNumTexGens(). The number of color channels\n available for all the active TEV stages is set using GX_SetNumChans(). Active TEV stages should not reference more texture coordinates or colors\n than are being generated.<br><br>\n\n > **Note:** There are some special settings for the _color_ argument. If you specify <tt>GX_COLOR_ZERO</tt>, you always get zero as rasterized color. If you specify\n <tt>GX_ALPHA_BUMP</tt> or <tt>GX_ALPHA_BUMPN</tt>, you can use \"Bump alpha\" component from indirect texture unit as rasterized color input (see GX_SetTevIndirect()\n for details about how to configure bump alpha). Since bump alpha contains only 5-bit data, <tt>GX_ALPHA_BUMP</tt> shifts them to higher bits, which makes the\n value range 0-248. Meanwhile <tt>GX_ALPHA_BUMPN</tt> performs normalization and you can get the value range 0-255.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage\n * `texcoord` (direction in) - texcoordid\n * `texmap` (direction in) - texmapid\n * `color` (direction in) - channelid\n\n # Returns\n\nnone"]
    pub fn GX_SetTevOrder(tevstage: u8_, texcoord: u8_, texmap: u32_, color: u8_);
}
extern "C" {
    #[doc = "void GX_SetNumTevStages(u8 num)\n Enables a <i>consecutive</i> number of TEV stages.\n\n \n\nThe output pixel color (before fogging and blending) is the result from the last stage. The last TEV stage must write to register <tt>GX_TEVPREV</tt>;\n see GX_SetTevColorOp() and GX_SetTevAlphaOp(). At least one TEV stage must be enabled. If a Z-texture is enabled, the Z texture must be looked up on\n the last stage; see GX_SetZTexture().\n\n > **Note:** The association of lighting colors, texture coordinates, and texture maps with a TEV stage is set using GX)SetTevOrder(). The number of texture\n coordinates available is set using GX_SetNumTexGens(). The number of color channels available is set using GX_SetNumChans().<br><br>\n\n > **Note:** GX_Init() will set _num_ to 1.\n\n # Arguments\n\n* `num` (direction in) - number of active TEV stages, between 1 and 16 inclusive\n\n # Returns\n\nnone"]
    pub fn GX_SetNumTevStages(num: u8_);
}
extern "C" {
    #[doc = "void GX_SetAlphaCompare(u8 comp0,u8 ref0,u8 aop,u8 comp1,u8 ref1)\n Sets the parameters for the alpha compare function which uses the alpha output from the last active TEV stage.\n\n \n\nThe alpha compare operation is:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>alpha_pass</i> = (<i>alpha_src</i> (_comp0)_ _ref0)_ (_op)_ (<i>alpha_src</i> (_comp1)_ _ref1)<br><br>_\n\n where <i>alpha_src</i> is the alpha from the last active TEV stage. As an example, you can implement these equations:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>alpha_pass</i> = (<i>alpha_src</i> _ref0)_ <b>AND</b> (<i>alpha_src</i> _ref1)_\n\n or\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>alpha_pass</i> = (<i>alpha_src</i> _ref0)_ <b>OR</b> (<i>alpha_src</i> _ref1)_\n\n > **Note:** The output alpha can be used in the blending equation (see GX_SetBlendMode()) to control how source and destination (frame buffer)\n pixels are combined.<br><br>\n\n > **Note:** The Z compare can occur either before or after texturing (see GX_SetZCompLoc()). In the case where Z compare occurs before texturing, the Z is\n written based only on the Z test. The color is written if both the Z test and alpha test pass. When Z compare occurs <i>after</i> texturing, the color\n and Z are written if both the Z test and alpha test pass. When using texture to make cutout shapes (like billboard trees) that need to be correctly Z\n buffered, you should configure the pipeline to Z buffer after texturing.<br><br>\n\n > **Note:** The number of active TEV stages is specified using GX_SetNumTevStages().\n\n # Arguments\n\n* `comp0` (direction in) - compare subfunction 0\n * `ref0` (direction in) - reference val for subfunction 0\n * `aop` (direction in) - alphaop for combining subfunctions 0 and 1; must not be <tt>GX_MAX_ALPHAOP</tt>\n * `comp1` (direction in) - compare subfunction 1\n * `ref1` (direction in) - reference val for subfunction 1\n\n # Returns\n\nnone"]
    pub fn GX_SetAlphaCompare(comp0: u8_, ref0: u8_, aop: u8_, comp1: u8_, ref1: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevKColor(u8 sel, GXColor col)\n Sets one of the \"konstant\" color registers in the TEV unit.\n\n \n\nThese registers are available to all TEV stages. They are constant in the sense that they cannot be written to be the TEV itself.\n\n # Arguments\n\n* `sel` (direction in) - tevkcolorid\n * `col` (direction in) - constant color value\n\n # Returns\n\nnone"]
    pub fn GX_SetTevKColor(sel: u8_, col: GXColor);
}
extern "C" {
    #[doc = "void GX_SetTevKColorSel(u8 tevstage,u8 sel)\n Selects a \"konstant\" color input to be used in a given TEV stage.\n\n The constant color input is used only if <tt>GX_CC_KONST</tt> is selected for an input for that TEV stage. Only one constant color selection is\n available for a given TEV stage, though it may be used for more than one input.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage\n * `sel` (direction in) - tevkcolorsel\n\n # Returns\n\nnone"]
    pub fn GX_SetTevKColorSel(tevstage: u8_, sel: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevKAlphaSel(u8 tevstage,u8 sel)\n Selects a \"konstant\" alpha input to be used in a given TEV stage.\n\n \n\nThe constant alpha input is used only if <tt>GX_CA_KONST</tt> is selected for an input for that TEV stage. Only one constant alpha selection is\n available for a given TEV stage, though it may be used for more than one input.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage\n * `sel` (direction in) - tevkalphasel\n\n # Returns\n\nnone"]
    pub fn GX_SetTevKAlphaSel(tevstage: u8_, sel: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevKColorS10(u8 sel, GXColorS10 col)\n Used to set one of the constant color registers in the Texture Environment (TEV) unit.\n\n \n\nThese registers are available to all TEV stages. At least one of these registers is used to pass the output of one TEV stage to the next\n in a multi-texture configuration.\n\n > **Note:** The application is responsible for allocating these registers so that no collisions in usage occur.<br><br>\n\n > **Note:** This function takes 10-bit signed values as color values; use GX_SetTevColor() to give 8-bit values.\n\n # Arguments\n\n* `sel` (direction in) - tevcoloutreg\n * `col` (direction in) - constant color value\n\n # Returns\n\nnone"]
    pub fn GX_SetTevKColorS10(sel: u8_, col: GXColorS10);
}
extern "C" {
    #[doc = "void GX_SetTevSwapMode(u8 tevstage,u8 ras_sel,u8 tex_sel)\n Selects a set of swap modes for the rasterized color and texture color for a given TEV stage.\n\n \n\nThis allows the color components of these inputs to be rearranged or duplicated.\n\n > **Note:** There are four different swap mode table entries, and each entry in the table specifies how the RGBA inputs map to the RGBA outputs.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage\n * `ras_sel` (direction in) - selects a swap mode for the rasterized color input.\n * `tex_sel` (direction in) - selects a swap mode for the texture color input.\n\n # Returns\n\nnone"]
    pub fn GX_SetTevSwapMode(tevstage: u8_, ras_sel: u8_, tex_sel: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevSwapModeTable(u8 swapid,u8 r,u8 g,u8 b,u8 a)\n Sets up the TEV color swap table.\n\n \n\nThe swap table allows the rasterized color and texture color to be swapped component-wise. An entry in the table specifies how the\n input color components map to the output color components.\n\n # Arguments\n\n* `swapid` (direction in) - tevswapsel\n * `r` (direction in) - input color component that should be mapped to the red output component.\n * `g` (direction in) - input color component that should be mapped to the green output component.\n * `b` (direction in) - input color component that should be mapped to the blue output component.\n * `a` (direction in) - input color component that should be mapped to the alpha output component.\n\n # Returns\n\nnone"]
    pub fn GX_SetTevSwapModeTable(swapid: u8_, r: u8_, g: u8_, b: u8_, a: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevIndirect(u8 tevstage,u8 indtexid,u8 format,u8 bias,u8 mtxid,u8 wrap_s,u8 wrap_t,u8 addprev,u8 utclod,u8 a)\n Controls how the results from an indirect lookup will be used to modify a given regular TEV stage lookup.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage being affected\n * `indtexid` (direction in) - indtexstage results to use with this TEV stage\n * `format` (direction in) - indtexformat, i.e. how many bits to extract from the indirect result color to use in indirect offsets and the indirect \"bump\" alpha\n * `bias` (direction in) - indtexbias to be applied to each component of the indirect offset\n * `mtxid` (direction in) - which indtexmtx and scale value to multiply the offsets with\n * `wrap_s` (direction in) - indtexwrap to use with the S component of the regular texture coordinate\n * `wrap_t` (direction in) - indtexwrap to use with the T component of the regular texture coordinate\n * `addprev` (direction in) - whether the tex coords results from the previous TEV stage should be added in\n * `utclod` (direction in) - whether to the unmodified (<tt>GX_TRUE</tt>) or modified (<tt>GX_FALSE</tt>) tex coords for mipmap LOD computation\n * `a` (direction in) - which offset component will supply the indtexalphasel, if any\n\n # Returns\n\nnone"]
    pub fn GX_SetTevIndirect(
        tevstage: u8_,
        indtexid: u8_,
        format: u8_,
        bias: u8_,
        mtxid: u8_,
        wrap_s: u8_,
        wrap_t: u8_,
        addprev: u8_,
        utclod: u8_,
        a: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetTevDirect(u8 tevstage)\n Used to turn off all indirect texture processing for the specified regular TEV stage.\n\n # Arguments\n\n* `tevstage` (direction in) - the tevstage to change\n\n # Returns\n\nnone"]
    pub fn GX_SetTevDirect(tevstage: u8_);
}
extern "C" {
    #[doc = "void GX_SetNumIndStages(u8 nstages)\n Used to set how many indirect lookups will take place.\n\n \n\nThe results from these indirect lookups may then be used to alter the lookups for any number of regular TEV stages.\n\n # Arguments\n\n* `nstages` (direction in) - number of indirect lookup stages\n\n # Returns\n\nnone"]
    pub fn GX_SetNumIndStages(nstages: u8_);
}
extern "C" {
    #[doc = "void GX_SetIndTexOrder(u8 indtexstage,u8 texcoord,u8 texmap)\n Used to specify the _texcoord_ and _texmap_ to used with a given indirect lookup.\n\n # Arguments\n\n* `indtexstage` (direction in) - indtexstage being affected\n * `texcoord` (direction in) - texcoordid to be used for this stage\n * `texmap` (direction in) - texmapid to be used for this stage\n\n # Returns\n\nnone"]
    pub fn GX_SetIndTexOrder(indtexstage: u8_, texcoord: u8_, texmap: u8_);
}
extern "C" {
    #[doc = "void GX_SetIndTexCoordScale(u8 indtexid,u8 scale_s,u8 scale_t)\n Allows the sharing of a texcoord between an indirect stage and a regular TEV stage.\n\n It allows the texture coordinates to be scaled down for use with an indirect map that is smaller than the corresponding regular map.\n\n # Arguments\n\n* `indtexid` (direction in) - indtexstage being affected\n * `scale_s` (direction in) - indtexscale factor for the S coord\n * `scale_t` (direction in) - indtexscale factor for the T coord\n\n # Returns\n\nnone"]
    pub fn GX_SetIndTexCoordScale(indtexid: u8_, scale_s: u8_, scale_t: u8_);
}
extern "C" {
    #[doc = "void GX_SetFog(u8 type,f32 startz,f32 endz,f32 nearz,f32 farz,GXColor col)\n Enables fog.\n\n \n\nUsing _type,_ the programmer may select one of several functions to control the fog density as a function of range to a quad (2x2 pixels).\n Range is cosine corrected Z in the x-z plane (eye coordinates), but is not corrected in the y direction (see GX_SetFogRangeAdj()). The parameters _startz_ and\n _endz_ allow further control over the fog behavior. The parameters _nearz_ and _farz_ should be set consistent with the projection matrix parameters. Note that these\n parameters are defined in eye-space. The fog color, in RGBX format (i.e. the alpha component is ignored), is set using the _col_ parameter. This will be the\n color of the pixel when fully fogged.\n\n > **Note:** GX_Init() turns fog off by default.\n\n # Arguments\n\n* `type` (direction in) - fogtype to use\n * `startz` (direction in) - minimum Z value at which the fog function is active\n * `endz` (direction in) - maximum Z value at which the fog function is active\n * `nearz` (direction in) - near plane (which should match the projection matrix parameters)\n * `farz` (direction in) - far plane (which should match the projection matrix parameters)\n * `col` (direction in) - fog color; alpha component is ignored\n\n # Returns\n\nnone"]
    pub fn GX_SetFog(type_: u8_, startz: f32_, endz: f32_, nearz: f32_, farz: f32_, col: GXColor);
}
extern "C" {
    #[doc = "void GX_SetFogRangeAdj(u8 enable,u16 center,GXFogAdjTbl *table)\n Enables or disables horizontal fog-range adjustment.\n\n \n\nThis adjustment is a factor that is multiplied by the eye-space Z used for fog computation; it is based upon the X position of the pixels being\n rendered. The Y direction is not compensated. This effectively increases the fog density at the edges of the screen, making for a more realistic fog\n effect. The adjustment is computed per quad (2x2 pixels), not per-pixel. The center of the viewport is specified using _center._ The range adjustment\n table is specified using _table._ The range adjust function is mirrored horizontally about the _center._\n\n > **Note:** GX_Init() disables range adjustment.\n\n [`GX_InitFogAdjTable()`]\n\n # Arguments\n\n* `enable` (direction in) - enables adjustment when <tt>GX_ENABLE</tt> is passed; disabled with <tt>GX_DISABLE</tt>\n * `center` (direction in) - centers the range adjust function; normally corresponds with the center of the viewport\n * `table` (direction in) - range adjustment parameter table\n\n # Returns\n\nnone"]
    pub fn GX_SetFogRangeAdj(enable: u8_, center: u16_, table: *mut GXFogAdjTbl);
}
extern "C" {
    #[doc = "GX_SetFogColor(GXColor color)\n Sets the fog color.\n\n \n\n_color_ is the color that a pixel will be if fully fogged. Alpha channel is ignored.\n\n # Arguments\n\n* `color` (direction in) - color to set fog to"]
    pub fn GX_SetFogColor(color: GXColor);
}
extern "C" {
    #[doc = "void GX_InitFogAdjTable(GXFogAdjTbl *table,u16 width,f32 projmtx[4][4])\n Generates the standard range adjustment table and puts the results into _table._\n\n \n\nThis table can be used by GX_SetFogRangeAdj() to adjust the eye-space Z used for fog based upon the X position of the pixels being rendered.\n The Y direction is not compensated. This effectively increases the fog density at the edges of the screen, making for a more realistic fog effect. The\n width of the viewport is specified using _width._ The _projmtx_ parameter is the projection matrix that is used to render into the viewport. It must\n be specified so that the function can compute the X extent of the viewing frustum in eye space.\n\n > **Note:** You must allocate _table_ yourself.\n\n # Arguments\n\n* `table` (direction in) - range adjustment parameter table\n * `width` (direction in) - width of the viewport\n * `projmtx` (direction in) - projection matrix used to render into the viewport"]
    pub fn GX_InitFogAdjTable(table: *mut GXFogAdjTbl, width: u16_, projmtx: *mut [f32_; 4usize]);
}
extern "C" {
    #[doc = "void GX_SetIndTexMatrix(u8 indtexmtx,f32 offset_mtx[2][3],s8 scale_exp)\n Sets one of the three static indirect matrices and the associated scale factor.\n\n \n\nThe indirect matrix and scale is used to process the results of an indirect lookup in order to produce offsets to use during a regular lookup.\n The matrix is multiplied by the [S T U] offsets that have been extracted (and optionally biased) from the indirect lookup color. In this matrix-vector\n multiply, the matrix is on the left and the [S T U] column vector is on the right.\n\n > **Note:** The matrix values are stored in the hardware as a sign and 10 fractional bits (two's complement); thus the smallest number that can be stored is\n -1 and the largest is (1 - 1/1024) or approximately 0.999. Since +1 cannot be stored, you may consider dividing all the matrix values by 2 (thus +1\n becomes +0.5) and adding one to the scale value in order to compensate.\n\n # Arguments\n\n* `indtexmtx` (direction in) - indtexmtx that is being affected\n * `offset_mtx` (direction in) - values to assign to the indirect matrix\n * `scale_exp` (direction in) - exponent to use for the associated scale factor\n\n # Returns\n\nnone"]
    pub fn GX_SetIndTexMatrix(indtexmtx: u8_, offset_mtx: *mut [f32_; 3usize], scale_exp: s8);
}
extern "C" {
    #[doc = "void GX_SetTevIndBumpST(u8 tevstage,u8 indstage,u8 mtx_sel)\n Sets up an environment-mapped bump-mapped indirect lookup.\n\n \n\nThe indirect map specifies offsets in (S,T) space. This kind of lookup requires 3 TEV stages to compute. As a result of all this work, a simple\n 2D bump map is properly oriented to the surface to which it is applied. It is used to alter a normal-based texgen which then looks up an environment map.\n The environment map may be a simple light map, or else it may be a reflection map of the surrounding scenery.\n\n > **Note:** When using this function, texture lookup should be disabled for the first two TEV stages. The third stage is where the texture lookup is actually performed.\n The associated geometry must supply normal/binormal/tangent coordinates at each vertex. Appropriate texgens must supply each of these to the proper stages\n (binormal to the first, tangent to the second, and normal to the third). Although a static indirect matrix is not used, one must choose a matrix slot and set up\n the associated scale value to be used with this lookup.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage that is being affected\n * `indstage` (direction in) - indtexstage results to use with this TEV stage\n * `mtx_sel` (direction in) - which indtexmtx to multiply the offsets with\n\n # Returns\n\nnone"]
    pub fn GX_SetTevIndBumpST(tevstage: u8_, indstage: u8_, mtx_sel: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevIndBumpXYZ(u8 tevstage,u8 indstage,u8 mtx_sel)\n Sets up an environment-mapped bump-mapped indirect lookup.\n\n \n\nThe indirect map specifies offsets in object (X, Y, Z) space. This kind of lookup requires only one TEV stage to compute; however, the bump map (indirect\n map) used is geometry-specific. Thus there is a space/computation tradeoff between using this function and using GX_SetTevIndBumpST().\n\n > **Note:** The indirect matrix must be loaded with a transformation for normals from object space to texture space (similar to eye space, but possibly with an inverted\n Y axis). The surface geometry need only provide regular normals at each vertex. A normal-based texgen must be set up for the regular texture coordinate.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage that is being affected\n * `indstage` (direction in) - indtexstage results to use with this TEV stage\n * `mtx_sel` (direction in) - which indtexmtx to multiply the offsets with\n\n # Returns\n\nnone"]
    pub fn GX_SetTevIndBumpXYZ(tevstage: u8_, indstage: u8_, mtx_sel: u8_);
}
extern "C" {
    #[doc = "void GX_SetTevIndTile(u8 tevstage,u8 indtexid,u16 tilesize_x,u16 tilesize_y,u16 tilespacing_x,u16 tilespacing_y,u8 indtexfmt,u8 indtexmtx,u8 bias_sel,u8 alpha_sel)\n Used to implement tiled texturing using indirect textures.\n\n \n\nIt will set up the correct values in the given indirect matrix; you only need to specify which matrix slot to use.\n\n > **Note:** The regular texture map contains only the tile definitions. The actual texture size to be applied to the polygon being drawn is the product of the base tile\n size and the size of the indirect map. In order to set the proper texture coordinate scale, one must call GX_SetTexCoordScaleManually(). One can also use\n GX_SetIndTexCoordScale() in order to use the same texcoord for the indirect stage as the regular TEV stage.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage that is being affected\n * `indtexid` (direction in) - indtexstage results to use with this TEV stage\n * `tilesize_x` (direction in) - size of the tile in the X dimension\n * `tilesize_y` (direction in) - size of the tile in the Y dimension\n * `tilespacing_x` (direction in) - spacing of the tiles (in the tile-definition map) in the X dimension\n * `tilespacing_y` (direction in) - spacing of the tiles (in the tile-definition map) in the Y dimension\n * `indtexfmt` (direction in) - indtexformat to use\n * `indtexmtx` (direction in) - indtexmtx to multiply the offsets with\n * `bias_sel` (direction in) - indtexbias to indicate tile stacking direction for pseudo-3D textures\n * `alpha_sel` (direction in) - which indtexalphasel will supply the indirect \"bump\" alpha, if any (for pseudo-3D textures).\n\n # Returns\n\nnone"]
    pub fn GX_SetTevIndTile(
        tevstage: u8_,
        indtexid: u8_,
        tilesize_x: u16_,
        tilesize_y: u16_,
        tilespacing_x: u16_,
        tilespacing_y: u16_,
        indtexfmt: u8_,
        indtexmtx: u8_,
        bias_sel: u8_,
        alpha_sel: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetTevIndWarp(u8 tevstage, u8 indtexid, u8 bias_flag, u8 replace_tex, u8 mtxid)\n Used to warp a normal texture lookup using an indirect texture map with 8-bit offsets.\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage that is being affected\n * `indtexid` (direction in) - indtexstage results to use with this TEV stage\n * `bias_flag` (direction in) - biases the indirect texture map offsets by -128 if the value is GX_TRUE\n * `replace_tex` (direction in) - GX_TRUE makes the indirect texture map offsets replace the input texture coordinates rather than offset them as with GX_FALSE\n * `mtxid` (direction in) - which indtexmtx to use for warping the texture\n # Returns\n\nnone"]
    pub fn GX_SetTevIndWarp(
        tevstage: u8_,
        indtexid: u8_,
        bias_flag: u8_,
        replace_tex: u8_,
        mtxid: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetTevIndRepeat(u8 tevstage)\n Set a given TEV stage to use the same texture coordinates as were computed in the previous stage.\n\n > **Note:** This is only useful when the previous stage texture coordinates took more than one stage to compute, as is the case for GX_SetTevIndBumpST().\n\n # Arguments\n\n* `tevstage` (direction in) - tevstage to modify\n\n # Returns\n\nnone"]
    pub fn GX_SetTevIndRepeat(tevstage: u8_);
}
extern "C" {
    #[doc = "void GX_SetColorUpdate(u8 enable)\n Enables or disables color-buffer updates when rendering into the Embedded Frame Buffer (EFB).\n\n > **Note:** This function also affects whether the color buffer is cleared during copies; see GX_CopyDisp() and GX_CopyTex().\n\n # Arguments\n\n* `enable` (direction in) - enables color-buffer updates with <tt>GX_TRUE</tt>\n\n # Returns\n\nnone"]
    pub fn GX_SetColorUpdate(enable: u8_);
}
extern "C" {
    #[doc = "void GX_SetAlphaUpdate(u8 enable)\n Enables or disables alpha-buffer updates of the Embedded Frame Buffer (EFB).\n\n > **Note:** This function also affects whether the alpha buffer is cleared during copy operations; see GX_CopyDisp() and GX_CopyTex().<br><br>\n\n > **Note:** The only EFB pixel format supporting an alpha buffer is <tt>GX_PF_RGBA6_Z24</tt>; see GX_SetPixelFmt(). The alpha _enable_ is ignored for non-alpha\n pixel formats.\n\n # Arguments\n\n* `enable` (direction in) - enables alpha-buffer updates with <tt>GX_TRUE</tt>\n\n # Returns\n\nnone"]
    pub fn GX_SetAlphaUpdate(enable: u8_);
}
extern "C" {
    #[doc = "void GX_SetPixelFmt(u8 pix_fmt,u8 z_fmt)\n Sets the format of pixels in the Embedded Frame Buffer (EFB).\n\n \n\nThere are two non-antialiased _pix_fmts:_ <tt>GX_PF_RGB8_Z24</tt> and <tt>GX_PF_RGBA6_Z24</tt>. The stride of the EFB is fixed at 640 pixels. The\n non-antialiased EFB has 528 lines available.\n\n When _pix_fmt_ is set to <tt>GX_PF_RGB565_Z16</tt>, multi-sample antialiasing is enabled. In order to get proper results, one must also call GX_SetCopyFilter().\n The position of the subsamples and the antialiasing filter coefficients are set using GX_SetCopyFilter(). When antialiasing, three 16b color/Z\n samples are computed for each pixel, and the total available number of pixels in the EFB is reduced by half (640 pixels x 264 lines). This function also sets the\n compression type for 16-bit Z formats, which allows trading off Z precision for range. The following guidelines apply:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a) far/near ratio <= 2^16, use <tt>GX_ZC_LINEAR</tt><br>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b) far/near ratio <= 2^18, use <tt>GX_ZC_NEAR</tt><br>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c) far/near ratio <= 2^20, use <tt>GX_ZC_MID</tt><br>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d) far/near ratio <= 2^24, use <tt>GX_ZC_FAR</tt><br><br>\n\n It is always best to use as little compression as possible (choice \"a\" is least compressed, choice \"d\" is most compressed). You get less precision with higher compression.\n The \"far\" in the above list does not necessarily refer to the far clipping plane. You should think of it as the farthest object you want correct occlusion for.\n\n > **Note:** This function also controls antialiasing (AA) mode.<br><br>\n\n > **Note:** Since changing pixel format requires the pixel pipeline to be synchronized, the use of this function causes stall of the graphics processor as a result. Therefore,\n you should avoid redundant calls of this function.\n\n # Arguments\n\n* `pix_fmt` (direction in) - <tt>GX_PF_RGB8_Z24</tt> or <tt>GX_PF_RGBA6_Z24</tt> for non-AA, <tt>GX_PF_RGB565_Z16</tt> for AA\n * `z_fmt` (direction in) - zfmt to use\n\n # Returns\n\nnone"]
    pub fn GX_SetPixelFmt(pix_fmt: u8_, z_fmt: u8_);
}
extern "C" {
    #[doc = "void GX_SetDither(u8 dither)\n Enables or disables dithering.\n\n \n\nA 4x4 Bayer matrix is used for dithering.\n\n > **Note:** Only valid when the pixel format (see GX_SetPixelFmt()) is either <tt>GX_PF_RGBA6_Z24</tt> or <tt>GX_PF_RGB565_Z16</tt>.<br><br>\n\n > **Note:** Dithering should probably be turned off if you are planning on using the result of rendering for comparisons (e.g. outline rendering\n algorithm that writes IDs to the alpha channel, copies the alpha channel to a texture, and later compares the texture in the TEV).\n\n # Arguments\n\n* `dither` (direction in) - enables dithering if <tt>GX_TRUE</tt> is given and pixel format is one of the two above, otherwise disabled\n\n # Returns\n\nnone"]
    pub fn GX_SetDither(dither: u8_);
}
extern "C" {
    #[doc = "void GX_SetDstAlpha(u8 enable,u8 a)\n Sets a constant alpha value for writing to the Embedded Frame Buffer (EFB).\n\n > **Note:** To be effective, the EFB pixel type must have an alpha channel (see GX_SetPixelFmt()). The alpha compare operation (see\n GX_SetAlphaCompare()) and blending operations (see GX_SetBlendMode()) still use source alpha (output from the last TEV stage) but when\n writing the pixel color, the constant alpha will replace the pixel alpha in the EFB.\n\n # Arguments\n\n* `enable` (direction in) - _a_ will be written to the framebuffer if <tt>GX_ENABLE</tt> is here and frame buffer pixel format supports destination alpha\n * `a` (direction in) - constant alpha value\n\n # Returns\n\nnone"]
    pub fn GX_SetDstAlpha(enable: u8_, a: u8_);
}
extern "C" {
    #[doc = "void GX_SetFieldMask(u8 even_mask,u8 odd_mask)\n selectively enables and disables interlacing of the frame buffer image.\n\n \n\nThis function is used when rendering fields to an interlaced Embedded Frame Buffer (EFB).\n\n > **Note:** When the mask is <tt>GX_FALSE</tt>, that field will not be written to the EFB, but the other field will be computed. In other words, you pay the\n fill rate price of a frame to produce a field.\n\n # Arguments\n\n* `even_mask` (direction in) - whether to write pixels with even Y coordinate\n * `odd_mask` (direction in) - whether to write pixels with odd Y coordinate\n\n # Returns\n\nnone"]
    pub fn GX_SetFieldMask(even_mask: u8_, odd_mask: u8_);
}
extern "C" {
    #[doc = "void GX_SetFieldMode(u8 field_mode,u8 half_aspect_ratio)\n Controls various rasterization and texturing parameters that relate to field-mode and double-strike rendering.\n\n \n\nIn field-mode rendering, one must adjust the vertical part of the texture LOD computation to account for the fact that pixels cover only half of\n the space from one rendered scan line to the next (with the other half of the space filled by a pixel from the other field). In both field-mode and\n double-strike rendering, one must adjust the aspect ratio for points and lines to account for the fact that pixels will be double-height when displayed\n (the pixel aspect ratio is 1/2).\n\n > **Note:** The values set here usually come directly from the render mode. The _field_rendering_ flags goes straight into _field_mode._ The _half_aspect_ratio_\n parameter is true if the _xfbHeight_ is half of the _viHeight,_ false otherwise.<br><br>\n\n > **Note:** GX_Init() sets both fields according to the default render mode.<br><br>\n\n > **Note:** On production hardware (i.e. a retail GameCube), only line aspect-ratio adjustment is implemented. Points are not adjusted.\n\n # Arguments\n\n* `field_mode` (direction in) - adjusts texture LOD computation as described above if true, otherwise does not\n * `half_aspect_ratio` (direction in) - adjusts line aspect ratio accordingly, otherwise does not\n\n # Returns\n\nnone"]
    pub fn GX_SetFieldMode(field_mode: u8_, half_aspect_ratio: u8_);
}
extern "C" {
    #[doc = "f32 GX_GetYScaleFactor(u16 efbHeight,u16 xfbHeight)\n Calculates an appropriate Y scale factor value for GX_SetDispCopyYScale() based on the height of the EFB and\n the height of the XFB.\n\n # Arguments\n\n* `efbHeight` (direction in) - Height of embedded framebuffer. Range from 2 to 528. Should be a multiple of 2.\n * `xfbHeight` (direction in) - Height of external framebuffer. Range from 2 to 1024. Should be equal or greater than _efbHeight._\n\n # Returns\n\nY scale factor which can be used as argument of GX_SetDispCopyYScale()."]
    pub fn GX_GetYScaleFactor(efbHeight: u16_, xfbHeight: u16_) -> f32_;
}
extern "C" {
    #[doc = "u32 GX_SetDispCopyYScale(f32 yscale)\n Sets the vertical scale factor for the EFB to XFB copy operation.\n\n \n\nThe number of actual lines copied is returned, based on the current EFB height. You can use this number to allocate the proper XFB size. You\n have to call GX_SetDispCopySrc() prior to this function call if you want to get the number of lines by using this function.\n\n # Arguments\n\n* `yscale` (direction in) - Vertical scale value. Range from 1.0 to 256.0.\n\n # Returns\n\nNumber of lines that will be copied."]
    pub fn GX_SetDispCopyYScale(yscale: f32_) -> u32_;
}
extern "C" {
    #[doc = "void GX_SetDispCopySrc(u16 left,u16 top,u16 wd,u16 ht)\n Sets the source parameters for the EFB to XFB copy operation.\n\n # Arguments\n\n* `left` (direction in) - left most source pixel to copy. Must be a multiple of 2 pixels.\n * `top` (direction in) - top most source line to copy. Must be a multiple of 2 lines.\n * `wd` (direction in) - width in pixels to copy. Must be a multiple of 2 pixels.\n * `ht` (direction in) - height in lines to copy. Must be a multiple of 2 lines.\n\n # Returns\n\nnone"]
    pub fn GX_SetDispCopySrc(left: u16_, top: u16_, wd: u16_, ht: u16_);
}
extern "C" {
    #[doc = "void GX_SetDispCopyDst(u16 wd,u16 ht)\n Sets the witdth and height of the display buffer in pixels.\n\n \n\nThe application typical renders an image into the EFB(source) and then copies it into the XFB(destination) in main memory. _wd_\n specifies the number of pixels between adjacent lines in the destination buffer and can be different than the width of the EFB.\n\n # Arguments\n\n* `wd` (direction in) - Distance between successive lines in the XFB, in pixels. Must be a multiple of 16.\n * `ht` (direction in) - Height of the XFB in lines.\n\n # Returns\n\nnone"]
    pub fn GX_SetDispCopyDst(wd: u16_, ht: u16_);
}
extern "C" {
    #[doc = "void GX_SetCopyClamp(u8 clamp)\n Sets the vertical clamping mode to use during the EFB to XFB or texture copy.\n\n # Arguments\n\n* `clamp` (direction in) - bit-wise OR of desired xfbclamp. Use <tt>GX_CLAMP_NONE</tt> for no clamping.\n\n # Returns\n\nnone"]
    pub fn GX_SetCopyClamp(clamp: u8_);
}
extern "C" {
    #[doc = "void GX_SetDispCopyGamma(u8 gamma)\n Sets the gamma correction applied to pixels during EFB to XFB copy operation.\n\n # Arguments\n\n* `gamma` (direction in) - gammamode\n\n # Returns\n\nnone"]
    pub fn GX_SetDispCopyGamma(gamma: u8_);
}
extern "C" {
    #[doc = "void GX_SetCopyFilter(u8 aa,u8 sample_pattern[12][2],u8 vf,u8 vfilter[7])\n Sets the subpixel sample patterns and vertical filter coefficients used to filter subpixels into pixels.\n\n \n\nThis function normally uses the _aa,_ _sample_pattern_ and _vfilter_ provided by the render mode struct:<br><br>\n\n GXRModeObj* rmode = VIDEO_GetPreferredMode(NULL);\n GX_SetCopyFilter(rmode->aa,rmode->sample_pattern,GX_TRUE,rmode->vfilter); > **Note:** In order to make use of the _sample_pattern,_ antialiasing must be enabled by setting the Embedded Frame Buffer (EFB) format to\n <tt>GX_PF_RGB565_Z16</tt>; see GX_SetPixelFmt().\n\n # Arguments\n\n* `aa` (direction in) - utilizes _sample_pattern_ if <tt>GX_TRUE</tt>, otherwise all sample points are centered\n * `sample_pattern` (direction in) - array of coordinates for sample points; valid range is 1 - 11 inclusive\n * `vf` (direction in) - use _vfilter_ if <tt>GX_TRUE</tt>, otherwise use default 1-line filter\n * `vfilter` (direction in) - vertical filter coefficients; valid coefficient range is 0 - 63 inclusive; sum should equal 64\n\n # Returns\n\nnone"]
    pub fn GX_SetCopyFilter(
        aa: u8_,
        sample_pattern: *mut [u8_; 2usize],
        vf: u8_,
        vfilter: *mut u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetDispCopyFrame2Field(u8 mode)\n Determines which lines are read from the Embedded Frame Buffer (EFB) when using GX_CopyDisp().\n\n \n\nSpecifically, it determines whether all lines, only even lines, or only odd lines are read.\n\n > **Note:** The opposite function, which determines whether all lines, only even lines or only odd lines are <i>written</i> to the EFB, is GX_SetFieldMask().<br><br>\n\n > **Note:** Only applies to display copies, GX_CopyTex() always uses the <tt>GX_COPY_PROGRESSIVE</tt> mode.\n\n # Arguments\n\n* `mode` (direction in) - copymode to determine which field to copy (or both)\n\n # Returns\n\nnone"]
    pub fn GX_SetDispCopyFrame2Field(mode: u8_);
}
extern "C" {
    #[doc = "void GX_SetCopyClear(GXColor color,u32 zvalue)\n Sets color and Z value to clear the EFB to during copy operations.\n\n \n\nThese values are used during both display copies and texture copies.\n\n # Arguments\n\n* `color` (direction in) - RGBA color (8-bit/component) to use during clear operation.\n * `zvalue` (direction in) - 24-bit Z value to use during clear operation. Use the constant <tt>GX_MAX_Z24</tt> to specify the maximum depth value.\n\n # Returns\n\nnone"]
    pub fn GX_SetCopyClear(color: GXColor, zvalue: u32_);
}
extern "C" {
    #[doc = "void GX_CopyDisp(void *dest,u8 clear)\n Copies the embedded framebuffer (EFB) to the external framebuffer(XFB) in main memory.\n\n > **Note:** The stride of the XFB is set using GX_SetDispCopyDst(). The source image in the EFB is described using GX_SetDispCopySrc().<br><br>\n\n > **Note:** The graphics processor will stall all graphics commands util the copy is complete.<br><br>\n\n > **Note:** If the _clear_ flag is true, the color and Z buffers will be cleared during the copy. They will be cleared to the constant\n values set using GX_SetCopyClear().\n\n # Arguments\n\n* `dest` (direction in) - pointer to the external framebuffer. _dest_ should be 32B aligned.\n * `clear` (direction in) - flag that indicates framebuffer should be cleared if <tt>GX_TRUE</tt>.\n\n # Returns\n\nnone"]
    pub fn GX_CopyDisp(dest: *mut ::libc::c_void, clear: u8_);
}
extern "C" {
    #[doc = "void GX_SetTexCopySrc(u16 left,u16 top,u16 wd,u16 ht)\n Sets the source parameters for the Embedded Frame Buffer (EFB) to texture image copy.\n\n \n\nThe GP will copy textures into the tiled texture format specified in GX_CopyTex(). The GP always copies tiles (32B) so image widths and\n heights that are not a multiple of the tile width will be padded with undefined data in the copied image\n\n # Arguments\n\n* `left` (direction in) - left-most source pixel to copy, multiple of two\n * `top` (direction in) - top-most source line to copy, multiple of two\n * `wd` (direction in) - width to copy in pixels, multiple of two\n * `ht` (direction in) - height to copy in pixels, multiple of two\n\n # Returns\n\nnone"]
    pub fn GX_SetTexCopySrc(left: u16_, top: u16_, wd: u16_, ht: u16_);
}
extern "C" {
    #[doc = "void GX_SetTexCopyDst(u16 wd,u16 ht,u32 fmt,u8 mipmap)\n This function sets the width and height of the destination texture buffer in texels.\n\n \n\nThis function sets the width (_wd)_ and height (_ht)_ of the destination texture buffer in texels. The application may render an image into\n the EFB and then copy it into a texture buffer in main memory. _wd_ specifies the number of texels between adjacent lines in the texture buffer and can\n be different than the width of the source image. This function also sets the texture format (_fmt)_ to be created during the copy operation. An\n optional box filter can be enabled using _mipmap._ This flag will scale the source image by 1/2.\n\n Normally, the width of the EFB and destination _wd_ are the same. When rendering smaller images that get copied and composited into a larger texture\n buffer, however, the EFB width and texture buffer _wd_ are not necessarily the same.\n\n The Z buffer can be copied to a Z texture format by setting _fmt_ to <tt>GX_TF_Z24X8</tt>. This operation is only valid when the EFB format is\n <tt>GX_PF_RGB8_Z24</tt> or <tt>GX_PF_RGBA6_Z24</tt>.\n\n The alpha channel can be copied from an EFB with format <tt>GX_PF_RGBA6_Z24</tt> by setting _fmt_ to <tt>GX_TF_A8</tt>.\n\n # Arguments\n\n* `wd` (direction in) - distance between successive lines in the texture buffer, in texels; must be a multiple of the texture tile width, which depends on _fmt._\n * `ht` (direction in) - height of the texture buffer\n * `fmt` (direction in) - texfmt\n * `mipmap` (direction in) - flag that indicates framebuffer should be cleared if <tt>GX_TRUE</tt>.\n\n # Returns\n\nnone"]
    pub fn GX_SetTexCopyDst(wd: u16_, ht: u16_, fmt: u32_, mipmap: u8_);
}
extern "C" {
    #[doc = "void GX_CopyTex(void *dest,u8 clear)\n Copies the embedded framebuffer (EFB) to the texture image buffer _dest_ in main memory.\n\n \n\nThis is useful when creating textures using the Graphics Processor (GP). If the _clear_ flag is set to <tt>GX_TRUE</tt>, the EFB will be cleared\n to the current color(see GX_SetCopyClear()) during the copy operation.\n\n # Arguments\n\n* `dest` (direction in) - pointer to the image buffer in main memory. _dest_ should be 32B aligned.\n * `clear` (direction in) - flag that indicates framebuffer should be cleared if <tt>GX_TRUE</tt>.\n\n # Returns\n\nnone"]
    pub fn GX_CopyTex(dest: *mut ::libc::c_void, clear: u8_);
}
extern "C" {
    #[doc = "void GX_PixModeSync(void)\n Causes the GPU to wait for the pipe to flush.\n\n \n\nThis function inserts a synchronization command into the graphics FIFO. When the GPU sees this command it will allow the rest of the pipe to\n flush before continuing. This command is useful in certain situation such as after using GX_CopyTex() and before a primitive that uses the copied texture.\n\n > **Note:** The command is actually implemented by writing the control register that determines the format of the embedded frame buffer (EFB). As a result, care\n should be used if this command is placed within a display list.\n\n # Returns\n\nnone"]
    pub fn GX_PixModeSync();
}
extern "C" {
    #[doc = "void GX_ClearBoundingBox(void)\n Clears the bounding box values before a new image is drawn.\n\n \n\nThe graphics hardware keeps track of a bounding box of pixel coordinates that are drawn in the Embedded Frame Buffer (EFB).\n\n # Returns\n\nnone"]
    pub fn GX_ClearBoundingBox();
}
extern "C" {
    #[doc = "GX_PokeAlphaMode(u8 func,u8 threshold)\n Sets a threshold which is compared to the alpha of pixels written to the Embedded Frame Buffer (EFB) using the GX_Poke*() functions.\n\n \n\nThe compare function order is:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src_alpha _func_ _threshold_\n\n > **Note:** The alpha compare function can be used to conditionally write pixels to the EFB using the source alpha channel as a template. If the compare function is\n true, the source color will be written to the EFB based on the result of the Z compare (see GX_PokeZMode()). If the alpha compare function is false, the source\n color is not written to the EFB.<br><br>\n\n > **Note:** The alpha compare test happens before the Z compare and before blending (see GX_PokeBlendMode()).\n\n # Arguments\n\n* `func` (direction in) - compare to use\n * `threshold` (direction in) - to which the source alpha will be compared to\n\n # Returns\n\nnone"]
    pub fn GX_PokeAlphaMode(func: u8_, threshold: u8_);
}
extern "C" {
    #[doc = "void GX_PokeAlphaUpdate(u8 update_enable)\n Enables or disables alpha-buffer updates for GX_Poke*() functions.\n\n \n\nThe normal rendering state (set by GX_SetAlphaUpdate()) is not affected.\n\n # Arguments\n\n* `update_enable` (direction in) - enables alpha-buffer updates with <tt>GX_TRUE</tt>, otherwise does not\n\n # Returns\n\nnone"]
    pub fn GX_PokeAlphaUpdate(update_enable: u8_);
}
extern "C" {
    #[doc = "void GX_PokeColorUpdate(u8 update_enable)\n Enables or disables color-buffer updates when writing the Embedded Frame Buffer (EFB) using the GX_Poke*() functions.\n\n # Arguments\n\n* `update_enable` (direction in) - enables color-buffer updates with <tt>GX_TRUE</tt>, otherwise does not\n\n # Returns\n\nnone"]
    pub fn GX_PokeColorUpdate(update_enable: u8_);
}
extern "C" {
    #[doc = "void GX_PokeDither(u8 dither)\n Enables dithering when writing the Embedded Frame Buffer (EFB) using GX_Poke*() functions.\n\n > **Note:** The _dither_ enable is only valid when the pixel format (see GX_SetPixelFmt()) is either <tt>GX_PF_RGBA6_Z24</tt> or <tt>GX_PF_RGB565_Z16</tt>.<br><br>\n\n > **Note:** A 4x4 Bayer matrix is used for dithering.\n\n # Arguments\n\n* `dither` (direction in) - if set to <tt>GX_TRUE</tt> and pixel format is one of the above, dithering is enabled; otherwise disabled\n\n # Returns\n\nnone"]
    pub fn GX_PokeDither(dither: u8_);
}
extern "C" {
    #[doc = "void GX_PokeBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op)\n Determines how the source image, is blended with the current Embedded Frame Buffer (EFB).\n\n \n\nWhen type is set to <tt>GX_BM_NONE</tt>, no color data is written to the EFB. When type is set to <tt>GX_BM_BLEND</tt>, the source and EFB pixels\n are blended using the following equation:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>src_pix_clr</i> * _src_fact_ + <i>dst_pix_clr</i> * _dst_fact<br><br>_\n\n When type is set to <tt>GX_BM_SUBTRACT</tt>, the destination pixel is computed as follows:<br><br>\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>dst_pix_clr</i> = <i>dst_pix_clr</i> - <i>src_pix_clr [clamped to zero]</i><br><br>\n\n Note that _src_fact_ and _dst_fact_ are not part of the equation.\n\n > **Note:** _dst_fact_ can be used only when the frame buffer has <tt>GX_PF_RGBA6_Z24</tt> as the pixel format (see GX_SetPixelFmt()).<br><br>\n\n > **Note:** When type is set to <tt>GX_BM_LOGIC</tt>, the source and EFB pixels are blended using logical bitwise operations.<br><br>\n\n > **Note:** This function does not effect the normal rendering state; see GX_SetBlendMode().\n\n # Arguments\n\n* `type` (direction in) - blendmode\n * `src_fact` (direction in) - source blendfactor; the pixel color produced by the graphics processor is multiplied by this factor\n * `dst_fact` (direction in) - destination blendfactor; the current frame buffer pixel color is multiplied by this factor\n * `op` (direction in) - logicop to use"]
    pub fn GX_PokeBlendMode(type_: u8_, src_fact: u8_, dst_fact: u8_, op: u8_);
}
extern "C" {
    #[doc = "void GX_PokeAlphaRead(u8 mode)\n Determines what value of alpha will be read from the Embedded Frame Buffer (EFB).\n\n \n\nThe mode only applies to GX_Peek*() functions.\n\n > **Note:** This feature works no matter what pixel type (see GX_SetPixelFmt()) you are using. If you are using the EFB with alpha plane, it is\n recommended that you use <tt>GX_READ_NONE</tt> so that you can read correct alpha value from the EFB. If you are using the EFB with no alpha, you should\n set either of <tt>GX_READ_00</tt> or <tt>GX_READ_FF</tt> in order to get a certain value.<br><br>\n\n # Arguments\n\n* `mode` (direction in) - alphareadmode that determines value of alpha read from a frame buffer with no alpha channel.\n\n # Returns\n\nnone"]
    pub fn GX_PokeAlphaRead(mode: u8_);
}
extern "C" {
    #[doc = "void GX_PokeDstAlpha(u8 enable,u8 a)\n Sets a constant alpha value for writing to the Embedded Frame Buffer (EFB).\n\n \n\nThe EFB pixel type must have an alpha channel for this function to be effective (see GX_SetPixelFmt()). The blending operations (see\n GX_PokeBlendMode()) still use source alpha but when writing the pixel color, the constant _a_ will replace the pixel alpha in the EFB.\n\n # Arguments\n\n* `enable` (direction in) - if set to <tt>GX_ENABLE</tt> and pixel format supports dest alpha, _a_ will be written to the framebuffer\n * `a` (direction in) - constant alpha value\n\n # Returns\n\nnone"]
    pub fn GX_PokeDstAlpha(enable: u8_, a: u8_);
}
extern "C" {
    #[doc = "void GX_PokeARGB(u16 x,u16 y,GXColor color)\n Allows the CPU to write _color_ directly to the Embedded Frame Buffer (EFB) at position _x,__y._\n\n \n\nThe alpha value in _color_ can be compared with the current alpha threshold (see GX_PokeAlphaMode()). The color will be blended\n into the EFB using the blend mode set by GX_PokeBlendMode().\n\n > **Note:** For an antialiased frame buffer, all 3 subsamples of a pixel are affected by the poke.\n\n # Arguments\n\n* `x` (direction in) - coordinate, in pixels; must be 0 - 639 inclusive\n * `y` (direction in) - coordinate, in lines; must be 0 - 527 inclusive\n * `color` (direction in) - color to write at the location\n\n # Returns\n\nnone"]
    pub fn GX_PokeARGB(x: u16_, y: u16_, color: GXColor);
}
extern "C" {
    #[doc = "void GX_PeekARGB(u16 x,u16 y,GXColor *color)\n Allows the CPU to read a color value directly from the Embedded Frame Buffer (EFB) at position _x,__y._\n\n > **Note:** For an antialiased frame buffer, only subsample 0 of a pixel is read.\n\n # Arguments\n\n* `x` (direction in) - coordinate, in pixels; must be 0 - 639 inclusive\n * `y` (direction in) - coordinate, in lines; must be 0 - 527 inclusive\n * `color` (direction out) - struct to store color in\n\n # Returns\n\nnone"]
    pub fn GX_PeekARGB(x: u16_, y: u16_, color: *mut GXColor);
}
extern "C" {
    #[doc = "void GX_PokeZ(u16 x,u16 y,u32 z)\n Allows the CPU to write a z value directly to the Embedded Frame Buffer (EFB) at position _x,__y._\n\n \n\nThe _z_ value can be compared with the current contents of the EFB. The Z compare fuction is set using GX_PokeZMode().\n\n > **Note:** The _z_ value should be in the range of 0x00000000 <= _z_ < 0x00FFFFFF in the case of non-antialiased frame buffer. For an antialiased\n frame buffer, the _z_ value should be in the compressed 16-bit format (0x00000000 <= _z_ <= 0x0000FFFF), and the poke will affect all 3\n subsamples of a pixel.\n\n # Arguments\n\n* `x` (direction in) - coordinate, in pixels; must be 0 - 639 inclusive\n * `y` (direction in) - coordinate, in lines; must be 0 - 527 inclusive\n * `z` (direction in) - value to write at position _x,__y_ in the EFB\n\n # Returns\n\nnone"]
    pub fn GX_PokeZ(x: u16_, y: u16_, z: u32_);
}
extern "C" {
    #[doc = "void GX_PeekZ(u16 x,u16 y,u32 *z)\n Allows the CPU to read a z value directly from the Embedded Frame Buffer (EFB) at position x,y.\n\n \n\nThe z value is raw integer value from the Z buffer.\n\n > **Note:** The value range is 24-bit when reading from non-antialiased frame buffer. When reading from an antialiased frame buffer, subsample\n 0 is read and returned. The value will be compressed 16-bit form in this case.\n\n # Arguments\n\n* `x` (direction in) - coordinate, in pixels; must be 0 - 639 inclusive\n * `y` (direction in) - coordinate, in lines; must be 0 - 527 inclusive\n * `z` (direction out) - pointer to a returned Z value\n\n # Returns\n\nnone"]
    pub fn GX_PeekZ(x: u16_, y: u16_, z: *mut u32_);
}
extern "C" {
    #[doc = "void GX_PokeZMode(u8 comp_enable,u8 func,u8 update_enable)\n Sets the Z-buffer compare mode when writing the Embedded Frame Buffer (EFB).\n\n \n\nThe result of the Z compare is used to conditionally write color values to the EFB. The Z value will be updated according to the\n result of the compare if Z update is enabled.\n\n When _comp_enable_ is set to <tt>GX_DISABLE</tt>, poke Z buffering is disabled and the Z buffer is not updated. The _func_ parameter determines the\n comparison that is performed. In the comparison function, the poked Z value is on the left while the Z value from the Z buffer is on the\n right. If the result of the comparison is false, the poked Z value is discarded. The parameter _update_enable_ determines whether or not the\n Z buffer is updated with the new Z value after a comparison is performed.\n\n > **Note:** The normal rendering Z mode (set by GX_SetZMode()) is not affected by this function.<br><br>\n\n > **Note:** Even if update_enable is <tt>GX_FALSE</tt>, compares may still be enabled.\n\n # Arguments\n\n* `comp_enable` (direction in) - enables comparisons with source and destination Z values if <tt>GX_TRUE</tt>\n * `func` (direction in) - compare function to use\n * `update_enable` (direction in) - enables Z-buffer updates when <tt>GX_TRUE</tt>\n\n # Returns\n\nnone"]
    pub fn GX_PokeZMode(comp_enable: u8_, func: u8_, update_enable: u8_);
}
extern "C" {
    #[doc = "u32 GX_GetTexObjFmt(const GXTexObj *obj)\n Returns the texture format described by texture object _obj._\n\n > **Note:** Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture format.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\ntexture format of the given texture object"]
    pub fn GX_GetTexObjFmt(obj: *const GXTexObj) -> u32_;
}
extern "C" {
    #[doc = "u32 GX_GetTexObjMipMap(const GXTexObj *obj)\n Returns the texture mipmap enable described by texture object _obj._\n\n > **Note:** Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture mipmap enable.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\nmipmap enable flag"]
    pub fn GX_GetTexObjMipMap(obj: *const GXTexObj) -> u32_;
}
extern "C" {
    #[doc = "void* GX_GetTexObjUserData(const GXTexObj *obj)\n Used to get a pointer to user data from the GXTexObj structure.\n\n \n\nYou can use this function to retrieve private data structures from the texture object. This pointer is set using GX_InitTexObjUserData().\n\n # Arguments\n\n* `obj` (direction in) - ptr to object to read data from\n\n # Returns\n\nPointer to user data."]
    pub fn GX_GetTexObjUserData(obj: *const GXTexObj) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "void* GX_GetTexObjData(const GXTexObj *obj)\n Used to get a pointer to texture data from the GXTexObj structure.\n\n > **Note:** The returned pointer is a physical address.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\nPhysical pointer to texture data."]
    pub fn GX_GetTexObjData(obj: *const GXTexObj) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "u8 GX_GetTexObjWrapS(const GXTexObj* obj)\n Returns the texture wrap s mode described by texture object _obj._\n\n > **Note:** Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture wrap s mode.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\nwrap s mode"]
    pub fn GX_GetTexObjWrapS(obj: *const GXTexObj) -> u8_;
}
extern "C" {
    #[doc = "u8 GX_GetTexObjWrapT(const GXTexObj* obj)\n Returns the texture wrap t mode described by texture object _obj._\n\n > **Note:** Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture wrap t mode.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\nwrap t mode"]
    pub fn GX_GetTexObjWrapT(obj: *const GXTexObj) -> u8_;
}
extern "C" {
    #[doc = "u16 GX_GetTexObjHeight(const GXTexObj* obj)\n Returns the texture height described by texture object _obj._\n\n > **Note:** Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture height.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\ntexture height"]
    pub fn GX_GetTexObjHeight(obj: *const GXTexObj) -> u16_;
}
extern "C" {
    #[doc = "u16 GX_GetTexObjWidth(const GXTexObj* obj)\n Returns the texture width described by texture object _obj._\n\n > **Note:** Use GX_InitTexObj() or GX_InitTexObjCI() to initialize the texture width.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n\n # Returns\n\ntexture width"]
    pub fn GX_GetTexObjWidth(obj: *const GXTexObj) -> u16_;
}
extern "C" {
    #[doc = "void GX_GetTexObjLOD(const GXTexObj* obj, f32 *minlod, f32 *maxlod)\n Returns the min and max LOD values for the texture object _obj._\n\n > **Note:** Use GX_InitTexObjLOD(), GX_InitTexObjMinLOD() or GX_InitTexObjMaxLOD()\n to initialize the texture minimum and maximum LOD.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `minlod` (direction out) - minimum LOD value from 0.0 - 10.0 inclusive\n * `maxlod` (direction out) - maximum LOD value from 0.0 - 10.0 inclusive\n\n # Returns\n\nnone"]
    pub fn GX_GetTexObjLOD(obj: *const GXTexObj, minlod: *mut f32_, maxlod: *mut f32_);
}
extern "C" {
    #[doc = "void GX_GetTexObjFilterMode(const GXTexObj* obj, u8 *minfilt, u8 *magfilt)\n Returns the filter mode for the texture object _obj._\n\n > **Note:** Use GX_InitTexObjLOD() or GX_InitTexObjFilterMode() to initialize the\n texture filter mode.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `minfilt` (direction out) - minification filter mode; will be one of texfilter\n * `maxfilt` (direction out) - magnification filter mode; will be _GX_NEAR_ or _GX_LINEAR_\n\n # Returns\n\nnone"]
    pub fn GX_GetTexObjFilterMode(obj: *const GXTexObj, minfilt: *mut u8_, magfilt: *mut u8_);
}
extern "C" {
    #[doc = "void GX_GetTexObjAll(const GXTexObj* obj, void** image_ptr, u16* width, u16* height, u8* format, u8* wrap_s, u8* wrap_t, u8* mipmap);\n Returns the parameters described by a texture object. Texture objects are used to describe all the parameters associated with a texture, including size, format, wrap modes, filter modes, etc. Texture objects are initialized using either GX_InitTexObj() or, for color index format textures, GX_InitTexObjCI().\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `image_ptr` (direction out) - Returns a physical pointer to the image data for a texture.\n * `width` (direction out) - Returns the width of the texture or LOD 0 for mipmaps\n * `height` (direction out) - Returns the height of the texture or LOD 0 for mipmaps\n * `format` (direction out) - Returns the texel format\n * `mipmap` (direction out) - Returns the mipmap enable flag.\n\n # Returns\n\nnone"]
    pub fn GX_GetTexObjAll(
        obj: *const GXTexObj,
        image_ptr: *mut *mut ::libc::c_void,
        width: *mut u16_,
        height: *mut u16_,
        format: *mut u8_,
        wrap_s: *mut u8_,
        wrap_t: *mut u8_,
        mipmap: *mut u8_,
    );
}
extern "C" {
    #[doc = "u32 GX_GetTexBufferSize(u16 wd,u16 ht,u32 fmt,u8 mipmap,u8 maxlod)\n Returns the amount of memory in bytes needed to store a texture of the given size and _fmt._\n\n \n\nIf the _mipmap_ flag is <tt>GX_TRUE</tt>, then the size of buffer needed for the mipmap pyramid up to _maxlod_ will be returned.\n _maxlod_ will be clamped to the number of LODs possible given the map _wd_ and _ht._ For mipmaps, _wd_ and _ht_ must be a power of two.\n\n > **Note:** This function takes into account the tiling and padding requirements of the GameCube's native texture format. The resulting size can be used\n along with memalign() to allocate texture buffers (see GX_CopyTex()).\n\n # Arguments\n\n* `wd` (direction in) - width of the texture in texels\n * `ht` (direction in) - height of the texture in texels\n * `fmt` (direction in) - format of the texture; use GX_TexFmt() or GX_CITexFmt() to get it\n * `mipmap` (direction in) - flag indicating whether or not the texture is a mipmap\n * `maxlod` (direction in) - if _mipmap_ is _GX_TRUE,_ texture size will include mipmap pyramid up to this value\n\n # Returns\n\nnumber of bytes needed for the texture, including tile padding"]
    pub fn GX_GetTexBufferSize(wd: u16_, ht: u16_, fmt: u32_, mipmap: u8_, maxlod: u8_) -> u32_;
}
extern "C" {
    #[doc = "void GX_InvalidateTexAll(void)\n Invalidates the current caches of the Texture Memory (TMEM).\n\n \n\nIt takes about 512 GP clocks to invalidate all the texture caches.\n\n > **Note:** Preloaded textures (see GX_PreloadEntireTexture()) are not affected.\n\n # Returns\n\nnone"]
    pub fn GX_InvalidateTexAll();
}
extern "C" {
    #[doc = "void GX_InvalidateTexRegion(GXTexRegion *region)\n Invalidates the texture cache in Texture Memory (TMEM) described by _region._\n\n \n\nThis function should be called when the CPU is used to modify a texture in main memory, or a new texture is loaded into main memory that\n is possibly cached in the texture region.\n\n > **Note:** In reality, this function invalidates the cache tags, forcing the texture cache to load new data. Preloaded textures (see\n GX_PreloadEntireTexture()) do not use the tags.<br><br>\n\n > **Note:** The texture hardware can invalidate 4 tags each GP clock. Each tag represents a superline or 512B of TMEM. Therefore, it takes 16\n GP clocks to invalidate a 32KB texture region.\n\n # Arguments\n\n* `region` (direction in) - ptr to GXTexRegion object\n\n # Returns\n\nnone"]
    pub fn GX_InvalidateTexRegion(region: *mut GXTexRegion);
}
extern "C" {
    #[doc = "void GX_InitTexCacheRegion(GXTexRegion *region,u8 is32bmipmap,u32 tmem_even,u8 size_even,u32 tmem_odd,u8 size_odd)\n Initializes a texture memory (TMEM) region object for cache.\n\n \n\nThe region is allocated by the application and can be used as a cache. An application can create many region objects and some of them can\n overlap; however, no two overlapping regions can be active at the same time.\n\n The possible sizes of a TMEM cache region are 32K, 128K or 512K.\n\n > **Note:** For pre-loaded textures, the region must be defined by using GX_InitTexPreloadRegion().<br><br>\n\n > **Note:** GX_Init() creates default texture regions, so it is not necessary for the application to use this function unless a different Texture Memory\n configuration is desired. In that case, the application should also define a region allocator using GX_SetTexRegionCallback().<br><br>\n\n > **Note:** The function GX_InvalidateTexRegion() can be used to force the texture in main memory associated with this region to be reloaded. This will be\n necessary whenever the texture data in main memory changes. You may invalidate all cached regions at once using GX_InvalidateTexAll().\n\n # Arguments\n\n* `region` (direction in) - ptr to a GXTexRegion struct\n * `is32bmipmap` (direction in) - should be set to <tt>GX_TRUE</tt> to interpret parameters according to the 32b mipmap meaning.\n * `tmem_even` (direction in) - base ptr in TMEM for even LODs; must be multiple of 2KB\n * `size_even` (direction in) - even texcachesize other than <tt>GX_TEXCACHE_NONE</tt>\n * `tmem_odd` (direction in) - base ptr in TMEM for odd LODs; must be multiple of 2KB\n * `size_odd` (direction in) - odd texcachesize other than <tt>GX_TEXCACHE_NONE</tt>\n\n # Returns\n\nnone"]
    pub fn GX_InitTexCacheRegion(
        region: *mut GXTexRegion,
        is32bmipmap: u8_,
        tmem_even: u32_,
        size_even: u8_,
        tmem_odd: u32_,
        size_odd: u8_,
    );
}
extern "C" {
    #[doc = "void GX_InitTexPreloadRegion(GXTexRegion *region,u32 tmem_even,u32 size_even,u32 tmem_odd,u32 size_odd)\n Initializes a Texture Memory (TMEM) region object for preloading.\n\n \n\nThe region is allocated in TMEM by the application and can be used only as a pre-loaded buffer. Cache regions must be allocated\n by using GX_InitTexCacheRegion(). For pre-loaded textures, the size of the region must match the size of the texture. An application can\n create many region objects and some of them can overlap; however, no two overlapping regions can be active at the same time.\n\n > **Note:** The maximum size of a region is 512K.\n\n GX_Init() creates no region for preloading, so the application should allocate appropriate regions if preloading is necessary. It\n is also required to create cache regions and its allocator by using GX_InitTexCacheRegion() and GX_SetTexRegionCallback(), otherwise new\n cache regions may overwrite the preloaded areas. (Alternatively, if you do not use any color-index textures, you may preload textures into\n the portion of texture memory normally allocated to color-index usage by the default allocator.)\n\n # Arguments\n\n* `region` (direction in) - ptr to a GXTexRegion struct\n * `tmem_even` (direction in) - base ptr in TMEM for even LODs; must be 32B aligned\n * `size_even` (direction in) - size of the even cache, in bytes; should be multiple of 32B\n * `tmem_odd` (direction in) - base ptr in TMEM for odd LODs; must be 32B aligned\n * `size_odd` (direction in) - size of the odd cache, in bytes; should be multiple of 32B\n\n # Returns\n\nnone"]
    pub fn GX_InitTexPreloadRegion(
        region: *mut GXTexRegion,
        tmem_even: u32_,
        size_even: u32_,
        tmem_odd: u32_,
        size_odd: u32_,
    );
}
extern "C" {
    #[doc = "void GX_InitTexObj(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap)\n Used to initialize or change a texture object for non-color index textures.\n\n \n\nTexture objects are used to describe all the parameters associated with a texture, including size, format, wrap modes, filter modes,\n etc. It is the application's responsibility to provide memory for a texture object. Once initialized, a texture object can be associated with\n one of eight active texture IDs using GX_LoadTexObj().\n\n > **Note:** To initialize a texture object for color index format textures, use GX_InitTexObjCI().<br><br>\n\n > **Note:** If the mipmap flag is <tt>GX_TRUE</tt>, then the texture is a mipmap and the texture will be trilerped. If the mipmap flag is <tt>GX_FALSE</tt>, the texture\n is not a mipmap and the texture will be bilerped. To override the filter modes and other mipmap controls, see GX_InitTexObjLOD().\n\n # Arguments\n\n* `obj` (direction out) - ptr to a texture object\n * `img_ptr` (direction in) - ptr to the image data for a texture, aligned to 32B\n * `wd` (direction in) - width of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n * `ht` (direction in) - height of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n * `fmt` (direction in) - texfmt\n * `wrap_s` (direction in) - texture coordinate wrapping strategy in the S direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n * `wrap_t` (direction in) - texture coordinate wrapping strategy in the T direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n * `mipmap` (direction in) - trilinear filtering will be used if <tt>GX_TRUE</tt>, otherwise bilinear is used\n\n # Returns\n\nnone"]
    pub fn GX_InitTexObj(
        obj: *mut GXTexObj,
        img_ptr: *mut ::libc::c_void,
        wd: u16_,
        ht: u16_,
        fmt: u8_,
        wrap_s: u8_,
        wrap_t: u8_,
        mipmap: u8_,
    );
}
extern "C" {
    #[doc = "void GX_InitTexObjCI(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap,u32 tlut_name)\n Used to initialize or change a texture object when the texture is color index format.\n\n \n\nTexture objects are used to describe all the parameters associated with a texture, including size, format, wrap modes, filter modes,\n etc. It is the application's responsibility to provide memory for a texture object. Once initialized, a texture object can be associated with\n one of eight active texture IDs using GX_LoadTexObj().\n\n > **Note:** If the _mipmap_ flag is <tt>GX_TRUE</tt>, then the texture is a mipmap and the texture will be filtered using the <tt>GX_LIN_MIP_NEAR</tt> filter mode\n (color index mipmaps cannot use the <tt>GX_LIN_MIP_LIN</tt> or <tt>GX_NEAR_MIP_LIN</tt> mode). If the _mipmap_ flag is <tt>GX_FALSE</tt>, the texture is not a mipmap\n and the texture will be bilerped. To override the filter modes and other mipmap controls, use GX_InitTexObjLOD(). Mipmap textures should\n set the width and height to a power of two, but mipmaps do not need to be square.<br><br>\n\n > **Note:** Non-mipmap (planar) textures do not have to be a power of two. However, to use the <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt> modes for _wrap_s_ and _wrap_t_\n the width and height, respectively, must be a power of two.<br><br>\n\n > **Note:** The _tlut_name_ is used to indicate which texture lookup table (TLUT) to use for the index to color conversion. To load the TLUT into\n texture memory, use GX_LoadTlut().\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `img_ptr` (direction in) - ptr to the image data for a texture, aligned to 32B\n * `wd` (direction in) - width of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n * `ht` (direction in) - height of the texture, or LOD level 0 for mipmaps; max value is 1024; mipmaps must be a power of two\n * `fmt` (direction in) - texfmt\n * `wrap_s` (direction in) - texture coordinate wrapping strategy in the S direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n * `wrap_t` (direction in) - texture coordinate wrapping strategy in the T direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n * `mipmap` (direction in) - if <tt>GX_TRUE</tt>, it is a mipmap texture, else it is a planar texture\n * `tlut_name` (direction in) - TLUT name to use for this texture; default texture configuration recognizes tlutname\n\n # Returns\n\nnone"]
    pub fn GX_InitTexObjCI(
        obj: *mut GXTexObj,
        img_ptr: *mut ::libc::c_void,
        wd: u16_,
        ht: u16_,
        fmt: u8_,
        wrap_s: u8_,
        wrap_t: u8_,
        mipmap: u8_,
        tlut_name: u32_,
    );
}
extern "C" {
    #[doc = "void GX_InitTexObjTlut(GXTexObj *obj,u32 tlut_name)\n Allows one to modify the TLUT that is associated with an existing texture object.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `tlut_name` (direction in) - TLUT name to use for this texture; default texture configuration recognizes tlutname\n\n # Returns\n\nnone"]
    pub fn GX_InitTexObjTlut(obj: *mut GXTexObj, tlut_name: u32_);
}
extern "C" {
    #[doc = "void GX_InitTexObjData(GXTexObj *obj,void *img_ptr)\n Allows one to modify the image data pointer for an existing texture object.\n\n > **Note:** The image format and size for the new data must agree with what they were when the texture object was first initialized using\n GX_InitTexObj() or GX_InitTexObjCI().\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `img_ptr` (direction in) - ptr to the texture data in main memory\n\n # Returns\n\nnone"]
    pub fn GX_InitTexObjData(obj: *mut GXTexObj, img_ptr: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "void GX_InitTexObjWrapMode(GXTexObj *obj,u8 wrap_s,u8 wrap_t)\n Allows one to modify the texture coordinate wrap modes for an existing texture object.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `wrap_s` (direction in) - texture coordinate wrapping strategy in the S direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n * `wrap_t` (direction in) - texture coordinate wrapping strategy in the T direction; use <tt>GX_CLAMP</tt>, <tt>GX_REPEAT</tt> or <tt>GX_MIRROR</tt>\n\n # Returns\n\nnone"]
    pub fn GX_InitTexObjWrapMode(obj: *mut GXTexObj, wrap_s: u8_, wrap_t: u8_);
}
extern "C" {
    #[doc = "void GX_InitTexObjFilterMode(GXTexObj *obj,u8 minfilt,u8 magfilt)\n Sets the filter mode for a texture.\n\n \n\nWhen the ratio of texels for this texture to pixels is not 1:1, the filter type for _minfilt_ or _magfilt_ is used.\n\n # Arguments\n\n* `obj` (direction in) - texture object to set the filters for\n * `minfilt` (direction in) - filter mode to use when the texel/pixel ratio is >= 1.0; needs to be one of texfilter.\n * `magfilt` (direction in) - filter mode to use when the texel/pixel ratio is < 1.0; needs to be _GX_NEAR_ or _GX_LINEAR_"]
    pub fn GX_InitTexObjFilterMode(obj: *mut GXTexObj, minfilt: u8_, magfilt: u8_);
}
extern "C" {
    #[doc = "void GX_InitTexObjMinLOD(GXTexObj *obj,f32 minlod)\n Sets the minimum LOD for a given texture.\n\n # Arguments\n\n* `obj` (direction in) - texture to set the minimum LOD for\n * `minlod` (direction in) - minimum LOD value; the hardware will use MAX(min_lod, lod); range is 0.0 to 10.0."]
    pub fn GX_InitTexObjMinLOD(obj: *mut GXTexObj, minlod: f32_);
}
extern "C" {
    #[doc = "void GX_InitTexObjMaxLOD(GXTexObj *obj,f32 maxlod)\n Sets the maximum LOD for a given texture.\n\n # Arguments\n\n* `obj` (direction in) - texture to set the maximum LOD for\n * `maxlod` (direction in) - maximum LOD value; the hardware will use MIN(max_lod, lod); range is 0.0 to 10.0."]
    pub fn GX_InitTexObjMaxLOD(obj: *mut GXTexObj, maxlod: f32_);
}
extern "C" {
    #[doc = "void GX_InitTexObjLODBias(GXTexObj *obj,f32 lodbias)\n Sets the LOD bias for a given texture.\n\n \n\nThe LOD computed by the graphics hardware can be biased using this function. The _lodbias_ is added to the computed lod and the\n result is clamped between the values given to GX_InitTexObjMinLOD() and GX_InitTexObjMaxLOD(). If _GX_ENABLE_ is given to\n GX_InitTexObjBiasClamp(), the effect of _lodbias_ will diminish as the polygon becomes more perpendicular to the view direction.\n\n # Arguments\n\n* `obj` (direction in) - texture to set the LOD bias for\n * `lodbias` (direction in) - bias to add to computed LOD value"]
    pub fn GX_InitTexObjLODBias(obj: *mut GXTexObj, lodbias: f32_);
}
extern "C" {
    #[doc = "void GX_InitTexObjBiasClamp(GXTexObj *obj,u8 biasclamp)\n Enables bias clamping for texture LOD.\n\n \n\nIf _biasclamp_ is _GX_ENABLE,_ the sum of LOD and _lodbias_ (given in GX_InitTexObjLODBias()) is clamped so that it is never\n less than the minimum extent of the pixel projected in texture space. This prevents over-biasing the LOD when the polygon is perpendicular\n to the view direction.\n\n # Arguments\n\n* `obj` (direction in) - texture to set the bias clamp value for\n * `biasclamp` (direction in) - whether or not to enable the bias clamp"]
    pub fn GX_InitTexObjBiasClamp(obj: *mut GXTexObj, biasclamp: u8_);
}
extern "C" {
    #[doc = "void GX_InitTexObjEdgeLOD(GXTexObj *obj,u8 edgelod)\n Changes LOD computing mode.\n\n \n\nWhen set to _GX_ENABLE,_ the LOD is computed using adjacent texels; when _GX_DISABLE,_ diagonal texels are used instead. This\n should be set to _GX_ENABLE_ if you use bias clamping (see GX_InitTexObjBiasClamp()) or anisotropic filtering (GX_ANISO_2 or GX_ANISO_4\n for GX_InitTexObjMaxAniso() argument).\n\n # Arguments\n\n* `obj` (direction in) - texture to set the edge LOD for\n * `edgelod` (direction in) - mode to set LOD computation to"]
    pub fn GX_InitTexObjEdgeLOD(obj: *mut GXTexObj, edgelod: u8_);
}
extern "C" {
    #[doc = "void GX_InitTexObjMaxAniso(GXTexObj *obj,u8 maxaniso)\n Sets the maximum anisotropic filter to use for a texture.\n\n \n\nAnisotropic filtering is accomplished by iterating the square filter along the direction of anisotropy to better approximate the\n quadralateral. This type of filtering results in sharper textures at the expense of multiple cycles per quad. The hardware will only use\n multiple cycles when necessary, and the maximum number of cycles is clamped by the _maxaniso_ parameter, so setting _maxaniso_ to\n _GX_ANISO_2_ will use at most 2 filter cycles per texture.\n\n > **Note:** These filter cycles are internal to the texture filter hardware and do not affect the available number of TEV stages. When setting\n _maxaniso_ to _GX_ANISO_2_ or _GX_ANISO_4,_ the _minfilt_ parameter given to GX_InitTexObjFilterMode() should be set to\n _GX_LIN_MIP_LIN._\n\n # Arguments\n\n* `obj` (direction in) - texture to set the max anisotropy value to\n * `maxaniso` (direction in) - the maximum anistropic filter to use; must be one of anisotropy"]
    pub fn GX_InitTexObjMaxAniso(obj: *mut GXTexObj, maxaniso: u8_);
}
extern "C" {
    #[doc = "GX_InitTexObjUserData(GXTexObj *obj,void *userdata)\n Used to set a pointer to user data in the GXTexObj structure.\n\n \n\nYou can use this function to attach private data structures to the texture object. This pointer can be retrieved using GX_GetTexObjUserData().\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `userdata` (direction in) - pointer to your data to attach to this texture"]
    pub fn GX_InitTexObjUserData(obj: *mut GXTexObj, userdata: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "void GX_LoadTexObj(GXTexObj *obj,u8 mapid)\n Loads the state describing a texture into one of eight hardware register sets.\n\n \n\nBefore this happens, the texture object _obj_ should be initialized using GX_InitTexObj() or GX_InitTexObjCI(). The _id_ parameter refers to\n the texture state register set. Once loaded, the texture can be used in any Texture Environment (TEV) stage using GX_SetTevOrder().\n\n > **Note:** This function will call the functions set by GX_SetTexRegionCallback() (and GX_SetTlutRegionCallback() if the texture is color-index\n format) to obtain the texture regions associated with this texture object. These callbacks are set to default functions by GX_Init().\n\n If the texture is a color-index texture, you <b>must</b> load the associated TLUT (using GX_LoadTlut()) before calling GX_LoadTexObj().\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `mapid` (direction in) - texmapid, <tt>GX_TEXMAP0</tt> to <tt>GX_TEXMAP7</tt> only\n\n # Returns\n\nnone"]
    pub fn GX_LoadTexObj(obj: *mut GXTexObj, mapid: u8_);
}
extern "C" {
    #[doc = "void GX_LoadTlut(GXTlutObj *obj,u32 tlut_name)\n Copies a Texture Look-Up Table (TLUT) from main memory to Texture Memory (TMEM).\n\n \n\nThe _tlut_name_ parameter is the name of a pre-allocated area of TMEM. The callback function set by GX_SetTlutRegionCallback() converts\n the _tlut_name_ into a GXTlutRegion pointer. The TLUT is loaded in the TMEM region described by this pointer. The TLUT object _obj_ describes the\n location of the TLUT in main memory, the TLUT format, and the TLUT size. _obj_ should have been previously initialized using GX_InitTlutObj().\n\n > **Note:** GX_Init() sets a default callback to convert _tlut_names_ from tlutname to GXTlutRegion pointers. The default configuration of\n TMEM has 20 TLUTs, 16 each 256 entries by 16 bits, and 4 each 1k entries by 16 bits. This configuration can be overriden by calling\n GX_InitTlutRegion() and GX_InitTexCacheRegion() to allocate TMEM. Then you can define your own region allocation scheme using GX_SetTlutRegionCallback()\n and GX_SetTexRegionCallback().\n\n # Arguments\n\n* `obj` (direction in) - ptr to a TLUT object; application must allocate this\n * `tlut_name` (direction in) - tlutname\n\n # Returns\n\nnone"]
    pub fn GX_LoadTlut(obj: *mut GXTlutObj, tlut_name: u32_);
}
extern "C" {
    #[doc = "void GX_LoadTexObjPreloaded(GXTexObj *obj,GXTexRegion *region,u8 mapid)\n Loads the state describing a preloaded texture into one of eight hardware register sets.\n\n \n\nBefore this happens, the texture object _obj_ should be initialized using GX_InitTexObj() or GX_InitTexObjCI(). The _mapid_ parameter refers to\n the texture state register set. The texture should be loaded beforehand using GX_PreloadEntireTexture(). Once loaded, the texture can be used in any Texture Environment\n (TEV) stage using GX_SetTevOrder().\n\n > **Note:** GX_Init() initially calls GX_SetTevOrder() to make a simple texture pipeline that associates <tt>GX_TEXMAP0</tt> with <tt>GX_TEVSTAGE0</tt>,\n <tt>GX_TEXMAP1</tt> with <tt>GX_TEVSTAGE1</tt>, etc.<br><br>\n\n > **Note:** GX_LoadTexObjPreloaded() will not call the functions set by GX_SetTexRegionCallback() (and GX_SetTlutRegionCallback() if the texture is color\n index format) because the region is set explicitly; however, these callback functions must be aware of all regions that are preloaded. The default\n callbacks set by GX_Init() assume there are no preloaded regions.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `region` (direction in) - ptr to a region object that describes an area of texture memory\n * `mapid` (direction in) - texmapid for reference in a TEV stage\n\n # Returns\n\nnone"]
    pub fn GX_LoadTexObjPreloaded(obj: *mut GXTexObj, region: *mut GXTexRegion, mapid: u8_);
}
extern "C" {
    #[doc = "void GX_PreloadEntireTexture(GXTexObj *obj,GXTexRegion *region)\n Loads a given texture from DRAM into the texture memory.\n\n \n\nAccesses to this texture will bypass the texture cache tag look-up and instead read the texels directly from texture memory. The\n texture region must be the same size as the texture (see GX_InitTexPreloadRegion()).\n\n > **Note:** This function loads the texture into texture memory, but to use it as a source for the Texture Environment (TEV) unit, you must first\n call GX_LoadTexObjPreloaded(). The default configuration (as set by GX_Init()) of texture memory has no preloaded regions, so you must install\n your own region allocator callbacks using GX_SetTexRegionCallback() and GX_SetTlutRegionCallback().\n\n # Arguments\n\n* `obj` (direction in) - ptr to object describing the texture to laod\n * `region` (direction in) - TMEM texture region to load the texture into\n\n # Returns\n\nnone"]
    pub fn GX_PreloadEntireTexture(obj: *mut GXTexObj, region: *mut GXTexRegion);
}
extern "C" {
    #[doc = "void GX_InitTlutObj(GXTlutObj *obj,void *lut,u8 fmt,u16 entries)\n Initializes a Texture Look-Up Table (TLUT) object.\n\n \n\nThe TLUT object describes the location of the TLUT in main memory, its format and the number of entries. The TLUT in main\n memory described by this object can be loaded into a TLUT allocated in the texture memory using the GX_LoadTlut() function.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a TLUT object\n * `lut` (direction in) - ptr to look-up table data; must be 32B aligned\n * `fmt` (direction in) - format of the entries in the TLUt; <tt>GX_TL_IA8</tt>, <tt>GX_TL_RGB565</tt> or <tt>GX_TL_RGB5A3</tt>\n * `entries` (direction in) - number of entries in this table; maximum is 16,384\n\n # Returns\n\nnone"]
    pub fn GX_InitTlutObj(obj: *mut GXTlutObj, lut: *mut ::libc::c_void, fmt: u8_, entries: u16_);
}
extern "C" {
    #[doc = "void GX_InitTlutRegion(GXTlutRegion *region,u32 tmem_addr,u8 tlut_sz)\n Initializes a Texture Look-Up Table (TLUT) region object.\n\n > **Note:** GX_Init() creates default TLUT regions, so the application does not need to call this function unless a new configuration\n of Texture Memory is desired. In that case, the application should also set a new TLUT region allocator using GX_SetTlutRegionCallback().\n\n # Arguments\n\n* `region` (direction in) - obj ptr to a TLUT region struct; application must allocate this\n * `tmem_addr` (direction in) - location of the TLU in TMEM; ptr must be aligned to table size\n * `tlut_sz` (direction in) - size of the table\n\n # Returns\n\nnone"]
    pub fn GX_InitTlutRegion(region: *mut GXTlutRegion, tmem_addr: u32_, tlut_sz: u8_);
}
extern "C" {
    #[doc = "void GX_InitTexObjLOD(GXTexObj *obj,u8 minfilt,u8 magfilt,f32 minlod,f32 maxlod,f32 lodbias,u8 biasclamp,u8 edgelod,u8 maxaniso)\n Sets texture Level Of Detail (LOD) controls explicitly for a texture object.\n\n \n\nIt is the application's responsibility to provide memory for a texture object. When initializing a texture object using GX_InitTexObj()\n or GX_InitTexObjCI(), this information is set to default values based on the mipmap flag. This function allows the programmer to override those\n defaults.\n\n > **Note:** This function should be called after GX_InitTexObj() or GX_InitTexObjCI() for a particular texture object.<br><br>\n\n > **Note:** Setting _biasclamp_ prevents over-biasing the LOD when the polygon is perpendicular to the view direction.<br><br>\n\n > **Note:** _edgelod_ should be set if _biasclamp_ is set or _maxaniso_ is set to <tt>GX_ANISO_2</tt> or <tt>GX_ANISO_4</tt>.<br><br>\n\n > **Note:** Theoretically, there is no performance difference amongst various magnification/minification filter settings except <tt>GX_LIN_MIP_LIN</tt> filter with\n <tt>GX_TF_RGBA8</tt> texture format which takes twice as much as other formats. However, this argument is assuming an environment where texture cache always\n hits. On real environments, you will see some performance differences by changing filter modes (especially minification filter) because cache-hit ratio\n changes according to which filter mode is being used.\n\n # Arguments\n\n* `obj` (direction in) - ptr to a texture object\n * `minfilt` (direction in) - texfilter to use when the texel/pixel ratio is >= 1.0\n * `magfilt` (direction in) - texfilter to use when the texel/pixel ratio is < 1.0; use only <tt>GX_NEAR</tt> or <tt>GX_LINEAR</tt>\n * `minlod` (direction in) - minimum LOD value from 0.0 - 10.0 inclusive\n * `maxlod` (direction in) - maximum LOD value from 0.0 - 10.0 inclusive\n * `lodbias` (direction in) - bias to add to computed LOD value\n * `biasclamp` (direction in) - if <tt>GX_ENABLE</tt>, clamp (LOD+lodbias) so that it is never less than the minimum extent of the pixel projected in texture space\n * `edgelod` (direction in) - if <tt>GX_ENABLE</tt>, compute LOD using adjacent texels\n * `maxaniso` (direction in) - anisotropy to use\n\n # Returns\n\nnone"]
    pub fn GX_InitTexObjLOD(
        obj: *mut GXTexObj,
        minfilt: u8_,
        magfilt: u8_,
        minlod: f32_,
        maxlod: f32_,
        lodbias: f32_,
        biasclamp: u8_,
        edgelod: u8_,
        maxaniso: u8_,
    );
}
extern "C" {
    #[doc = "void GX_SetTexCoordScaleManually(u8 texcoord,u8 enable,u16 ss,u16 ts)\n Overrides the automatic texture coordinate scaling (based upon the associated map size) and lets one manually assign the scale values that\n are used for a given _texcoord._\n\n \n\nSetting the _enable_ parameter to <tt>GX_TRUE</tt> gives this behavior. The given _texcoord_ retains these manual scale values until this function is\n called again. This function is also used to return a given texture coordinate back to normal, automatic scaling (by setting _enable_ to <tt>GX_FALSE</tt>).\n\n > **Note:** A texture coordinate is scaled after being computed by the relevant texgen and before the actual texture lookup Normally, the scale value is set\n according to the texture map that is associated with the texcoord by GX_SetTevOrder(). However, there are certain cases where a different scale value is\n desirable. One such case is when using indirect tiled textures (see GX_SetTevIndTile()).\n\n # Arguments\n\n* `texcoord` (direction in) - the texcoordid being changed\n * `enable` (direction in) - if <tt>GX_TRUE</tt>, scale will be set manually, otherwise set automatically and _ss_ and _ts_ ignored\n * `ss` (direction in) - manual scale value for the S component of the coordinate\n * `ts` (direction in) - manual scale value for the T component of the coordinate\n\n # Returns\n\nnone"]
    pub fn GX_SetTexCoordScaleManually(texcoord: u8_, enable: u8_, ss: u16_, ts: u16_);
}
extern "C" {
    pub fn GX_SetTexCoordCylWrap(texcoord: u8_, s_enable: u8_, t_enable: u8_);
}
extern "C" {
    #[doc = "void GX_SetTexCoordBias(u8 texcoord,u8 s_enable,u8 t_enable)\n Sets the texture coordinate bias of a particular texture.\n\n \n\nRange bias is used with texture coordinates applied in <tt>GX_REPEAT</tt> wrap mode in order to increase the precision of texture coordinates\n that spread out over a large range. The texture coordinate values for a primitive are biased (by an equal integer) towards zero early in the\n graphics pipeline, thus preserving bits for calculation later in the pipe. Since the coordinates are repeated, this bias by an integer should\n have no effect upon the actual appearance of the texture.\n\n > **Note:** Texture coordinate range bias is something that is normally set automatically by the GX API (during GX_Begin()); however, when a texture\n coordinate is being scaled manually (by using GX_SetTexCoordScaleManually()), the associated bias is no longer modified by GX. Thus,\n GX_SetTexCoordBias() allows the bias to be changed while a texture coordinate is being manually controlled.\n\n # Arguments\n\n* `texcoord` (direction in) - texcoordid being changed\n * `s_enable` (direction in) - enable or disable range bias in the S direction with <tt>GX_ENABLE</tt>/<tt>GX_DISABLE</tt>\n * `t_enable` (direction in) - enable or disable range bias in the T direction with <tt>GX_ENABLE</tt>/<tt>GX_DISABLE</tt>\n\n # Returns\n\nnone"]
    pub fn GX_SetTexCoordBias(texcoord: u8_, s_enable: u8_, t_enable: u8_);
}
extern "C" {
    #[doc = "GXTexRegionCallback GX_SetTexRegionCallback(GXTexRegionCallback cb)\n Sets the callback function called by GX_LoadTexObj() to obtain an available texture region.\n\n \n\nGX_Init() calls this function to set a default region-assignment policy. A programmer can override this default region assignment\n by implementing his own callback function. A pointer to the texture object and the texture map ID that are passed\n to GX_LoadTexObj() are provided to the callback function.\n\n # Arguments\n\n* `cb` (direction in) - ptr to a function that takes a pointer to a GXTexObj and a texmapid as a parameter and returns a pointer to a GXTexRegion.\n\n # Returns\n\npointer to the previously set callback"]
    pub fn GX_SetTexRegionCallback(cb: GXTexRegionCallback) -> GXTexRegionCallback;
}
extern "C" {
    #[doc = "GXTlutRegionCallback GX_SetTlutRegionCallback(GXTlutRegionCallback cb)\n Sets the callback function called by GX_LoadTlut() to find the region into which to load the TLUT.\n\n \n\nGX_LoadTexObj() will also call _cb_ to obtain the Texture Look-up Table (TLUT) region when the texture forma\n is color-index.\n\n GX_Init() calls GX_SetTlutRegionCallback() to set a default TLUT index-to-region mapping. The name for the TLUT from the texture\n object is provided as an argument to the callback. The callback should return a pointer to the GXTlutRegion for this TLUT index.\n\n > **Note:** For a given _tlut_name_ (in the GXTlutRegionCallback struct), _cb_ must always return the same GXTlutRegion; this is because\n GX_LoadTlut() will initialize data into the GXTlutRegion which GX_LoadTexObj() will subsequently use.\n\n # Arguments\n\n* `cb` (direction in) - ptr to a function that takes a u32 TLUT name as a parameter and returns a pointer to a GXTlutRegion.\n\n # Returns\n\npointer to the previously set callback"]
    pub fn GX_SetTlutRegionCallback(cb: GXTlutRegionCallback) -> GXTlutRegionCallback;
}
extern "C" {
    #[doc = "void GX_InitLightPos(GXLightObj *lit_obj,f32 x,f32 y,f32 z)\n Sets the position of the light in the light object.\n\n \n\nThe GameCube graphics hardware supports local diffuse lights. The position of the light should be in the same space as a transformed\n vertex position (i.e., view space).\n\n > **Note:** Although the hardware doesn't support parallel directional diffuse lights, it is possible to get \"almost parallel\" lights by setting\n sufficient large values to position parameters (x, y and z) which makes the light position very far away from objects to be lit and all rays\n considered almost parallel.<br><br>\n\n > **Note:** The memory for the light object must be allocated by the application; this function does not load any hardware registers directly. To\n load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to the light object\n * `x` (direction in) - X coordinate to place the light at\n * `y` (direction in) - Y coordinate to place the light at\n * `z` (direction in) - Z coordinate to place the light at\n\n # Returns\n\nnone"]
    pub fn GX_InitLightPos(lit_obj: *mut GXLightObj, x: f32_, y: f32_, z: f32_);
}
extern "C" {
    #[doc = "void GX_InitLightColor(GXLightObj *lit_obj,GXColor col)\n Sets the color of the light in the light object.\n\n > **Note:** The memory for the light object should be allocated by the application; this function does not load any hardware register directly. To\n load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to the light object\n * `col` (direction in) - color to set the light to\n\n # Returns\n\nnone"]
    pub fn GX_InitLightColor(lit_obj: *mut GXLightObj, col: GXColor);
}
extern "C" {
    #[doc = "void GX_InitLightDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz)\n Sets the direction of a light in the light object.\n\n \n\nThis direction is used when the light object is used as spotlight or a specular light (see the <i>attn_fn</i> parameter of GX_SetChanCtrl()).\n\n > **Note:** The coordinate space of the light normal should be consistent with a vertex normal transformed by a normal matrix; i.e., it should be\n transformed to view space.<br><br>\n\n > **Note:** This function does not set the direction of parallel directional diffuse lights. If you want parallel diffuse lights, you may put the light\n position very far from every objects to be lit. (See GX_InitLightPos() and GX_SetChanCtrl())<br><br>\n\n > **Note:** The memory for the light object must be allocated by the application; this function does not load any hardware registers. To load a light\n object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to the light object\n * `nx` (direction in) - X coordinate of the light normal\n * `ny` (direction in) - Y coordinate of the light normal\n * `nz` (direction in) - Z coordinate of the light normal\n\n # Returns\n\nnone"]
    pub fn GX_InitLightDir(lit_obj: *mut GXLightObj, nx: f32_, ny: f32_, nz: f32_);
}
extern "C" {
    #[doc = "void GX_LoadLightObj(const GXLightObj *lit_obj,u8 lit_id)\n Loads a light object into a set of hardware registers associated with a lightid.\n\n \n\nThis function copies the light object data into the graphics FIFO through the CPU write-gather buffer mechanism. This guarantees that\n the light object is coherent with the CPU cache.\n\n > **Note:** The light object must have been initialized first using the necessary GX_InitLight*() functions.<br><br>\n\n > **Note:** Another way to load a light object is with GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to the light object to load\n * `lit_id` (direction in) - lightid to load this light into\n\n # Returns\n\nnone"]
    pub fn GX_LoadLightObj(lit_obj: *const GXLightObj, lit_id: u8_);
}
extern "C" {
    #[doc = "void GX_LoadLightObjIdx(u32 litobjidx,u8 litid)\n Instructs the GP to fetch the light object at _ltobjindx_ from an array.\n\n \n\nThe light object is retrieved from the array to which <tt>GX_SetArray(GX_VA_LIGHTARRAY, ...)</tt> points. Then it loads the object into\n the hardware register associated with lightid.\n\n > **Note:** Data flows directly from the array in DRAM to the GP; therefore, the light object data may not be coherent with the CPU's cache. The\n application is responsible for storing the light object data from the CPU cache (using DCStoreRange()) before calling GX_LoadLightObjIdx().\n\n # Arguments\n\n* `litobjidx` (direction in) - index to a light object\n * `litid` (direction in) - lightid to load this light into\n\n # Returns\n\nnone"]
    pub fn GX_LoadLightObjIdx(litobjidx: u32_, litid: u8_);
}
extern "C" {
    #[doc = "void GX_InitLightDistAttn(GXLightObj *lit_obj,f32 ref_dist,f32 ref_brite,u8 dist_fn)\n Sets coefficients for distance attenuation in a light object.\n\n \n\nThis function uses three easy-to-control parameters instead of <i>k0</i>, <i>k1</i>, and <i>k2</i> in GX_InitLightAttn().\n\n In this function, you can specify the brightness on an assumed reference point. The parameter _ref_distance_ is distance between the light\n and the reference point. The parameter _ref_brite_ specifies ratio of the brightness on the reference point. The value for _ref_dist_ should\n be greater than 0 and that for _ref_brite_ should be within 0 < _ref_brite_ < 1, otherwise distance attenuation feature is turned off. The\n parameter _dist_fn_ defines type of the brightness decreasing curve by distance; <tt>GX_DA_OFF</tt> turns distance attenuation feature off.\n\n > **Note:** If you want more flexible control, it is better to use GX_InitLightAttn() and calculate appropriate coefficients.<br><br>\n\n > **Note:** This function sets parameters only for distance attenuation. Parameters for angular attenuation should be set by using\n GX_InitLightSpot() or GX_InitLightAttnA().<br><br>\n\n > **Note:** This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or\n GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `ref_dist` (direction in) - distance between the light and reference point\n * `ref_brite` (direction in) - brightness of the reference point\n * `dist_fn` (direction in) - distattnfn to use\n\n # Returns\n\nnone"]
    pub fn GX_InitLightDistAttn(
        lit_obj: *mut GXLightObj,
        ref_dist: f32_,
        ref_brite: f32_,
        dist_fn: u8_,
    );
}
extern "C" {
    #[doc = "void GX_InitLightAttn(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2,f32 k0,f32 k1,f32 k2)\n Sts coefficients used in the lighting attenuation calculation in a given light object.\n\n \n\nThe parameters _a0,_ _a1,_ and _a2_ are used for angular (spotlight) attenuation. The coefficients _k0,_ _k1,_ and _k2_ are used for\n distance attenuation. The attenuation function is:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>atten</i> = <i>clamp0</i>(_a2^2_ * <i>aattn</i>^2 + _a1_ * <i>aattn</i> + _a0)_ / (_k2_ * <i>d</i>^2 + _k1_ * <i>d</i> + _k0)_\n\n where <i>aattn</i> is the cosine of the angle between the light direction and the vector from the light position to the vertex, and <i>d</i> is\n the distance from the light position to the vertex when the channel attenuation function is <tt>GX_AF_SPOT</tt>. The light color will be\n multiplied by the <i>atten</i> factor when the attenuation function for the color channel referencing this light is set to <tt>GX_AF_SPOT</tt>\n (see GX_SetChanCtrl()).\n\n > **Note:** The convenience function GX_InitLightSpot() can be used to set the angle attenuation coefficents based on several spot light\n types. The convenience function GX_InitLightDistAttn() can be used to set the distance attenuation coefficients using one of several\n common attenuation functions.<br><br>\n\n > **Note:** The convenience macro GX_InitLightShininess() can be used to set the attenuation parameters for specular lights.<br><br>\n\n > **Note:** When the channel attenuation function is set to <tt>GX_AF_SPEC</tt>, the <i>aattn</i> and <i>d</i> parameter are equal to the dot product of the\n eye-space vertex normal and the half-angle vector set by GX_InitSpecularDir().<br><br>\n\n > **Note:** This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj()\n or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `a0` (direction in) - angle attenuation coefficient\n * `a1` (direction in) - angle attenuation coefficient\n * `a2` (direction in) - angle attenuation coefficient\n * `k0` (direction in) - distance attenuation coefficient\n * `k1` (direction in) - distance attenuation coefficient\n * `k2` (direction in) - distance attenuation coefficient\n\n # Returns\n\nnone"]
    pub fn GX_InitLightAttn(
        lit_obj: *mut GXLightObj,
        a0: f32_,
        a1: f32_,
        a2: f32_,
        k0: f32_,
        k1: f32_,
        k2: f32_,
    );
}
extern "C" {
    #[doc = "void GX_InitLightAttnA(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2)\n Sets coefficients used in the lighting angle attenuation calculation in a given light object.\n\n \n\nThe parameters _a0,_ _a1,_ and _a2_ are used for angular (spotlight) attenuation. The attenuation\n function is:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>atten</i> = <i>clamp0</i>(_a2^2_ * <i>cos(theta)</i>^2 + _a1_ * <i>cos(theta)</i> + _a0)_ / (_k2_ * <i>d</i>^2 + _k1_ * <i>d</i> + _k0)_\n\n where <i>cos(theta)</i> is the cosine of the angle between the light normal and the vector from the light position to the vertex, and <i>d</i> is the distance\n from the light position to the vertex. The _k0-__2_ coefficients can be set using GX_InitLightAttnK(). You can set both the _a0-__2_ and _k0-__2_ coefficients\n can be set using GX_InitLightAttn(). The light color will be multiplied by the <i>atten</i> factor when the attenuation function for the color channel\n referencing this light is set to <tt>GX_AF_SPOT</tt> (see GX_SetChanCtrl()).\n\n > **Note:** The convenience function GX_InitLightSpot() can be used to set the angle attenuation coefficents based on several spot light types. The\n convenience function GX_InitLightDistAttn() can be used to set the distance attenuation coefficients using one of several common attenuation functions.<br><br>\n\n > **Note:** This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `a0` (direction in) - angle attenuation coefficient\n * `a1` (direction in) - angle attenuation coefficient\n * `a2` (direction in) - angle attenuation coefficient\n\n # Returns\n\nnone"]
    pub fn GX_InitLightAttnA(lit_obj: *mut GXLightObj, a0: f32_, a1: f32_, a2: f32_);
}
extern "C" {
    #[doc = "void GX_InitLightAttnK(GXLightObj *lit_obj,f32 k0,f32 k1,f32 k2)\n Sets coefficients used in the lighting distance attenuation calculation in a given light object.\n\n \n\nThe coefficients _k0,_ _k1,_ and _k2_ are used for distance attenuation. The attenuation function is:\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>atten</i> = <i>clamp0</i>(_a2^2_ * <i>cos(theta)</i>^2 + _a1_ * <i>cos(theta)</i> + _a0)_ / (_k2_ * <i>d</i>^2 + _k1_ * <i>d</i> + _k0)_\n\n where <i>cos(theta)</i> is the cosine of the angle between the light normal and the vector from the light position to the vertex, and <i>d</i> is the distance\n from the light position to the vertex. The _a0-__2_ coefficients can be set using GX_InitLightAttnA(). You can set both the _a0-__2_ and _k0-__2_ coefficients\n can be set using GX_InitLightAttn(). The light color will be multiplied by the <i>atten</i> factor when the attenuation function for the color channel\n referencing this light is set to <tt>GX_AF_SPOT</tt> (see GX_SetChanCtrl()).\n\n > **Note:** The convenience function GX_InitLightSpot() can be used to set the angle attenuation coefficents based on several spot light types. The convenience\n function GX_InitLightDistAttn() can be used to set the distance attenuation coefficients using one of several common attenuation functions.<br><br>\n\n > **Note:** Note that this function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or\n GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `k0` (direction in) - distance attenuation coefficient\n * `k1` (direction in) - distance attenuation coefficient\n * `k2` (direction in) - distance attenuation coefficient\n\n # Returns\n\nnone"]
    pub fn GX_InitLightAttnK(lit_obj: *mut GXLightObj, k0: f32_, k1: f32_, k2: f32_);
}
extern "C" {
    #[doc = "void GX_InitSpecularDirHA(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz,f32 hx,f32 hy,f32 hz)\n Sets the direction and half-angle vector of a specular light in the light object.\n\n \n\nThese vectors are used when the light object is used only as specular light. In contrast to GX_InitSpecularDir(),\n which caclulates half-angle vector automatically by assuming the view vector as (0, 0, 1), this function allows users to\n specify half-angle vector directly as input arguments. It is useful to do detailed control for orientation of highlights.\n\n > **Note:** This function does not load any hardware registers. To load a light object into a hardware light, use GX_LoadLightObj()\n or GX_LoadLightObjIdx().<br><br>\n\n > **Note:** Other notes are similar to those described in GX_InitSpecularDir().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `nx` (direction in) - X coordinate of the light normal\n * `ny` (direction in) - Y coordinate of the light normal\n * `nz` (direction in) - Z coordinate of the light normal\n * `hx` (direction in) - X coordinate of half-angle\n * `hy` (direction in) - Y coordinate of half-angle\n * `hz` (direction in) - Z coordinate of half-angle\n\n # Returns\n\nnone"]
    pub fn GX_InitSpecularDirHA(
        lit_obj: *mut GXLightObj,
        nx: f32_,
        ny: f32_,
        nz: f32_,
        hx: f32_,
        hy: f32_,
        hz: f32_,
    );
}
extern "C" {
    #[doc = "void GX_InitSpecularDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz)\n Sets the direction of a specular light in the light object.\n\n \n\nThis direction is used when the light object is used only as specular light. The coordinate space of the light normal\n should be consistent with a vertex normal transformed by a normal matrix; i.e., it should be transformed to view space.\n\n > **Note:** This function should be used if and only if the light object is used as specular light. One specifies a specular light in\n GX_SetChanCtrl() by setting the attenfunc to <tt>GX_AF_SPEC</tt>. Furthermore, one must not use GX_InitLightDir() or\n GX_InitLightPos() to set up a light object which will be used as a specular light since these functions will destroy the information\n set by GX_InitSpecularDir(). In contrast to diffuse lights (including spotlights) that are considered local lights, a specular light\n is a parallel light (i.e. the specular light is infinitely far away such that all the rays of the light are parallel), and thus one\n can only specify directional information.\n\n > **Note:** This function does not load any hardware registers. To load a light object into a hardware light, use GX_LoadLightObj()\n or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `nx` (direction in) - X coordinate of the light normal\n * `ny` (direction in) - Y coordinate of the light normal\n * `nz` (direction in) - Z coordinate of the light normal\n\n # Returns\n\nnone"]
    pub fn GX_InitSpecularDir(lit_obj: *mut GXLightObj, nx: f32_, ny: f32_, nz: f32_);
}
extern "C" {
    #[doc = "void GX_InitLightSpot(GXLightObj *lit_obj,f32 cut_off,u8 spotfn)\n Sets coefficients for angular (spotlight) attenuation in light object.\n\n \n\nThis function uses two easy-to-control parameters instead of _a0,_ _a1,_ and _a2_ on GX_InitLightAttn().\n\n \n\nThe parameter _cut_off_ specifies cutoff angle of the spotlight by degree. The spotlight works while the angle between the ray for a vertex and\n the light direction given by GX_InitLightDir() is smaller than this cutoff angle. The value for _cut_off_ should be within 0 < _cut_off_ <= 90.0, otherwise\n given light object doesn't become a spotlight.\n\n The parameter _spotfn_ defines type of the illumination distribution within cutoff angle. The value <tt>GX_SP_OFF</tt> turns spotlight feature off even if\n color channel setting is using <tt>GX_AF_SPOT</tt> (see GX_SetChanCtrl()).\n\n > **Note:** This function can generate only some kind of simple spotlights. If you want more flexible control, it is better to use GX_InitLightAttn() and calculate\n appropriate coefficients.<br><br>\n\n > **Note:** This function sets parameters only for angular attenuation. Parameters for distance attenuation should be set by using GX_InitLightDistAttn() or\n GX_InitLightAttnK().<br><br>\n\n > **Note:** This function does not load any hardware registers directly. To load a light object into a hardware light, use GX_LoadLightObj() or GX_LoadLightObjIdx().\n\n # Arguments\n\n* `lit_obj` (direction in) - ptr to a light object\n * `cut_off` (direction in) - cutoff angle of the spotlight, in degrees\n * `spotfn` (direction in) - spotfn to use for this light\n\n # Returns\n\nnone"]
    pub fn GX_InitLightSpot(lit_obj: *mut GXLightObj, cut_off: f32_, spotfn: u8_);
}
extern "C" {
    pub fn GX_ReadClksPerVtx() -> u32_;
}
extern "C" {
    pub fn GX_GetOverflowCount() -> u32_;
}
extern "C" {
    pub fn GX_ResetOverflowCount() -> u32_;
}
extern "C" {
    #[doc = "lwp_t GX_GetCurrentGXThread(void)\n Returns the current GX thread.\n\n \n\nThe current GX thread should be the thread that is currently responsible for generating graphics data. By default,\n the GX thread is the thread that invoked GX_Init(); however, it may be changed by calling GX_SetCurrentGXThread().\n\n > **Note:** When graphics data is being generated in immediate mode (that is, the CPU FIFO = GP FIFO, and the GP is actively consuming\n data), the high watermark may be triggered. When this happens, the high watermark interrupt handler will suspend the GX thread, thus\n preventing any further graphics data from being generated. The low watermark interrupt handler will resume the thread.\n\n # Returns\n\nthe current GX thread"]
    pub fn GX_GetCurrentGXThread() -> lwp_t;
}
extern "C" {
    #[doc = "lwp_t GX_SetCurrentGXThread(void)\n Sets the current GX thread to the calling thread.\n\n \n\nThe new thread should be the thread that will be responsible for generating graphics data. By default, the GX thread is\n the thread that invoked GX_Init(); however, it may be changed by calling this function.\n\n > **Note:** It is a programming error to change GX thread while the current GX thread is suspended by a high water mark interrupt. This\n indicates that you have two threads about to generate GX data.<br><br>\n\n > **Note:** When graphics data is being generated in immediate mode (that is, the CPU FIFO = GP FIFO, and the GP is actively consuming\n data), the high watermark may be triggered. When this happens, the high watermark interrupt handler will suspend the GX thread, thus\n preventing any further graphics data from being generated. The low watermark interrupt handler will resume the thread.\n\n # Returns\n\nthe previous GX thread ID"]
    pub fn GX_SetCurrentGXThread() -> lwp_t;
}
extern "C" {
    #[doc = "void GX_RestoreWriteGatherPipe(void)\n Restores the write-gather pipe.\n\n \n\nThe CPU fifo that was attached at the time GX_RedirectWriteGatherPipe() was called will be re-attached. If there is data pending\n in the write gather pipe (e.g. if the amount of data written was not a multiple of 32 bytes), the data will be padded with zeroes and\n flushed out.\n\n This function must be called between successive calls to GX_RedirectWriteGatherPipe().\n\n # Returns\n\nnone"]
    pub fn GX_RestoreWriteGatherPipe();
}
extern "C" {
    #[doc = "void GX_SetGPMetric(u32 perf0,u32 perf1)\n Sets two performance metrics to measure in the GP.\n\n \n\nperf0 and perf1 are set to measure. The initial metrics measured are <tt>GX_PERF0_NONE</tt> and <tt>GX_PERF1_NONE</tt>, which return counts of zero\n for the first call to GX_ReadGPMetric().\n\n Each performance counter has a unique set of events or ratios that it can count. In some cases the same metric can be counted using both\n counters, for example <tt>GX_PERF0_VERTICES</tt> and <tt>GX_PERF1_VERTICES</tt>. Ratios (the metric name ends in <tt>_RATIO</tt>) are multiplied by\n 1000 (1000 = all misses/clips, etc., 0 = no misses/clips, etc.).\n\n > **Note:** GX_ReadGPMetric() and GX_ClearGPMetric() can be used in the callback associated with the draw sync interrupt (see GX_SetDrawSyncCallback()).\n This function should not be used in the draw sync callback because it will insert tokens in the GP command stream at random times.\n\n This function reads results from CPU-accessible registers in the GP, therefore, this command <i>must not</i> be used in a display list. In\n addition, the performance counters in some cases are triggered by sending tokens through the Graphics FIFO to the GP. This implies that\n the function should only be used in immediate mode (when the Graphics FIFO is connected to the CPU and the GP at the same time). It may\n also be necessary to send a draw sync token using GX_SetDrawSync() or call GX_SetDrawDone() after GX_ReadGPMetric() to ensure that the\n state has actually been processed by the GP.\n\n # Arguments\n\n* `perf0` (direction in) - perf0metrics to measure\n * `perf1` (direction in) - perf1metrics to measure\n\n # Returns\n\nnone"]
    pub fn GX_SetGPMetric(perf0: u32_, perf1: u32_);
}
extern "C" {
    #[doc = "void GX_ClearGPMetric(void)\n Clears the two virtual GP performance counters to zero.\n\n > **Note:** The counter's function is set using GX_SetGPMetric(); the counter's value is read using GX_ReadGPMetric(). Consult these for more details.\n\n This function resets CPU accessible counters, so it should <b>not</b> be used in a display list.\n\n # Returns\n\nnone"]
    pub fn GX_ClearGPMetric();
}
extern "C" {
    #[doc = "void GX_InitXfRasMetric(void)\n Initialize the transformation unit (XF) rasterizer unit (RAS) to take performance measurements.\n\n This function should be avoided; use the GP performance metric functions instead.\n\n # Returns\n\nnone"]
    pub fn GX_InitXfRasMetric();
}
extern "C" {
    #[doc = "void GX_ReadXfRasMetric(u32 *xfwaitin,u32 *xfwaitout,u32 *rasbusy,u32 *clks)\n Read performance metric values from the XF and RAS units.\n\n This function should be avoided; use the GP performance metric functions instead.<br><br>\n\n The parameters for this function are a best guess based on names and existing code.\n\n # Arguments\n\n* `xfwaitin` (direction out) - Number of clocks the XF has waited for data to arrive?\n * `xfwaitout` (direction out) - Number of clocks the XF has waited to push finished data down?\n * `rasbusy` (direction out) - Number of clocks the RAS has spent being busy?\n * `clks` (direction out) - Clocks that have passed since last count reset?\n\n # Returns\n\nnone"]
    pub fn GX_ReadXfRasMetric(
        xfwaitin: *mut u32_,
        xfwaitout: *mut u32_,
        rasbusy: *mut u32_,
        clks: *mut u32_,
    );
}
extern "C" {
    #[doc = "void GX_ClearVCacheMetric(void)\n Clears the Vertex Cache performance counter.\n\n \n\nThis function clears the performance counter by sending a special clear token via the Graphics FIFO.\n\n > **Note:** To set the metric for the counter, call GX_SetVCacheMetric(); to read the counter value, call GX_ReadVCacheMetric().\n\n # Returns\n\nnone"]
    pub fn GX_ClearVCacheMetric();
}
extern "C" {
    #[doc = "void GX_ReadVCacheMetric(u32 *check,u32 *miss,u32 *stall)\n Returns Vertex Cache performance counters.\n\n \n\nEach call to this function resets the counter to zero. GX_SetVCacheMetric() sets the metric to be measured by\n the Vertex Cache performance counter.\n\n This function reads CPU-accessible registers in the GP and so should not be called in a display list.\n\n # Arguments\n\n* `check` (direction out) - total number of accesses to the vertex cache\n * `miss` (direction out) - total number of cache misses to the vertex cache\n * `stall` (direction out) - number of GP clocks that the vertex cache was stalled\n\n # Returns\n\nnone"]
    pub fn GX_ReadVCacheMetric(check: *mut u32_, miss: *mut u32_, stall: *mut u32_);
}
extern "C" {
    #[doc = "void GX_SetVCacheMetric(u32 attr)\n Sets the metric the Vertex Cache performance counter will measure.\n\n \n\nIt is possible to monitor a particular attribute or all attributes using _attr._\n\n > **Note:** To clear the counter, call GX_ClearVCacheMetric(); to read the counter value, call GX_ReadVCacheMetric().\n\n # Arguments\n\n* `attr` (direction in) - vcachemetrics to measure\n\n # Returns\n\nnone"]
    pub fn GX_SetVCacheMetric(attr: u32_);
}
extern "C" {
    #[doc = "void GX_GetGPStatus(u8 *overhi,u8 *underlow,u8 *readIdle,u8 *cmdIdle,u8 *brkpt)\n Reads the current status of the GP.\n\n \n\n_overhi_ and _underlow_ will indicate whether or not the watermarks have been reached. If the CPU and GP FIFOs\n are the same, then _overhi_ will indicate whether or not the current GX thread is suspended. The value of _brkpt_ can be\n used to determine if a breakpoint is in progress (i.e. GP reads are suspended; they are resumed by a call to\n GX_DisableBreakPt()). A callback can also be used to notify your application that the break point has been reached. (see\n GX_SetBreakPtCallback())\n\n # Arguments\n\n* `overhi` (direction out) - <tt>GX_TRUE</tt> if high watermark has been passed\n * `underlow` (direction out) - <tt>GX_TRUE</tt> if low watermark has been passed\n * `readIdle` (direction out) - <tt>GX_TRUE</tt> if the GP read unit is idle\n * `cmdIdle` (direction out) - <tt>GX_TRUE</tt> if all commands have been flushed to XF\n * `brkpt` (direction out) - <tt>GX_TRUE</tt> if FIFO has reached a breakpoint and GP reads have been stopped\n\n # Returns\n\nnone"]
    pub fn GX_GetGPStatus(
        overhi: *mut u8_,
        underlow: *mut u8_,
        readIdle: *mut u8_,
        cmdIdle: *mut u8_,
        brkpt: *mut u8_,
    );
}
extern "C" {
    #[doc = "void GX_ReadGPMetric(u32 *cnt0,u32 *cnt1)\n Returns the count of the previously set performance metrics.\n\n > **Note:** The performance metrics can be set using GX_SetGPMetric(); the counters can be cleared using GX_ClearGPMetric().<br><br>\n\n > **Note:** GX_ReadGPMetric() and GX_ClearGPMetric() can be used in the callback associated with the draw sync interrupt (see GX_SetDrawSyncCallback()).\n The function GX_SetGPMetric() should <b>not</b> be used in the draw sync callback because it will insert tokens in the GP command stream at random times.<br><br>\n\n This function reads results from CPU-accessible registers in the GP, therefore, this command <i>must not</i> be used in a display list. It\n may also be necessary to send a draw sync token using GX_SetDrawSync() or GX_SetDrawDone() before GX_ReadGPMetric() is called to ensure that the\n state has actually been processed by the GP.\n\n # Arguments\n\n* `cnt0` (direction out) - current value of GP counter 0\n * `cnt1` (direction out) - current value of GP counter 1\n\n # Returns\n\nnone"]
    pub fn GX_ReadGPMetric(cnt0: *mut u32_, cnt1: *mut u32_);
}
extern "C" {
    #[doc = "void GX_ReadBoundingBox(u16 *top,u16 *bottom,u16 *left,u16 *right)\n Returns the bounding box of pixel coordinates that are drawn in the Embedded Framebuffer (EFB).\n\n \n\nThis function reads the bounding box values. GX_ClearBoundingBox() can be used reset the values of the bounding box.\n\n > **Note:** Since the hardware can only test the bounding box in quads (2x2 pixel blocks), the result of this function may contain error\n of plus or minus 1 pixel. Also because of this, <b>left</b> and <b>top</b> are always even-numbered and <b>right</b> and <b>bottom</b>\n are always odd-numbered.\n\n # Arguments\n\n* `top` (direction out) - uppermost line in the bounding box\n * `bottom` (direction out) - lowest line in the bounding box\n * `left` (direction out) - leftmost pixel in the bounding box\n * `right` (direction out) - rightmost pixel in the bounding box\n\n # Returns\n\nnone"]
    pub fn GX_ReadBoundingBox(top: *mut u16_, bottom: *mut u16_, left: *mut u16_, right: *mut u16_);
}
extern "C" {
    #[doc = "volatile void* GX_RedirectWriteGatherPipe(void *ptr)\n Temporarily points the CPU's write-gather pipe at a new location.\n\n \n\nAfter calling this function, subsequent writes to the address returned by this function (or the WGPipe union)\n will be gathered and sent to a destination buffer. The write pointer is automatically incremented by the GP. The write\n gather pipe can be restored by calling GX_RestoreWriteGatherPipe(). This function cannot be called between a\n GX_Begin()/GX_End() pair.\n\n > **Note:** The destination buffer, referred to by _ptr,_ must be 32 byte aligned. The amount of data written should\n also be 32-byte aligned. If it is not, zeroes will be added to pad the destination buffer to 32 bytes. No part of the\n destination buffer should be modified inside the CPU caches - this may introduce cache incoherency problems.<br><br>\n\n > **Note:** The write gather pipe is one of the fastest ways to move data out of the CPU (the other being the locked cache DMA).\n In general, you are compute-bound when sending data from the CPU.<br><br>\n\n > **Note:** This function is cheaper than trying to create a fake CPU fifo around a destination buffer, which requires calls to\n GX_SetCPUFifo(), GX_InitFifoBase(), etc. This function performs very light weight state saves by assuming that the CPU and\n GP FIFOs never change.\n\n <b>No GX commands can be called until the write gather pipe is restored. You MUST call\n GX_RestoreWriteGatherPipe() before calling this function again, or else the final call to restore the pipe will fail.</b>\n\n # Arguments\n\n* `ptr` (direction in) - to destination buffer, 32-byte aligned\n\n # Returns\n\nreal address of the write-gather \"port\". All writes to this address will be gathered by the CPU write gather pipe.\n You may also use the WGPipe union. If you do not use the WGPipe union, ensure that your local variable is volatile."]
    pub fn GX_RedirectWriteGatherPipe(ptr: *mut ::libc::c_void) -> *mut ::libc::c_void;
}
pub type SICallback = ::core::option::Option<unsafe extern "C" fn(arg1: s32, arg2: u32_)>;
pub type RDSTHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32_, arg2: *mut ::libc::c_void)>;
extern "C" {
    pub fn SI_Sync() -> u32_;
}
extern "C" {
    pub fn SI_Busy() -> u32_;
}
extern "C" {
    pub fn SI_IsChanBusy(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_SetXY(line: u16_, cnt: u8_);
}
extern "C" {
    pub fn SI_EnablePolling(poll: u32_);
}
extern "C" {
    pub fn SI_DisablePolling(poll: u32_);
}
extern "C" {
    pub fn SI_SetCommand(chan: s32, cmd: u32_);
}
extern "C" {
    pub fn SI_GetStatus(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_GetResponse(chan: s32, buf: *mut ::libc::c_void) -> u32_;
}
extern "C" {
    pub fn SI_GetResponseRaw(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_SetSamplingRate(samplingrate: u32_);
}
extern "C" {
    pub fn SI_RefreshSamplingRate();
}
extern "C" {
    pub fn SI_Transfer(
        chan: s32,
        out: *mut ::libc::c_void,
        out_len: u32_,
        in_: *mut ::libc::c_void,
        in_len: u32_,
        cb: SICallback,
        us_delay: u32_,
    ) -> u32_;
}
extern "C" {
    pub fn SI_DecodeType(type_: u32_) -> u32_;
}
extern "C" {
    pub fn SI_GetTypeAsync(chan: s32, cb: SICallback) -> u32_;
}
extern "C" {
    pub fn SI_GetType(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_Probe(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_GetCommand(chan: s32) -> u32_;
}
extern "C" {
    pub fn SI_TransferCommands();
}
extern "C" {
    pub fn SI_RegisterPollingHandler(handler: RDSTHandler) -> u32_;
}
extern "C" {
    pub fn SI_UnregisterPollingHandler(handler: RDSTHandler) -> u32_;
}
extern "C" {
    pub fn SI_EnablePollingInterrupt(enable: s32) -> u32_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _excption_frame {
    pub EXCPT_Number: u32_,
    pub SRR0: u32_,
    pub SRR1: u32_,
    pub GPR: [u32_; 32usize],
    pub GQR: [u32_; 8usize],
    pub CR: u32_,
    pub LR: u32_,
    pub CTR: u32_,
    pub XER: u32_,
    pub MSR: u32_,
    pub DAR: u32_,
    pub state: u16_,
    pub mode: u16_,
    pub FPR: [f64_; 32usize],
    pub FPSCR: u64_,
    pub PSFPR: [f64_; 32usize],
}
pub type frame_context = _excption_frame;
#[doc = "void (*raw_irq_handler_t)(u32 irq,void *ctx)\nfunction pointer typedef for the interrupt handler callback\n# Arguments\n\n* `irq` (direction in) - interrupt number of triggered interrupt.\n* `ctx` (direction in) - pointer to the user data."]
pub type raw_irq_handler_t =
    ::core::option::Option<unsafe extern "C" fn(irq: u32_, ctx: *mut ::libc::c_void)>;
extern "C" {
    #[doc = "raw_irq_handler_t IRQ_Request(u32 nIrq,raw_irq_handler_t pHndl,void *pCtx)\nRegister an interrupt handler.\n# Arguments\n\n* `nIrq` (direction in) - interrupt number to which to register the handler\n* `pHndl` (direction in) - pointer to the handler callback function which to call when interrupt has triggered\n* `pCtx` (direction in) - pointer to user data to pass with, when handler is called\n\n# Returns\n\nOld interrupt handler, else NULL"]
    pub fn IRQ_Request(
        nIrq: u32_,
        pHndl: raw_irq_handler_t,
        pCtx: *mut ::libc::c_void,
    ) -> raw_irq_handler_t;
}
extern "C" {
    #[doc = "raw_irq_handler_t IRQ_Free(u32 nIrq)\nFree an interrupt handler.\n# Arguments\n\n* `nIrq` (direction in) - interrupt number for which to free the handler\n\n# Returns\n\nOld interrupt handler, else NULL"]
    pub fn IRQ_Free(nIrq: u32_) -> raw_irq_handler_t;
}
extern "C" {
    #[doc = "raw_irq_handler_t IRQ_GetHandler(u32 nIrq)\nGet the handler from interrupt number\n# Arguments\n\n* `nIrq` (direction in) - interrupt number for which to retrieve the handler\n\n# Returns\n\ninterrupt handler, else NULL"]
    pub fn IRQ_GetHandler(nIrq: u32_) -> raw_irq_handler_t;
}
extern "C" {
    #[doc = "u32 IRQ_Disable()\nDisable the complete IRQ subsystem. No interrupts will be served. Multithreading kernel fully disabled.\n\n# Returns\n\nOld state of the IRQ subsystem"]
    pub fn IRQ_Disable() -> u32_;
}
extern "C" {
    #[doc = "u32 IRQ_Restore(u32 level)\nRestore the IRQ subsystem with the given level. This is function should be used together with IRQ_Disable()\n# Arguments\n\n* `level` (direction in) - IRQ level to restore to.\n\n# Returns\n\nnone"]
    pub fn IRQ_Restore(level: u32_);
}
extern "C" {
    pub fn __MaskIrq(nMask: u32_);
}
extern "C" {
    pub fn __UnmaskIrq(nMask: u32_);
}
#[doc = "u32 mutex_t\ntypedef for the mutex handle"]
pub type mutex_t = u32_;
extern "C" {
    #[doc = "s32 LWP_MutexInit(mutex_t *mutex,bool use_recursive)\nInitializes a mutex lock.\n# Arguments\n\n* `mutex` (direction out) - pointer to a mutex_t handle.\n* `use_recursive` (direction in) - whether to allow the thread, whithin the same context, to enter multiple times the lock or not.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_MutexInit(mutex: *mut mutex_t, use_recursive: bool) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_MutexDestroy(mutex_t mutex)\nClose mutex lock, release all threads and handles locked on this mutex.\n# Arguments\n\n* `mutex` (direction in) - handle to the mutex_t structure.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_MutexDestroy(mutex: mutex_t) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_MutexLock(mutex_t mutex)\nEnter the mutex lock.\n# Arguments\n\n* `mutex` (direction in) - handle to the mutext_t structure.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_MutexLock(mutex: mutex_t) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_MutexTryLock(mutex_t mutex)\nTry to enter the mutex lock.\n# Arguments\n\n* `mutex` (direction in) - handle to the mutex_t structure.\n\n# Returns\n\n0: on first aquire, 1: would lock"]
    pub fn LWP_MutexTryLock(mutex: mutex_t) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_MutexUnlock(mutex_t mutex)\nRelease the mutex lock and let other threads process further on this mutex.\n# Arguments\n\n* `mutex` (direction in) - handle to the mutex_t structure.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_MutexUnlock(mutex: mutex_t) -> s32;
}
#[doc = "u32 mqbox_t\ntypedef for the message queue handle"]
pub type mqbox_t = u32_;
#[doc = "void* mqmsg_t\ntypedef for the message pointer"]
pub type mqmsg_t = *mut ::libc::c_void;
extern "C" {
    #[doc = "u32 MQ_Init(mqbox_t *mqbox,u32 count)\nInitializes a message queue\n# Arguments\n\n* `mqbox` (direction out) - pointer to the mqbox_t handle.\n* `count` (direction in) - maximum number of messages the queue can hold\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn MQ_Init(mqbox: *mut mqbox_t, count: u32_) -> s32;
}
extern "C" {
    #[doc = "void MQ_Close(mqbox_t mqbox)\nCloses the message queue and releases all memory.\n# Arguments\n\n* `mqbox` (direction in) - handle to the mqbox_t structure.\n\n# Returns\n\nnone"]
    pub fn MQ_Close(mqbox: mqbox_t);
}
extern "C" {
    #[doc = "BOOL MQ_Send(mqbox_t mqbox,mqmsg_t msg,u32 flags)\nSends a message to the given message queue.\n# Arguments\n\n* `mqbox` (direction in) - mqbox_t handle to the message queue\n* `msg` (direction in) - message to send\n* `flags` (direction in) - message flags (MQ_MSG_BLOCK, MQ_MSG_NOBLOCK)\n\n# Returns\n\nbool result"]
    pub fn MQ_Send(mqbox: mqbox_t, msg: mqmsg_t, flags: u32_) -> BOOL;
}
extern "C" {
    #[doc = "BOOL MQ_Jam(mqbox_t mqbox,mqmsg_t msg,u32 flags)\nSends a message to the given message queue and jams it in front of the queue.\n# Arguments\n\n* `mqbox` (direction in) - mqbox_t handle to the message queue\n* `msg` (direction in) - message to send\n* `flags` (direction in) - message flags (MQ_MSG_BLOCK, MQ_MSG_NOBLOCK)\n\n# Returns\n\nbool result"]
    pub fn MQ_Jam(mqbox: mqbox_t, msg: mqmsg_t, flags: u32_) -> BOOL;
}
extern "C" {
    #[doc = "BOOL MQ_Receive(mqbox_t mqbox,mqmsg_t *msg,u32 flags)\nSends a message to the given message queue.\n# Arguments\n\n* `mqbox` (direction in) - mqbox_t handle to the message queue\n* `msg` (direction in) - pointer to a mqmsg_t_t-type message to receive.\n* `flags` (direction in) - message flags (MQ_MSG_BLOCK, MQ_MSG_NOBLOCK)\n\n# Returns\n\nbool result"]
    pub fn MQ_Receive(mqbox: mqbox_t, msg: *mut mqmsg_t, flags: u32_) -> BOOL;
}
#[doc = "u32 sem_t\ntypedef for the semaphore handle"]
pub type sem_t = u32_;
extern "C" {
    #[doc = "s32 LWP_SemInit(sem_t *sem,u32 start,u32 max)\nInitializes a semaphore.\n# Arguments\n\n* `sem` (direction out) - pointer to a sem_t handle.\n* `start` (direction in) - start count of the semaphore\n* `max` (direction in) - maximum count of the semaphore\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_SemInit(sem: *mut sem_t, start: u32_, max: u32_) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_SemDestroy(sem_t sem)\nClose and destroy a semaphore, release all threads and handles locked on this semaphore.\n# Arguments\n\n* `sem` (direction in) - handle to the sem_t structure.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_SemDestroy(sem: sem_t) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_SemWait(sem_t sem)\nCount down semaphore counter and enter lock if counter <=0\n# Arguments\n\n* `sem` (direction in) - handle to the sem_t structure.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_SemWait(sem: sem_t) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_SemGetValue(sem_t sem, u32* value)\nreturn the current semaphore count\n# Arguments\n\n* `sem` (direction in) - handle to the sem_t structure.\n* `the` (direction out) - current value of the semaphore\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_SemGetValue(sem: sem_t, value: *mut u32_) -> s32;
}
extern "C" {
    #[doc = "s32 LWP_SemPost(sem_t sem)\nCount up semaphore counter and release lock if counter >0\n# Arguments\n\n* `sem` (direction in) - handle to the sem_t structure.\n\n# Returns\n\n0 on success, <0 on error"]
    pub fn LWP_SemPost(sem: sem_t) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _padstatus {
    pub button: u16_,
    pub stickX: s8,
    pub stickY: s8,
    pub substickX: s8,
    pub substickY: s8,
    pub triggerL: u8_,
    pub triggerR: u8_,
    pub analogA: u8_,
    pub analogB: u8_,
    pub err: s8,
}
pub type PADStatus = _padstatus;
pub type sampling_callback = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn PAD_Init() -> u32_;
}
extern "C" {
    pub fn PAD_Sync() -> u32_;
}
extern "C" {
    pub fn PAD_Read(status: *mut PADStatus) -> u32_;
}
extern "C" {
    pub fn PAD_Reset(mask: u32_) -> u32_;
}
extern "C" {
    pub fn PAD_Recalibrate(mask: u32_) -> u32_;
}
extern "C" {
    pub fn PAD_Clamp(status: *mut PADStatus);
}
extern "C" {
    pub fn PAD_ControlMotor(chan: s32, cmd: u32_);
}
extern "C" {
    pub fn PAD_SetSpec(spec: u32_);
}
extern "C" {
    pub fn PAD_ScanPads() -> u32_;
}
extern "C" {
    pub fn PAD_ButtonsUp(pad: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn PAD_ButtonsDown(pad: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn PAD_ButtonsHeld(pad: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn PAD_SubStickX(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_SubStickY(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_StickX(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_StickY(pad: ::libc::c_int) -> s8;
}
extern "C" {
    pub fn PAD_TriggerL(pad: ::libc::c_int) -> u8_;
}
extern "C" {
    pub fn PAD_TriggerR(pad: ::libc::c_int) -> u8_;
}
extern "C" {
    pub fn PAD_SetSamplingCallback(cb: sampling_callback) -> sampling_callback;
}
pub type FHANDLE = *mut ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tplfile {
    pub type_: ::libc::c_int,
    pub ntextures: ::libc::c_int,
    pub texdesc: *mut ::libc::c_void,
    pub tpl_file: FHANDLE,
}
pub type TPLFile = _tplfile;
extern "C" {
    pub fn TPL_OpenTPLFromFile(tdf: *mut TPLFile, file_name: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn TPL_OpenTPLFromMemory(tdf: *mut TPLFile, memory: *mut ::libc::c_void, len: u32_) -> s32;
}
extern "C" {
    pub fn TPL_GetTexture(tdf: *mut TPLFile, id: s32, texObj: *mut GXTexObj) -> s32;
}
extern "C" {
    pub fn TPL_GetTextureCI(
        tdf: *mut TPLFile,
        id: s32,
        texObj: *mut GXTexObj,
        tlutObj: *mut GXTlutObj,
        tluts: u8_,
    ) -> s32;
}
extern "C" {
    pub fn TPL_GetTextureInfo(
        tdf: *mut TPLFile,
        id: s32,
        fmt: *mut u32_,
        width: *mut u16_,
        height: *mut u16_,
    ) -> s32;
}
extern "C" {
    pub fn TPL_CloseTPLFile(tdf: *mut TPLFile);
}
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
pub type wint_t = ::libc::c_int;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_ulong;
pub type _ssize_t = ::libc::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<wint_t>,
    pub __wchb: __BindgenUnionField<[::libc::c_uchar; 4usize]>,
    pub bindgen_union_field: u32,
}
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::libc::c_ulong;
pub type __daddr_t = ::libc::c_long;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::libc::c_int;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::libc::c_ulong;
pub type _LOCK_T = ::libc::c_int;
pub type _LOCK_RECURSIVE_T = ::libc::c_int;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1 {
    pub _reent: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 25usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::libc::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::libc::c_int;
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::libc::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::libc::c_int,
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub contentionscope: ::libc::c_int,
    pub inheritsched: ::libc::c_int,
    pub schedpolicy: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::libc::c_int,
    pub recursive: ::libc::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::libc::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::libc::c_int,
    pub init_executed: ::libc::c_int,
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::libc::c_long;
}
extern "C" {
    pub static mut _daylight: ::libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::libc::c_char; 2usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::libc::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::libc::c_void>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: sigval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_value: sigval,
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: usize,
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::libc::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::libc::c_int, arg3: sigval) -> ::libc::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::libc::c_int, arg2: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn str2sig(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
pub type sig_atomic_t = ::libc::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn signal(arg1: ::libc::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::libc::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::libc::c_int;
}
#[doc = "u32 syswd_t\n handle typedef for the alarm context"]
pub type syswd_t = u32_;
#[doc = "struct _syssram syssram\n holds the stored configuration value from the system SRAM area\n # Arguments\n\n* `checksum` - holds the block checksum.\n * `checksum_in` - holds the inverse block checksum\n * `ead0` - unknown attribute\n * `ead1` - unknown attribute\n * `counter_bias` - bias value for the realtime clock\n * `display_offsetH` - pixel offset for the VI\n * `ntd` - mostly unknown attribute\n * `lang` - language of system\n * `flags` - device and operations flag"]
pub type syssram = _syssram;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _syssram {
    pub checksum: u16_,
    pub checksum_inv: u16_,
    pub ead0: u32_,
    pub ead1: u32_,
    pub counter_bias: u32_,
    pub display_offsetH: s8,
    pub ntd: u8_,
    pub lang: u8_,
    pub flags: u8_,
}
#[doc = "struct _syssramex syssramex\n holds the stored configuration value from the extended SRAM area\n # Arguments\n\n* `flash_id[2][12]` - 96bit memorycard unlock flash ID\n * `wirelessKbd_id` - Device ID of last connected wireless keyboard\n * `wirelessPad_id[4]` - 16bit device ID of last connected pad.\n * `dvderr_code` - last non-recoverable error from DVD interface\n * `__padding0` - padding\n * `flashID_chksum[2]` - 8bit checksum of unlock flash ID\n * `gbs` - Game Boy Player Start-Up Disc settings\n * `__padding1` - padding"]
pub type syssramex = _syssramex;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _syssramex {
    pub flash_id: [[u8_; 12usize]; 2usize],
    pub wirelessKbd_id: u32_,
    pub wirelessPad_id: [u16_; 4usize],
    pub dvderr_code: u8_,
    pub __padding0: u8_,
    pub flashID_chksum: [u8_; 2usize],
    pub gbs: u16_,
    pub __padding1: u16_,
}
pub type alarmcallback =
    ::core::option::Option<unsafe extern "C" fn(alarm: syswd_t, cb_arg: *mut ::libc::c_void)>;
pub type sys_fontheader = _sys_fontheader;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sys_fontheader {
    pub font_type: u16_,
    pub first_char: u16_,
    pub last_char: u16_,
    pub inval_char: u16_,
    pub asc: u16_,
    pub desc: u16_,
    pub width: u16_,
    pub leading: u16_,
    pub cell_width: u16_,
    pub cell_height: u16_,
    pub sheet_size: u32_,
    pub sheet_format: u16_,
    pub sheet_column: u16_,
    pub sheet_row: u16_,
    pub sheet_width: u16_,
    pub sheet_height: u16_,
    pub width_table: u16_,
    pub sheet_image: u32_,
    pub sheet_fullsize: u32_,
    pub c0: u8_,
    pub c1: u8_,
    pub c2: u8_,
    pub c3: u8_,
}
pub type resetcallback =
    ::core::option::Option<unsafe extern "C" fn(irq: u32_, ctx: *mut ::libc::c_void)>;
pub type powercallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type resetfunction = ::core::option::Option<unsafe extern "C" fn(final_: s32) -> s32>;
pub type sys_resetinfo = _sys_resetinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sys_resetinfo {
    pub node: lwp_node,
    pub func: resetfunction,
    pub prio: u32_,
}
extern "C" {
    #[doc = "void SYS_Init(void)\n> **Deprecated** Performs basic system initialization such as EXI init etc. This function is called from within the crt0 startup code.\n\n# Returns\n\nnone"]
    pub fn SYS_Init();
}
extern "C" {
    #[doc = "void* SYS_AllocateFramebuffer(GXRModeObj *rmode)\n Allocate cacheline aligned memory for the external framebuffer based on the rendermode object.\n # Arguments\n\n* `rmode` (direction in) - pointer to the video/render mode configuration\n\n # Returns\n\npointer to the framebuffer's startaddress. <b><i>NOTE:</i></b> Address returned is aligned to a 32byte boundery!"]
    pub fn SYS_AllocateFramebuffer(rmode: *mut GXRModeObj) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_ProtectRange(chan: u32_, addr: *mut ::libc::c_void, bytes: u32_, cntrl: u32_);
}
extern "C" {
    pub fn SYS_StartPMC(mcr0val: u32_, mcr1val: u32_);
}
extern "C" {
    pub fn SYS_DumpPMC();
}
extern "C" {
    pub fn SYS_StopPMC();
}
extern "C" {
    pub fn SYS_ResetPMC();
}
extern "C" {
    #[doc = "s32 SYS_CreateAlarm(syswd_t *thealarm)\nCreate/initialize sysalarm structure\n# Arguments\n\n* `thealarm` (direction in) - pointer to the handle to store the created alarm context identifier\n\n# Returns\n\n0 on succuess, non-zero on error"]
    pub fn SYS_CreateAlarm(thealarm: *mut syswd_t) -> s32;
}
extern "C" {
    #[doc = "s32 SYS_SetAlarm(syswd_t thealarm,const struct timespec *tp,alarmcallback cb)\nSet the alarm parameters for a one-shot alarm, add to the list of alarms and start.\n# Arguments\n\n* `thealarm` (direction in) - identifier to the alarm context to be initialize for a one-shot alarm\n* `tp` (direction in) - pointer to timespec structure holding the time to fire the alarm\n* `cb` (direction in) - pointer to callback which is called when the alarm fires.\n\n# Returns\n\n0 on succuess, non-zero on error"]
    pub fn SYS_SetAlarm(
        thealarm: syswd_t,
        tp: *const timespec,
        cb: alarmcallback,
        cbarg: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 SYS_SetPeriodicAlarm(syswd_t thealarm,const struct timespec *tp_start,const struct timespec *tp_period,alarmcallback cb)\nSet the alarm parameters for a periodioc alarm, add to the list of alarms and start. The alarm and interval persists as long as SYS_CancelAlarm() isn't called.\n# Arguments\n\n* `thealarm` (direction in) - identifier to the alarm context to be initialized for a periodic alarm\n* `tp_start` (direction in) - pointer to timespec structure holding the time to fire first time the alarm\n* `tp_period` (direction in) - pointer to timespec structure holding the interval for all following alarm triggers.\n* `cb` (direction in) - pointer to callback which is called when the alarm fires.\n\n# Returns\n\n0 on succuess, non-zero on error"]
    pub fn SYS_SetPeriodicAlarm(
        thealarm: syswd_t,
        tp_start: *const timespec,
        tp_period: *const timespec,
        cb: alarmcallback,
        cbarg: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    #[doc = "s32 SYS_RemoveAlarm(syswd_t thealarm)\nRemove the given alarm context from the list of contexts and destroy it\n# Arguments\n\n* `thealarm` (direction in) - identifier to the alarm context to be removed and destroyed\n\n# Returns\n\n0 on succuess, non-zero on error"]
    pub fn SYS_RemoveAlarm(thealarm: syswd_t) -> s32;
}
extern "C" {
    #[doc = "s32 SYS_CancelAlarm(syswd_t thealarm)\nCancel the alarm, but do not remove from the list of contexts.\n# Arguments\n\n* `thealarm` (direction in) - identifier to the alram context to be canceled\n\n# Returns\n\n0 on succuess, non-zero on error"]
    pub fn SYS_CancelAlarm(thealarm: syswd_t) -> s32;
}
extern "C" {
    pub fn SYS_STDIO_Report(use_stdout: bool);
}
extern "C" {
    #[doc = "void SYS_Report (char const *const fmt_, ...)\nwrite formatted string to Dolphin OSReport uart"]
    pub fn SYS_Report(fmt_: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn SYS_GetCounterBias() -> u32_;
}
extern "C" {
    pub fn SYS_SetCounterBias(bias: u32_);
}
extern "C" {
    pub fn SYS_GetDisplayOffsetH() -> s8;
}
extern "C" {
    pub fn SYS_SetDisplayOffsetH(offset: s8);
}
extern "C" {
    pub fn SYS_GetEuRGB60() -> u8_;
}
extern "C" {
    pub fn SYS_SetEuRGB60(enable: u8_);
}
extern "C" {
    pub fn SYS_GetLanguage() -> u8_;
}
extern "C" {
    pub fn SYS_SetLanguage(lang: u8_);
}
extern "C" {
    pub fn SYS_GetProgressiveScan() -> u8_;
}
extern "C" {
    pub fn SYS_SetProgressiveScan(enable: u8_);
}
extern "C" {
    pub fn SYS_GetSoundMode() -> u8_;
}
extern "C" {
    pub fn SYS_SetSoundMode(mode: u8_);
}
extern "C" {
    pub fn SYS_GetVideoMode() -> u8_;
}
extern "C" {
    pub fn SYS_SetVideoMode(mode: u8_);
}
extern "C" {
    pub fn SYS_GetWirelessID(chan: u32_) -> u16_;
}
extern "C" {
    pub fn SYS_SetWirelessID(chan: u32_, id: u16_);
}
extern "C" {
    pub fn SYS_GetGBSMode() -> u16_;
}
extern "C" {
    pub fn SYS_SetGBSMode(mode: u16_);
}
extern "C" {
    pub fn SYS_GetFontEncoding() -> u32_;
}
extern "C" {
    pub fn SYS_InitFont(font_data: *mut sys_fontheader) -> u32_;
}
extern "C" {
    pub fn SYS_GetFontTexture(
        c: s32,
        image: *mut *mut ::libc::c_void,
        xpos: *mut s32,
        ypos: *mut s32,
        width: *mut s32,
    );
}
extern "C" {
    pub fn SYS_GetFontTexel(
        c: s32,
        image: *mut ::libc::c_void,
        pos: s32,
        stride: s32,
        width: *mut s32,
    );
}
extern "C" {
    pub fn SYS_ResetSystem(reset: s32, reset_code: u32_, force_menu: s32);
}
extern "C" {
    pub fn SYS_RegisterResetFunc(info: *mut sys_resetinfo);
}
extern "C" {
    pub fn SYS_UnregisterResetFunc(info: *mut sys_resetinfo);
}
extern "C" {
    pub fn SYS_SwitchFiber(arg0: u32_, arg1: u32_, arg2: u32_, arg3: u32_, pc: u32_, newsp: u32_);
}
extern "C" {
    pub fn SYS_GetArena1Lo() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena1Lo(newLo: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena1Hi() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena1Hi(newHi: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena1Size() -> u32_;
}
extern "C" {
    pub fn SYS_SetResetCallback(cb: resetcallback) -> resetcallback;
}
extern "C" {
    pub fn SYS_ResetButtonDown() -> u32_;
}
extern "C" {
    pub fn SYS_GetHollywoodRevision() -> u32_;
}
extern "C" {
    pub fn SYS_GetArena2Lo() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena2Lo(newLo: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena2Hi() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn SYS_SetArena2Hi(newHi: *mut ::libc::c_void);
}
extern "C" {
    pub fn SYS_GetArena2Size() -> u32_;
}
extern "C" {
    pub fn SYS_SetPowerCallback(cb: powercallback) -> powercallback;
}
extern "C" {
    pub fn SYS_Time() -> u64_;
}
extern "C" {
    pub fn kprintf(str_: *const ::libc::c_char, ...);
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,singlefield NTSC mode"]
    pub static mut TVNtsc240Ds: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,singlefield,antialiased NTSC mode"]
    pub static mut TVNtsc240DsAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,interlaced NTSC mode"]
    pub static mut TVNtsc240Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 240 lines,interlaced,antialiased NTSC mode"]
    pub static mut TVNtsc240IntAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced NTSC mode"]
    pub static mut TVNtsc480Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced,doublefield NTSC mode"]
    pub static mut TVNtsc480IntDf: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced,doublefield,antialiased NTSC mode"]
    pub static mut TVNtsc480IntAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,progressive,singlefield NTSC mode"]
    pub static mut TVNtsc480Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVNtsc480ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVNtsc480ProgAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240Ds: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240DsAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240Int: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal240IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 480 lines,interlaced,doublefield,antialiased MPAL mode"]
    pub static mut TVMpal480IntDf: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVMpal480ProgAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,singlefield PAL mode"]
    pub static mut TVPal264Ds: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,singlefield,antialiased PAL mode"]
    pub static mut TVPal264DsAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,interlaced PAL mode"]
    pub static mut TVPal264Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 264 lines,interlaced,antialiased PAL mode"]
    pub static mut TVPal264IntAa: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 528 lines,interlaced PAL mode"]
    pub static mut TVPal528Int: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 528 lines,interlaced,doublefield PAL mode"]
    pub static mut TVPal528IntDf: GXRModeObj;
}
extern "C" {
    #[doc = "< Video and render mode configuration for 524 lines,interlaced,doublefield,antialiased PAL mode"]
    pub static mut TVPal524IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVPal576IntDfScale: GXRModeObj;
}
extern "C" {
    pub static mut TVPal528Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVPal528ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVPal524ProgAa: GXRModeObj;
}
extern "C" {
    pub static mut TVPal576ProgScale: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240Ds: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240DsAa: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240Int: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz240IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480Int: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480IntDf: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480IntAa: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480Prog: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480ProgSoft: GXRModeObj;
}
extern "C" {
    pub static mut TVEurgb60Hz480ProgAa: GXRModeObj;
}
#[doc = "void (*VIRetraceCallback)(u32 retraceCnt)\n function pointer typedef for the user's retrace callback\n # Arguments\n\n* `retraceCnt` (direction in) - current retrace count"]
pub type VIRetraceCallback = ::core::option::Option<unsafe extern "C" fn(retraceCnt: u32_)>;
pub type VIPositionCallback = ::core::option::Option<unsafe extern "C" fn(posX: u32_, posY: u32_)>;
extern "C" {
    pub fn VIDEO_GetNextFramebuffer() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn VIDEO_GetCurrentFramebuffer() -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "void VIDEO_Init(void)\n Initializes the VIDEO subsystem. This call should be done in the early stages of your main()\n\n # Returns\n\nnone"]
    pub fn VIDEO_Init();
}
extern "C" {
    #[doc = "void VIDEO_Flush(void)\n Flush the shadow registers to the drivers video registers.\n\n # Returns\n\nnone"]
    pub fn VIDEO_Flush();
}
extern "C" {
    #[doc = "void VIDEO_SetBlack(bool black)\n Blackout the VIDEO interface.\n\n # Arguments\n\n* `black` (direction in) - Boolean flag to determine whether to blackout the VI or not.\n\n # Returns\n\nnone"]
    pub fn VIDEO_SetBlack(black: bool);
}
extern "C" {
    #[doc = "u32 VIDEO_GetNextField(void)\n Get the next field in DS mode.\n\n # Returns\n\nvi_fielddef \"field\""]
    pub fn VIDEO_GetNextField() -> u32_;
}
extern "C" {
    #[doc = "u32 VIDEO_GetCurrentLine(void)\n Get current video line\n\n # Returns\n\nlinenumber"]
    pub fn VIDEO_GetCurrentLine() -> u32_;
}
extern "C" {
    #[doc = "u32 VIDEO_GetCurrentTvMode(void)\n Get current configured TV mode\n\n # Returns\n\nvi_standardtypedef \"tvmode\""]
    pub fn VIDEO_GetCurrentTvMode() -> u32_;
}
extern "C" {
    #[doc = "void VIDEO_Configure(GXRModeObj *rmode)\n Configure the VI with the given render mode object\n\n # Arguments\n\n* `rmode` (direction in) - pointer to the video/render mode gxrmode_obj \"configuration\".\n\n # Returns\n\nnone"]
    pub fn VIDEO_Configure(rmode: *mut GXRModeObj);
}
extern "C" {
    pub fn VIDEO_GetFrameBufferSize(rmode: *mut GXRModeObj) -> u32_;
}
extern "C" {
    #[doc = "void VIDEO_ClearFrameBuffer(GXRModeObj *rmode,void *fb,u32 color)\n Clear the given framebuffer.\n\n # Arguments\n\n* `rmode` (direction in) - pointer to a GXRModeObj, specifying the mode.\n * `fb` (direction in) - pointer to the startaddress of the framebuffer to clear.\n * `color` (direction in) - YUYUV value to use for clearing.\n\n # Returns\n\nnone"]
    pub fn VIDEO_ClearFrameBuffer(rmode: *mut GXRModeObj, fb: *mut ::libc::c_void, color: u32_);
}
extern "C" {
    #[doc = "void VIDEO_WaitVSync(void)\n Wait on the next vertical retrace\n\n # Returns\n\nnone"]
    pub fn VIDEO_WaitVSync();
}
extern "C" {
    #[doc = "void VIDEO_SetNextFramebuffer(void *fb)\n Set the framebuffer for the next VI register update.\n\n # Returns\n\nnone"]
    pub fn VIDEO_SetNextFramebuffer(fb: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "void VIDEO_SetNextRightFramebuffer(void *fb)\n Set the right framebuffer for the next VI register update. This is used for 3D Gloves for instance.\n\n # Returns\n\nnone"]
    pub fn VIDEO_SetNextRightFramebuffer(fb: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "VIRetraceCallback VIDEO_SetPreRetraceCallback(VIRetraceCallback callback)\n Set the Pre-Retrace callback function. This function is called within the video interrupt handler before the VI registers will be updated.\n\n # Arguments\n\n* `callback` (direction in) - pointer to the callback function which is called at pre-retrace.\n\n # Returns\n\nOld pre-retrace callback or NULL"]
    pub fn VIDEO_SetPreRetraceCallback(callback: VIRetraceCallback) -> VIRetraceCallback;
}
extern "C" {
    #[doc = "VIRetraceCallback VIDEO_SetPostRetraceCallback(VIRetraceCallback callback)\n Set the Post-Retrace callback function. This function is called within the video interrupt handler after the VI registers are updated.\n\n # Arguments\n\n* `callback` (direction in) - pointer to the callback function which is called at post-retrace.\n\n # Returns\n\nOld post-retrace callback or NULL"]
    pub fn VIDEO_SetPostRetraceCallback(callback: VIRetraceCallback) -> VIRetraceCallback;
}
extern "C" {
    #[doc = "u32 VIDEO_HaveComponentCable(void)\n Check for a component cable. This function returns 1 when a Component (YPbPr) cable is connected.\n\n # Returns\n\n1 if a component cable is connected, 0 otherwise"]
    pub fn VIDEO_HaveComponentCable() -> u32_;
}
extern "C" {
    pub fn VIDEO_GetPreferredMode(mode: *mut GXRModeObj) -> *mut GXRModeObj;
}
extern "C" {
    #[doc = "u32 VIDEO_GetVideoScanMode(void)\n Get video scan mode. This function returns 0 when interlaced, 1 when non interlaced and 2 when progressive\n\n # Returns\n\n0 when interlaced, 1 when non interlaced and 2 when progressive"]
    pub fn VIDEO_GetVideoScanMode() -> u32_;
}
extern "C" {
    pub fn usb_flush(chn: s32);
}
extern "C" {
    pub fn usb_isgeckoalive(chn: s32) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer_safe(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer_safe(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer_ex(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer_ex(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_recvbuffer_safe_ex(
        chn: s32,
        buffer: *mut ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_sendbuffer_safe_ex(
        chn: s32,
        buffer: *const ::libc::c_void,
        size: ::libc::c_int,
        retries: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_flashread(
        chn: s32,
        offset: u32_,
        buffer: *mut ::libc::c_void,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_flashwrite(
        chn: s32,
        offset: u32_,
        buffer: *const ::libc::c_void,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn usb_flashverify(chn: s32) -> ::libc::c_int;
}
extern "C" {
    pub fn MakeTexture565(
        src: *const ::libc::c_void,
        dst: *mut ::libc::c_void,
        width: s32,
        height: s32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ioctlv {
    pub data: *mut ::libc::c_void,
    pub len: u32_,
}
pub type ioctlv = _ioctlv;
extern "C" {
    pub fn __IPC_Reinitialize();
}
pub type ipccallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn iosCreateHeap(size: s32) -> s32;
}
extern "C" {
    pub fn iosAlloc(hid: s32, size: s32) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn iosFree(hid: s32, ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn IPC_GetBufferLo() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn IPC_GetBufferHi() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn IPC_SetBufferLo(bufferlo: *mut ::libc::c_void);
}
extern "C" {
    pub fn IPC_SetBufferHi(bufferhi: *mut ::libc::c_void);
}
extern "C" {
    pub fn IOS_Open(filepath: *const ::libc::c_char, mode: u32_) -> s32;
}
extern "C" {
    pub fn IOS_OpenAsync(
        filepath: *const ::libc::c_char,
        mode: u32_,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Close(fd: s32) -> s32;
}
extern "C" {
    pub fn IOS_CloseAsync(fd: s32, ipc_cb: ipccallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn IOS_Seek(fd: s32, where_: s32, whence: s32) -> s32;
}
extern "C" {
    pub fn IOS_SeekAsync(
        fd: s32,
        where_: s32,
        whence: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Read(fd: s32, buf: *mut ::libc::c_void, len: s32) -> s32;
}
extern "C" {
    pub fn IOS_ReadAsync(
        fd: s32,
        buf: *mut ::libc::c_void,
        len: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Write(fd: s32, buf: *const ::libc::c_void, len: s32) -> s32;
}
extern "C" {
    pub fn IOS_WriteAsync(
        fd: s32,
        buf: *const ::libc::c_void,
        len: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Ioctl(
        fd: s32,
        ioctl: s32,
        buffer_in: *mut ::libc::c_void,
        len_in: s32,
        buffer_io: *mut ::libc::c_void,
        len_io: s32,
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlAsync(
        fd: s32,
        ioctl: s32,
        buffer_in: *mut ::libc::c_void,
        len_in: s32,
        buffer_io: *mut ::libc::c_void,
        len_io: s32,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_Ioctlv(fd: s32, ioctl: s32, cnt_in: s32, cnt_io: s32, argv: *mut ioctlv) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvAsync(
        fd: s32,
        ioctl: s32,
        cnt_in: s32,
        cnt_io: s32,
        argv: *mut ioctlv,
        ipc_cb: ipccallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvFormat(
        hId: s32,
        fd: s32,
        ioctl: s32,
        format: *const ::libc::c_char,
        ...
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvFormatAsync(
        hId: s32,
        fd: s32,
        ioctl: s32,
        usr_cb: ipccallback,
        usr_data: *mut ::libc::c_void,
        format: *const ::libc::c_char,
        ...
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvReboot(
        fd: s32,
        ioctl: s32,
        cnt_in: s32,
        cnt_io: s32,
        argv: *mut ioctlv,
    ) -> s32;
}
extern "C" {
    pub fn IOS_IoctlvRebootBackground(
        fd: s32,
        ioctl: s32,
        cnt_in: s32,
        cnt_io: s32,
        argv: *mut ioctlv,
    ) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha_context {
    pub states: [u32_; 5usize],
    pub upper_length: u32_,
    pub lower_length: u32_,
}
extern "C" {
    pub fn SHA_Init() -> s32;
}
extern "C" {
    pub fn SHA_Close() -> s32;
}
extern "C" {
    pub fn SHA_InitializeContext(context: *mut sha_context) -> s32;
}
extern "C" {
    pub fn SHA_Calculate(
        context: *mut sha_context,
        data: *const ::libc::c_void,
        data_size: u32_,
        message_digest: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn SHA_Input(
        context: *mut sha_context,
        data: *const ::libc::c_void,
        data_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn AES_Init() -> s32;
}
extern "C" {
    pub fn AES_Close() -> s32;
}
extern "C" {
    pub fn AES_Decrypt(
        key: *const ::libc::c_void,
        key_size: u32_,
        iv: *mut ::libc::c_void,
        iv_size: u32_,
        in_data: *const ::libc::c_void,
        out_data: *mut ::libc::c_void,
        data_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn AES_Encrypt(
        key: *const ::libc::c_void,
        key_size: u32_,
        iv: *mut ::libc::c_void,
        iv_size: u32_,
        in_data: *const ::libc::c_void,
        out_data: *mut ::libc::c_void,
        data_size: u32_,
    ) -> s32;
}
pub type sigtype = u32_;
pub type sig_header = sigtype;
pub type signed_blob = sig_header;
pub type sha1 = [u8_; 20usize];
pub type aeskey = [u8_; 16usize];
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sig_rsa2048 {
    pub type_: sigtype,
    pub sig: [u8_; 256usize],
    pub fill: [u8_; 60usize],
}
pub type sig_rsa2048 = _sig_rsa2048;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sig_rsa4096 {
    pub type_: sigtype,
    pub sig: [u8_; 512usize],
    pub fill: [u8_; 60usize],
}
pub type sig_rsa4096 = _sig_rsa4096;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _sig_ecdsa {
    pub type_: sigtype,
    pub sig: [u8_; 60usize],
    pub fill: [u8_; 64usize],
}
pub type sig_ecdsa = _sig_ecdsa;
pub type sig_issuer = [::libc::c_char; 64usize];
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tiklimit {
    pub tag: u32_,
    pub value: u32_,
}
pub type tiklimit = _tiklimit;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tikview {
    pub view: u32_,
    pub ticketid: u64_,
    pub devicetype: u32_,
    pub titleid: u64_,
    pub access_mask: u16_,
    pub reserved: [u8_; 60usize],
    pub cidx_mask: [u8_; 64usize],
    pub padding: u16_,
    pub limits: [tiklimit; 8usize],
}
pub type tikview = _tikview;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tik {
    pub issuer: sig_issuer,
    pub fill: [u8_; 63usize],
    pub cipher_title_key: aeskey,
    pub fill2: u8_,
    pub ticketid: u64_,
    pub devicetype: u32_,
    pub titleid: u64_,
    pub access_mask: u16_,
    pub reserved: [u8_; 60usize],
    pub cidx_mask: [u8_; 64usize],
    pub padding: u16_,
    pub limits: [tiklimit; 8usize],
}
pub type tik = _tik;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tmd_content {
    pub cid: u32_,
    pub index: u16_,
    pub type_: u16_,
    pub size: u64_,
    pub hash: sha1,
}
pub type tmd_content = _tmd_content;
#[repr(C, packed)]
pub struct _tmd {
    pub issuer: sig_issuer,
    pub version: u8_,
    pub ca_crl_version: u8_,
    pub signer_crl_version: u8_,
    pub vwii_title: u8_,
    pub sys_version: u64_,
    pub title_id: u64_,
    pub title_type: u32_,
    pub group_id: u16_,
    pub zero: u16_,
    pub region: u16_,
    pub ratings: [u8_; 16usize],
    pub reserved: [u8_; 12usize],
    pub ipc_mask: [u8_; 12usize],
    pub reserved2: [u8_; 18usize],
    pub access_rights: u32_,
    pub title_version: u16_,
    pub num_contents: u16_,
    pub boot_index: u16_,
    pub fill3: u16_,
    pub contents: __IncompleteArrayField<tmd_content>,
}
pub type tmd = _tmd;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _tmd_view_content {
    pub cid: u32_,
    pub index: u16_,
    pub type_: u16_,
    pub size: u64_,
}
pub type tmd_view_content = _tmd_view_content;
#[repr(C, packed)]
pub struct _tmdview {
    pub version: u8_,
    pub filler: [u8_; 3usize],
    pub sys_version: u64_,
    pub title_id: u64_,
    pub title_type: u32_,
    pub group_id: u16_,
    pub reserved: [u8_; 62usize],
    pub title_version: u16_,
    pub num_contents: u16_,
    pub contents: __IncompleteArrayField<tmd_view_content>,
}
pub type tmd_view = _tmdview;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_header {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
}
pub type cert_header = _cert_header;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_rsa2048 {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
    pub modulus: [u8_; 256usize],
    pub exponent: u32_,
    pub pad: [u8_; 52usize],
}
pub type cert_rsa2048 = _cert_rsa2048;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_rsa4096 {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
    pub modulus: [u8_; 512usize],
    pub exponent: u32_,
    pub pad: [u8_; 52usize],
}
pub type cert_rsa4096 = _cert_rsa4096;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _cert_ecdsa {
    pub issuer: sig_issuer,
    pub cert_type: u32_,
    pub cert_name: [::libc::c_char; 64usize],
    pub cert_id: u32_,
    pub r: [u8_; 30usize],
    pub s: [u8_; 30usize],
    pub pad: [u8_; 60usize],
}
pub type cert_ecdsa = _cert_ecdsa;
extern "C" {
    pub fn __ES_Init() -> s32;
}
extern "C" {
    pub fn __ES_Close() -> s32;
}
extern "C" {
    pub fn __ES_Reset() -> s32;
}
extern "C" {
    pub fn ES_GetTitleID(titleID: *mut u64_) -> s32;
}
extern "C" {
    pub fn ES_SetUID(uid: u64_) -> s32;
}
extern "C" {
    pub fn ES_GetDataDir(titleID: u64_, filepath: *mut ::libc::c_char) -> s32;
}
extern "C" {
    pub fn ES_GetNumTicketViews(titleID: u64_, cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTicketViews(titleID: u64_, views: *mut tikview, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumOwnedTitles(cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetOwnedTitles(titles: *mut u64_, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumTitles(cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTitles(titles: *mut u64_, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumStoredTMDContents(
        stmd: *const signed_blob,
        tmd_size: u32_,
        cnt: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_GetStoredTMDContents(
        stmd: *const signed_blob,
        tmd_size: u32_,
        contents: *mut u32_,
        cnt: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_GetStoredTMDSize(titleID: u64_, size: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetStoredTMD(titleID: u64_, stmd: *mut signed_blob, size: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTitleContentsCount(titleID: u64_, num: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTitleContents(titleID: u64_, data: *mut u8_, size: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTMDViewSize(titleID: u64_, size: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetTMDView(titleID: u64_, data: *mut u8_, size: u32_) -> s32;
}
extern "C" {
    pub fn ES_GetNumSharedContents(cnt: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetSharedContents(contents: *mut sha1, cnt: u32_) -> s32;
}
extern "C" {
    pub fn ES_LaunchTitle(titleID: u64_, view: *const tikview) -> s32;
}
extern "C" {
    pub fn ES_LaunchTitleBackground(titleID: u64_, view: *const tikview) -> s32;
}
extern "C" {
    pub fn ES_Identify(
        certificates: *const signed_blob,
        certificates_size: u32_,
        tmd: *const signed_blob,
        tmd_size: u32_,
        ticket: *const signed_blob,
        ticket_size: u32_,
        keyid: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_AddTicket(
        tik: *const signed_blob,
        tik_size: u32_,
        certificates: *const signed_blob,
        certificates_size: u32_,
        crl: *const signed_blob,
        crl_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_DeleteTicket(view: *const tikview) -> s32;
}
extern "C" {
    pub fn ES_AddTitleTMD(tmd: *const signed_blob, tmd_size: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddTitleStart(
        tmd: *const signed_blob,
        tmd_size: u32_,
        certificatess: *const signed_blob,
        certificatess_size: u32_,
        crl: *const signed_blob,
        crl_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_AddContentStart(titleID: u64_, cid: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddContentData(cid: s32, data: *mut u8_, data_size: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddContentFinish(cid: u32_) -> s32;
}
extern "C" {
    pub fn ES_AddTitleFinish() -> s32;
}
extern "C" {
    pub fn ES_AddTitleCancel() -> s32;
}
extern "C" {
    pub fn ES_ImportBoot(
        tik: *const signed_blob,
        tik_size: u32_,
        tik_certs: *const signed_blob,
        tik_certs_size: u32_,
        tmd: *const signed_blob,
        tmd_size: u32_,
        tmd_certs: *const signed_blob,
        tmd_certs_size: u32_,
        content: *const u8_,
        content_size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn ES_OpenContent(index: u16_) -> s32;
}
extern "C" {
    pub fn ES_OpenTitleContent(titleID: u64_, views: *mut tikview, index: u16_) -> s32;
}
extern "C" {
    pub fn ES_ReadContent(cfd: s32, data: *mut u8_, data_size: u32_) -> s32;
}
extern "C" {
    pub fn ES_SeekContent(cfd: s32, where_: s32, whence: s32) -> s32;
}
extern "C" {
    pub fn ES_CloseContent(cfd: s32) -> s32;
}
extern "C" {
    pub fn ES_DeleteTitle(titleID: u64_) -> s32;
}
extern "C" {
    pub fn ES_DeleteTitleContent(titleID: u64_) -> s32;
}
extern "C" {
    pub fn ES_Encrypt(
        keynum: u32_,
        iv: *mut u8_,
        source: *mut u8_,
        size: u32_,
        dest: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn ES_Decrypt(
        keynum: u32_,
        iv: *mut u8_,
        source: *mut u8_,
        size: u32_,
        dest: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn ES_Sign(source: *mut u8_, size: u32_, sig: *mut u8_, certs: *mut u8_) -> s32;
}
extern "C" {
    pub fn ES_GetDeviceCert(outbuf: *mut u8_) -> s32;
}
extern "C" {
    pub fn ES_GetDeviceID(device_id: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_GetBoot2Version(version: *mut u32_) -> s32;
}
extern "C" {
    pub fn ES_NextCert(certs: *const signed_blob) -> *mut signed_blob;
}
pub type stmcallback = ::core::option::Option<unsafe extern "C" fn(event: u32_)>;
extern "C" {
    pub fn __STM_Init() -> s32;
}
extern "C" {
    pub fn __STM_Close() -> s32;
}
extern "C" {
    pub fn STM_ShutdownToStandby() -> s32;
}
extern "C" {
    pub fn STM_ShutdownToIdle() -> s32;
}
extern "C" {
    pub fn STM_SetLedMode(mode: u32_) -> s32;
}
extern "C" {
    pub fn STM_RebootSystem() -> s32;
}
extern "C" {
    pub fn STM_RegisterEventHandler(newhandler: stmcallback) -> stmcallback;
}
extern "C" {
    pub fn __IOS_InitializeSubsystems() -> s32;
}
extern "C" {
    pub fn __IOS_ShutdownSubsystems() -> s32;
}
extern "C" {
    pub fn __IOS_LoadStartupIOS() -> s32;
}
extern "C" {
    pub fn __IOS_LaunchNewIOS(version: ::libc::c_int) -> s32;
}
extern "C" {
    pub fn IOS_GetPreferredVersion() -> s32;
}
extern "C" {
    pub fn IOS_ReloadIOS(version: ::libc::c_int) -> s32;
}
extern "C" {
    pub fn IOS_GetVersion() -> s32;
}
extern "C" {
    pub fn IOS_GetRevision() -> s32;
}
extern "C" {
    pub fn IOS_GetRevisionMajor() -> s32;
}
extern "C" {
    pub fn IOS_GetRevisionMinor() -> s32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbendpointdesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bEndpointAddress: u8_,
    pub bmAttributes: u8_,
    pub wMaxPacketSize: u16_,
    pub bInterval: u8_,
}
pub type usb_endpointdesc = _usbendpointdesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbinterfacedesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bInterfaceNumber: u8_,
    pub bAlternateSetting: u8_,
    pub bNumEndpoints: u8_,
    pub bInterfaceClass: u8_,
    pub bInterfaceSubClass: u8_,
    pub bInterfaceProtocol: u8_,
    pub iInterface: u8_,
    pub extra: *mut u8_,
    pub extra_size: u16_,
    pub endpoints: *mut _usbendpointdesc,
}
pub type usb_interfacedesc = _usbinterfacedesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbconfdesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub wTotalLength: u16_,
    pub bNumInterfaces: u8_,
    pub bConfigurationValue: u8_,
    pub iConfiguration: u8_,
    pub bmAttributes: u8_,
    pub bMaxPower: u8_,
    pub interfaces: *mut _usbinterfacedesc,
}
pub type usb_configurationdesc = _usbconfdesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbdevdesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bcdUSB: u16_,
    pub bDeviceClass: u8_,
    pub bDeviceSubClass: u8_,
    pub bDeviceProtocol: u8_,
    pub bMaxPacketSize0: u8_,
    pub idVendor: u16_,
    pub idProduct: u16_,
    pub bcdDevice: u16_,
    pub iManufacturer: u8_,
    pub iProduct: u8_,
    pub iSerialNumber: u8_,
    pub bNumConfigurations: u8_,
    pub configurations: *mut _usbconfdesc,
}
pub type usb_devdesc = _usbdevdesc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbhiddesc {
    pub bLength: u8_,
    pub bDescriptorType: u8_,
    pub bcdHID: u16_,
    pub bCountryCode: u8_,
    pub bNumDescriptors: u8_,
    pub descr: [_usbhiddesc__bindgen_ty_1; 1usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _usbhiddesc__bindgen_ty_1 {
    pub bDescriptorType: u8_,
    pub wDescriptorLength: u16_,
}
pub type usb_hiddesc = _usbhiddesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usb_device_entry {
    pub device_id: s32,
    pub vid: u16_,
    pub pid: u16_,
    pub token: u32_,
}
pub type usb_device_entry = _usb_device_entry;
pub type usbcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn USB_Initialize() -> s32;
}
extern "C" {
    pub fn USB_Deinitialize() -> s32;
}
extern "C" {
    pub fn USB_OpenDevice(device_id: s32, vid: u16_, pid: u16_, fd: *mut s32) -> s32;
}
extern "C" {
    pub fn USB_CloseDevice(fd: *mut s32) -> s32;
}
extern "C" {
    pub fn USB_CloseDeviceAsync(fd: *mut s32, cb: usbcallback, usrdata: *mut ::libc::c_void)
        -> s32;
}
extern "C" {
    pub fn USB_GetDescriptors(fd: s32, udd: *mut usb_devdesc) -> s32;
}
extern "C" {
    pub fn USB_FreeDescriptors(udd: *mut usb_devdesc);
}
extern "C" {
    pub fn USB_GetGenericDescriptor(
        fd: s32,
        type_: u8_,
        index: u8_,
        interface: u8_,
        data: *mut ::libc::c_void,
        size: u32_,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetHIDDescriptor(fd: s32, interface: u8_, uhd: *mut usb_hiddesc, size: u32_) -> s32;
}
extern "C" {
    pub fn USB_GetReportDescriptorSize(fd: s32, interface: u8_) -> s32;
}
extern "C" {
    pub fn USB_GetReportDescriptor(
        fd: s32,
        interface: u8_,
        data: *mut ::libc::c_void,
        size: u16_,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetDeviceDescription(fd: s32, devdesc: *mut usb_devdesc) -> s32;
}
extern "C" {
    pub fn USB_DeviceRemovalNotifyAsync(
        fd: s32,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_DeviceChangeNotifyAsync(
        interface_class: u8_,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_SuspendDevice(fd: s32) -> s32;
}
extern "C" {
    pub fn USB_ResumeDevice(fd: s32) -> s32;
}
extern "C" {
    pub fn USB_ReadIsoMsg(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadIsoMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadIntrMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadIntrMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadBlkMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadBlkMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadCtrlMsg(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_ReadCtrlMsgAsync(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIsoMsg(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIsoMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        bPackets: u8_,
        rpPacketSizes: *mut u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        userdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIntrMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteIntrMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteBlkMsg(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteBlkMsgAsync(
        fd: s32,
        bEndpoint: u8_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteCtrlMsg(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_WriteCtrlMsgAsync(
        fd: s32,
        bmRequestType: u8_,
        bmRequest: u8_,
        wValue: u16_,
        wIndex: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
        cb: usbcallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetConfiguration(fd: s32, configuration: *mut u8_) -> s32;
}
extern "C" {
    pub fn USB_SetConfiguration(fd: s32, configuration: u8_) -> s32;
}
extern "C" {
    pub fn USB_SetAlternativeInterface(fd: s32, interface: u8_, alternateSetting: u8_) -> s32;
}
extern "C" {
    pub fn USB_ClearHalt(fd: s32, endpointAddress: u8_) -> s32;
}
extern "C" {
    pub fn USB_GetDeviceList(
        descr_buffer: *mut usb_device_entry,
        num_descr: u8_,
        interface_class: u8_,
        cnt_descr: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn USB_GetAsciiString(
        fd: s32,
        bIndex: u8_,
        wLangID: u16_,
        wLength: u16_,
        rpData: *mut ::libc::c_void,
    ) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fstats {
    pub file_length: u32_,
    pub file_pos: u32_,
}
pub type fstats = _fstats;
pub type isfscallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn ISFS_Initialize() -> s32;
}
extern "C" {
    pub fn ISFS_Deinitialize() -> s32;
}
extern "C" {
    pub fn ISFS_Format() -> s32;
}
extern "C" {
    pub fn ISFS_FormatAsync(cb: isfscallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn ISFS_Open(filepath: *const ::libc::c_char, mode: u8_) -> s32;
}
extern "C" {
    pub fn ISFS_OpenAsync(
        filepath: *const ::libc::c_char,
        mode: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Close(fd: s32) -> s32;
}
extern "C" {
    pub fn ISFS_CloseAsync(fd: s32, cb: isfscallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn ISFS_Delete(filepath: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn ISFS_DeleteAsync(
        filepath: *const ::libc::c_char,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_ReadDir(
        filepath: *const ::libc::c_char,
        name_list: *mut ::libc::c_char,
        num: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_ReadDirAsync(
        filepath: *const ::libc::c_char,
        name_list: *mut ::libc::c_char,
        num: *mut u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateFile(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateFileAsync(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Write(fd: s32, buffer: *const ::libc::c_void, length: u32_) -> s32;
}
extern "C" {
    pub fn ISFS_WriteAsync(
        fd: s32,
        buffer: *const ::libc::c_void,
        length: u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Read(fd: s32, buffer: *mut ::libc::c_void, length: u32_) -> s32;
}
extern "C" {
    pub fn ISFS_ReadAsync(
        fd: s32,
        buffer: *mut ::libc::c_void,
        length: u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Seek(fd: s32, where_: s32, whence: s32) -> s32;
}
extern "C" {
    pub fn ISFS_SeekAsync(
        fd: s32,
        where_: s32,
        whence: s32,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateDir(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_CreateDirAsync(
        filepath: *const ::libc::c_char,
        attributes: u8_,
        owner_perm: u8_,
        group_perm: u8_,
        other_perm: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetStats(stats: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn ISFS_GetStatsAsync(
        stats: *mut ::libc::c_void,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetFileStats(fd: s32, status: *mut fstats) -> s32;
}
extern "C" {
    pub fn ISFS_GetFileStatsAsync(
        fd: s32,
        status: *mut fstats,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetAttr(
        filepath: *const ::libc::c_char,
        ownerID: *mut u32_,
        groupID: *mut u16_,
        attributes: *mut u8_,
        ownerperm: *mut u8_,
        groupperm: *mut u8_,
        otherperm: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetAttrAsync(
        filepath: *const ::libc::c_char,
        ownerID: *mut u32_,
        groupID: *mut u16_,
        attributes: *mut u8_,
        ownerperm: *mut u8_,
        groupperm: *mut u8_,
        otherperm: *mut u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_Rename(
        filepathOld: *const ::libc::c_char,
        filepathNew: *const ::libc::c_char,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_RenameAsync(
        filepathOld: *const ::libc::c_char,
        filepathNew: *const ::libc::c_char,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_SetAttr(
        filepath: *const ::libc::c_char,
        ownerID: u32_,
        groupID: u16_,
        attributes: u8_,
        ownerperm: u8_,
        groupperm: u8_,
        otherperm: u8_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_SetAttrAsync(
        filepath: *const ::libc::c_char,
        ownerID: u32_,
        groupID: u16_,
        attributes: u8_,
        ownerperm: u8_,
        groupperm: u8_,
        otherperm: u8_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetUsage(
        filepath: *const ::libc::c_char,
        usage1: *mut u32_,
        usage2: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn ISFS_GetUsageAsync(
        filepath: *const ::libc::c_char,
        usage1: *mut u32_,
        usage2: *mut u32_,
        cb: isfscallback,
        usrdata: *mut ::libc::c_void,
    ) -> s32;
}
pub const CONF_BIGARRAY: _bindgen_ty_2 = 1;
pub const CONF_SMALLARRAY: _bindgen_ty_2 = 2;
pub const CONF_BYTE: _bindgen_ty_2 = 3;
pub const CONF_SHORT: _bindgen_ty_2 = 4;
pub const CONF_LONG: _bindgen_ty_2 = 5;
pub const CONF_BOOL: _bindgen_ty_2 = 7;
pub type _bindgen_ty_2 = ::libc::c_uint;
pub const CONF_VIDEO_NTSC: _bindgen_ty_3 = 0;
pub const CONF_VIDEO_PAL: _bindgen_ty_3 = 1;
pub const CONF_VIDEO_MPAL: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::libc::c_uint;
pub const CONF_REGION_JP: _bindgen_ty_4 = 0;
pub const CONF_REGION_US: _bindgen_ty_4 = 1;
pub const CONF_REGION_EU: _bindgen_ty_4 = 2;
pub const CONF_REGION_KR: _bindgen_ty_4 = 4;
pub const CONF_REGION_CN: _bindgen_ty_4 = 5;
pub type _bindgen_ty_4 = ::libc::c_uint;
pub const CONF_AREA_JPN: _bindgen_ty_5 = 0;
pub const CONF_AREA_USA: _bindgen_ty_5 = 1;
pub const CONF_AREA_EUR: _bindgen_ty_5 = 2;
pub const CONF_AREA_AUS: _bindgen_ty_5 = 3;
pub const CONF_AREA_BRA: _bindgen_ty_5 = 4;
pub const CONF_AREA_TWN: _bindgen_ty_5 = 5;
pub const CONF_AREA_ROC: _bindgen_ty_5 = 6;
pub const CONF_AREA_KOR: _bindgen_ty_5 = 7;
pub const CONF_AREA_HKG: _bindgen_ty_5 = 8;
pub const CONF_AREA_ASI: _bindgen_ty_5 = 9;
pub const CONF_AREA_LTN: _bindgen_ty_5 = 10;
pub const CONF_AREA_SAF: _bindgen_ty_5 = 11;
pub const CONF_AREA_CHN: _bindgen_ty_5 = 12;
pub type _bindgen_ty_5 = ::libc::c_uint;
pub const CONF_SHUTDOWN_STANDBY: _bindgen_ty_6 = 0;
pub const CONF_SHUTDOWN_IDLE: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::libc::c_uint;
pub const CONF_LED_OFF: _bindgen_ty_7 = 0;
pub const CONF_LED_DIM: _bindgen_ty_7 = 1;
pub const CONF_LED_BRIGHT: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::libc::c_uint;
pub const CONF_SOUND_MONO: _bindgen_ty_8 = 0;
pub const CONF_SOUND_STEREO: _bindgen_ty_8 = 1;
pub const CONF_SOUND_SURROUND: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = ::libc::c_uint;
pub const CONF_LANG_JAPANESE: _bindgen_ty_9 = 0;
pub const CONF_LANG_ENGLISH: _bindgen_ty_9 = 1;
pub const CONF_LANG_GERMAN: _bindgen_ty_9 = 2;
pub const CONF_LANG_FRENCH: _bindgen_ty_9 = 3;
pub const CONF_LANG_SPANISH: _bindgen_ty_9 = 4;
pub const CONF_LANG_ITALIAN: _bindgen_ty_9 = 5;
pub const CONF_LANG_DUTCH: _bindgen_ty_9 = 6;
pub const CONF_LANG_SIMP_CHINESE: _bindgen_ty_9 = 7;
pub const CONF_LANG_TRAD_CHINESE: _bindgen_ty_9 = 8;
pub const CONF_LANG_KOREAN: _bindgen_ty_9 = 9;
pub type _bindgen_ty_9 = ::libc::c_uint;
pub const CONF_ASPECT_4_3: _bindgen_ty_10 = 0;
pub const CONF_ASPECT_16_9: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::libc::c_uint;
pub const CONF_SENSORBAR_BOTTOM: _bindgen_ty_11 = 0;
pub const CONF_SENSORBAR_TOP: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::libc::c_uint;
pub type conf_pad_device = _conf_pad_device;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _conf_pad_device {
    pub bdaddr: [u8_; 6usize],
    pub name: [::libc::c_char; 64usize],
}
pub type conf_pads = _conf_pads;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _conf_pads {
    pub num_registered: u8_,
    pub registered: [conf_pad_device; 10usize],
    pub active: [conf_pad_device; 4usize],
    pub balance_board: conf_pad_device,
    pub unknown: conf_pad_device,
}
extern "C" {
    pub fn CONF_Init() -> s32;
}
extern "C" {
    pub fn CONF_GetLength(name: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn CONF_GetType(name: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn CONF_Get(name: *const ::libc::c_char, buffer: *mut ::libc::c_void, length: u32_) -> s32;
}
extern "C" {
    pub fn CONF_GetShutdownMode() -> s32;
}
extern "C" {
    pub fn CONF_GetIdleLedMode() -> s32;
}
extern "C" {
    pub fn CONF_GetProgressiveScan() -> s32;
}
extern "C" {
    pub fn CONF_GetEuRGB60() -> s32;
}
extern "C" {
    pub fn CONF_GetIRSensitivity() -> s32;
}
extern "C" {
    pub fn CONF_GetSensorBarPosition() -> s32;
}
extern "C" {
    pub fn CONF_GetPadSpeakerVolume() -> s32;
}
extern "C" {
    pub fn CONF_GetPadMotorMode() -> s32;
}
extern "C" {
    pub fn CONF_GetSoundMode() -> s32;
}
extern "C" {
    pub fn CONF_GetLanguage() -> s32;
}
extern "C" {
    pub fn CONF_GetCounterBias(bias: *mut u32_) -> s32;
}
extern "C" {
    pub fn CONF_GetScreenSaverMode() -> s32;
}
extern "C" {
    pub fn CONF_GetDisplayOffsetH(offset: *mut s8) -> s32;
}
extern "C" {
    pub fn CONF_GetPadDevices(pads: *mut conf_pads) -> s32;
}
extern "C" {
    pub fn CONF_GetNickName(nickname: *mut u8_) -> s32;
}
extern "C" {
    pub fn CONF_GetAspectRatio() -> s32;
}
extern "C" {
    pub fn CONF_GetEULA() -> s32;
}
extern "C" {
    pub fn CONF_GetParentalPassword(password: *mut s8) -> s32;
}
extern "C" {
    pub fn CONF_GetParentalAnswer(answer: *mut s8) -> s32;
}
extern "C" {
    pub fn CONF_GetWiiConnect24() -> s32;
}
extern "C" {
    pub fn CONF_GetRegion() -> s32;
}
extern "C" {
    pub fn CONF_GetArea() -> s32;
}
extern "C" {
    pub fn CONF_GetVideo() -> s32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbstorage_handle {
    pub configuration: u8_,
    pub interface: u32_,
    pub altInterface: u32_,
    pub bInterfaceSubClass: u8_,
    pub ep_in: u8_,
    pub ep_out: u8_,
    pub max_lun: u8_,
    pub sector_size: *mut u32_,
    pub usb_fd: s32,
    pub lock: mutex_t,
    pub alarm: syswd_t,
    pub retval: s32,
    pub tag: u32_,
    pub suspended: u8_,
    pub buffer: *mut u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_device_command {
    pub command: [u8; 16usize],
    pub command_length: u8,
    pub flags: u8,
    pub scsi_status: u8,
    pub data: *mut ::libc::c_void,
    pub data_length: usize,
}
extern "C" {
    pub fn USBStorage_Initialize() -> s32;
}
extern "C" {
    pub fn USBStorage_Deinitialize();
}
extern "C" {
    pub fn USBStorage_Open(
        dev: *mut usbstorage_handle,
        device_id: s32,
        vid: u16_,
        pid: u16_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_Close(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_Reset(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_GetMaxLUN(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_MountLUN(dev: *mut usbstorage_handle, lun: u8_) -> s32;
}
extern "C" {
    pub fn USBStorage_Suspend(dev: *mut usbstorage_handle) -> s32;
}
extern "C" {
    pub fn USBStorage_IsDVD() -> s32;
}
extern "C" {
    pub fn USBStorage_ioctl(request: ::libc::c_int, ...) -> s32;
}
extern "C" {
    pub fn USBStorage_ReadCapacity(
        dev: *mut usbstorage_handle,
        lun: u8_,
        sector_size: *mut u32_,
        n_sectors: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_Read(
        dev: *mut usbstorage_handle,
        lun: u8_,
        sector: u32_,
        n_sectors: u16_,
        buffer: *mut u8_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_Write(
        dev: *mut usbstorage_handle,
        lun: u8_,
        sector: u32_,
        n_sectors: u16_,
        buffer: *const u8_,
    ) -> s32;
}
extern "C" {
    pub fn USBStorage_StartStop(
        dev: *mut usbstorage_handle,
        lun: u8_,
        lo_ej: u8_,
        start: u8_,
        imm: u8_,
    ) -> s32;
}
extern "C" {
    pub static mut __io_usbstorage: DISC_INTERFACE;
}
extern "C" {
    pub fn WII_Initialize() -> s32;
}
extern "C" {
    pub fn WII_ReturnToMenu() -> s32;
}
extern "C" {
    pub fn WII_ReturnToSettings() -> s32;
}
extern "C" {
    pub fn WII_ReturnToSettingsPage(page: *const ::libc::c_char) -> s32;
}
extern "C" {
    pub fn WII_LaunchTitle(titleID: u64_) -> s32;
}
extern "C" {
    pub fn WII_LaunchTitleWithArgs(titleID: u64_, launchcode: ::libc::c_int, ...) -> s32;
}
extern "C" {
    pub fn WII_OpenURL(url: *const ::libc::c_char) -> s32;
}
extern "C" {
    #[doc = "api_doc Detailed API description\n\n - aram.h \"ARAM subsystem\"\n - arqmgr.h \"ARAM queue management subsystem\"\n - audio.h \"AUDIO subsystem\"\n - asndlib.h \"ASND library\"\n - exi.h \"EXI subsystem\"\n - irq.h \"IRQ subsystem\"\n - dsp.h \"DSP subsystem\"\n - dvd.h \"DVD subsystem\"\n - gx.h \"GX subsystem\"\n - gu.h \"gu/Matrix subsystem\"\n - video.h \"VIDEO subsystem\"\n - cache.h \"Cache subsystem\"\n - card.h \"Memory card subsystem\"\n - consol.h \"Console subsystem\"\n - system.h \"OS functions and initialization\"\n - lwp.h \"Thread subsystem I\"\n - message.h \"Thread subsystem II\"\n - mutex.h \"Thread subsystem III\"\n - semaphore.h \"Thread subsystem IV\"\n - cond.h \"Thread subsystem V\""]
    pub fn depackrnc1_ulen(packed: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn depackrnc1(packed: *mut ::libc::c_void, unpacked: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn depackrnc2(packed: *mut ::libc::c_void, unpacked: *mut ::libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
extern "C" {
    pub fn utimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::libc::c_int, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::libc::c_int, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::libc::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: u8_,
    pub sin_family: u8_,
    pub sin_port: u16_,
    pub sin_addr: in_addr,
    pub sin_zero: [s8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8_,
    pub sa_family: u8_,
    pub sa_data: [s8; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::libc::c_char,
    pub h_aliases: *mut *mut ::libc::c_char,
    pub h_addrtype: u16_,
    pub h_length: u16_,
    pub h_addr_list: *mut *mut ::libc::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollsd {
    pub socket: s32,
    pub events: u32_,
    pub revents: u32_,
}
extern "C" {
    pub fn inet_addr(cp: *const ::libc::c_char) -> u32_;
}
extern "C" {
    pub fn inet_aton(cp: *const ::libc::c_char, addr: *mut in_addr) -> s8;
}
extern "C" {
    pub fn inet_ntoa(addr: in_addr) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn if_config(
        local_ip: *mut ::libc::c_char,
        netmask: *mut ::libc::c_char,
        gateway: *mut ::libc::c_char,
        use_dhcp: bool,
        max_retries: ::libc::c_int,
    ) -> s32;
}
extern "C" {
    pub fn if_configex(
        local_ip: *mut in_addr,
        netmask: *mut in_addr,
        gateway: *mut in_addr,
        use_dhcp: bool,
        max_retries: ::libc::c_int,
    ) -> s32;
}
extern "C" {
    pub fn net_init() -> s32;
}
pub type netcallback =
    ::core::option::Option<unsafe extern "C" fn(result: s32, usrdata: *mut ::libc::c_void) -> s32>;
extern "C" {
    pub fn net_init_async(cb: netcallback, usrdata: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn net_get_status() -> s32;
}
extern "C" {
    pub fn net_wc24cleanup();
}
extern "C" {
    pub fn net_get_mac_address(mac_buf: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn net_deinit();
}
extern "C" {
    pub fn net_gethostip() -> u32_;
}
extern "C" {
    pub fn net_socket(domain: u32_, type_: u32_, protocol: u32_) -> s32;
}
extern "C" {
    pub fn net_bind(s: s32, name: *mut sockaddr, namelen: u32_) -> s32;
}
extern "C" {
    pub fn net_listen(s: s32, backlog: u32_) -> s32;
}
extern "C" {
    pub fn net_accept(s: s32, addr: *mut sockaddr, addrlen: *mut u32_) -> s32;
}
extern "C" {
    pub fn net_connect(s: s32, arg1: *mut sockaddr, arg2: u32_) -> s32;
}
extern "C" {
    pub fn net_write(s: s32, data: *const ::libc::c_void, size: s32) -> s32;
}
extern "C" {
    pub fn net_send(s: s32, data: *const ::libc::c_void, size: s32, flags: u32_) -> s32;
}
extern "C" {
    pub fn net_sendto(
        s: s32,
        data: *const ::libc::c_void,
        len: s32,
        flags: u32_,
        to: *mut sockaddr,
        tolen: u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_recv(s: s32, mem: *mut ::libc::c_void, len: s32, flags: u32_) -> s32;
}
extern "C" {
    pub fn net_recvfrom(
        s: s32,
        mem: *mut ::libc::c_void,
        len: s32,
        flags: u32_,
        from: *mut sockaddr,
        fromlen: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_read(s: s32, mem: *mut ::libc::c_void, len: s32) -> s32;
}
extern "C" {
    pub fn net_close(s: s32) -> s32;
}
extern "C" {
    pub fn net_select(
        maxfdp1: s32,
        readset: *mut fd_set,
        writeset: *mut fd_set,
        exceptset: *mut fd_set,
        timeout: *mut timeval,
    ) -> s32;
}
extern "C" {
    pub fn net_getsockopt(
        s: s32,
        level: u32_,
        optname: u32_,
        optval: *const ::libc::c_void,
        optlen: u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_setsockopt(
        s: s32,
        level: u32_,
        optname: u32_,
        optval: *const ::libc::c_void,
        optlen: u32_,
    ) -> s32;
}
extern "C" {
    pub fn net_getsockname(s: s32, addr: *mut sockaddr, addrlen: *mut u32_) -> s32;
}
extern "C" {
    pub fn net_ioctl(s: s32, cmd: u32_, argp: *mut ::libc::c_void) -> s32;
}
extern "C" {
    pub fn net_fcntl(s: s32, cmd: u32_, flags: u32_) -> s32;
}
extern "C" {
    pub fn net_poll(sds: *mut pollsd, nsds: s32, timeout: s32) -> s32;
}
extern "C" {
    pub fn net_shutdown(s: s32, how: u32_) -> s32;
}
extern "C" {
    pub fn net_gethostbyname(addrString: *const ::libc::c_char) -> *mut hostent;
}
extern "C" {
    pub static mut tcp_localip: *const ::libc::c_char;
}
extern "C" {
    pub static mut tcp_netmask: *const ::libc::c_char;
}
extern "C" {
    pub static mut tcp_gateway: *const ::libc::c_char;
}
extern "C" {
    #[doc = "void _break()\n Stub function to insert the hardware break instruction. This function is used to enter the debug stub and to\n connect with the host. The developer is free to insert this function at any position in project's source code.\n\n # Returns\n\nnone."]
    pub fn _break();
}
extern "C" {
    #[doc = "void DEBUG_Init(s32 device_type,s32 channel_port)\n Performs the initialization of the debug stub.\n # Arguments\n\n* `device_type` (direction in) - type of device to use. can be either USB or TCP.\n * `channel_port` (direction in) - depending on the used device this can be either the EXI channel or the TCP port.\n\n # Returns\n\nnone."]
    pub fn DEBUG_Init(device_type: s32, channel_port: s32);
}
pub const NOTE_DO: _bindgen_ty_12 = 0;
pub const NOTE_DOs: _bindgen_ty_12 = 1;
pub const NOTE_REb: _bindgen_ty_12 = 1;
pub const NOTE_RE: _bindgen_ty_12 = 2;
pub const NOTE_REs: _bindgen_ty_12 = 3;
pub const NOTE_MIb: _bindgen_ty_12 = 3;
pub const NOTE_MI: _bindgen_ty_12 = 4;
pub const NOTE_FA: _bindgen_ty_12 = 5;
pub const NOTE_FAs: _bindgen_ty_12 = 6;
pub const NOTE_SOLb: _bindgen_ty_12 = 6;
pub const NOTE_SOL: _bindgen_ty_12 = 7;
pub const NOTE_SOLs: _bindgen_ty_12 = 8;
pub const NOTE_LAb: _bindgen_ty_12 = 8;
pub const NOTE_LA: _bindgen_ty_12 = 9;
pub const NOTE_LAs: _bindgen_ty_12 = 10;
pub const NOTE_SIb: _bindgen_ty_12 = 10;
pub const NOTE_SI: _bindgen_ty_12 = 11;
#[doc = "notecode Note codification\n # "]
pub type _bindgen_ty_12 = ::libc::c_uint;
pub const NOTE_C: _bindgen_ty_13 = 0;
pub const NOTE_Cs: _bindgen_ty_13 = 1;
pub const NOTE_Db: _bindgen_ty_13 = 1;
pub const NOTE_D: _bindgen_ty_13 = 2;
pub const NOTE_Ds: _bindgen_ty_13 = 3;
pub const NOTE_Eb: _bindgen_ty_13 = 3;
pub const NOTE_E: _bindgen_ty_13 = 4;
pub const NOTE_F: _bindgen_ty_13 = 5;
pub const NOTE_Fs: _bindgen_ty_13 = 6;
pub const NOTE_Gb: _bindgen_ty_13 = 6;
pub const NOTE_G: _bindgen_ty_13 = 7;
pub const NOTE_Gs: _bindgen_ty_13 = 8;
pub const NOTE_Ab: _bindgen_ty_13 = 8;
pub const NOTE_A: _bindgen_ty_13 = 9;
pub const NOTE_As: _bindgen_ty_13 = 10;
pub const NOTE_Bb: _bindgen_ty_13 = 10;
pub const NOTE_B: _bindgen_ty_13 = 11;
pub type _bindgen_ty_13 = ::libc::c_uint;
#[doc = "Callback type for ASND_SetVoice()."]
pub type ASNDVoiceCallback = ::core::option::Option<unsafe extern "C" fn(voice: s32)>;
extern "C" {
    #[doc = "Initializes the SND lib and fixes the hardware sample rate.\n # Arguments\n\n* `note` (direction in) - notecode to play. for example: NOTE(C,4) for note C and octave 4.\n * `freq_base` (direction in) - Frequency base of the sample. For example 8000Hz.\n * `note_base` (direction in) - notecode of the sample. For example: NOTE(L, 3) for note L and octave 3 (LA 3).\n # Returns\n\nFrequency, in Hz."]
    pub fn ANote2Freq(
        note: ::libc::c_int,
        freq_base: ::libc::c_int,
        note_base: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Initializes the ASND lib and fixes the hardware sample rate to 48000.\n # Returns\n\nNone."]
    pub fn ASND_Init();
}
extern "C" {
    #[doc = "De-initializes the ASND lib.\n # Returns\n\nNone."]
    pub fn ASND_End();
}
extern "C" {
    #[doc = "Used to pause (or unpause) the sound.\n > **Note:** The sound starts paused when ASND_Init() is called.\n # Arguments\n\n* `paused` (direction in) - If 1, sound is paused; sound can be unpaused with 0.\n # Returns\n\nNone."]
    pub fn ASND_Pause(paused: s32);
}
extern "C" {
    #[doc = "Returns sound paused status.\n # Returns\n\n1 if paused, 0 if unpaused."]
    pub fn ASND_Is_Paused() -> s32;
}
extern "C" {
    #[doc = "Returns the global time.\n \n\nThe time is updated from the IRQ.\n # Returns\n\nThe current time, in milliseconds."]
    pub fn ASND_GetTime() -> u32_;
}
extern "C" {
    #[doc = "Retrieves the global sample counter.\n \n\nThis counter is updated from the IRQ in steps of ASND_GetSamplesPerTick().\n > **Note:** You can use this to implement one timer with high precision.\n # Returns\n\nCurrent sample."]
    pub fn ASND_GetSampleCounter() -> u32_;
}
extern "C" {
    #[doc = "Retrieves the samples sent from the IRQ in one tick.\n # Returns\n\nSamples per tick."]
    pub fn ASND_GetSamplesPerTick() -> u32_;
}
extern "C" {
    #[doc = "Set the global time.\n \n\nThis time is updated from the IRQ.\n # Arguments\n\n* `time` (direction in) - Fix the current time, in milliseconds.\n # Returns\n\nNone."]
    pub fn ASND_SetTime(time: u32_);
}
extern "C" {
    #[doc = "Sets a global callback for general purposes.\n \n\nThis callback is called from the IRQ.\n # Arguments\n\n* `callback` (direction in) - Callback function to assign.\n # Returns\n\nNone."]
    pub fn ASND_SetCallback(callback: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = "Returns the current audio rate.\n > **Note:** This function is implemented for compatibility with SNDLIB.\n # Returns\n\nAudio rate (48000)."]
    pub fn ASND_GetAudioRate() -> s32;
}
extern "C" {
    #[doc = "Sets a PCM voice to play.\n \n\nThis function stops one previous voice. Use ASND_StatusVoice() to test the status condition.\n > **Note:** The voices are played in 16-bit stereo, regardless of the source format.<br><br>\n\n > **Note:** _callback_ is used to implement a double buffer. When the second buffer is empty, the callback function is called with the voice number\n as an argument. You can use <tt>void <i>callback</i> (s32 voice)</tt> to call ASND_AddVoice() and add one voice to the second buffer. When the callback\n is non-NULL the, the voice never stops and returns SND_WAITING if successful on timeout condition.\n # Arguments\n\n* `voice` (direction in) - Voice slot to use for this sound; valid values are 0 to (MAX_SND_VOICES-1).\n * `format` (direction in) - sndsetvoiceformats to use for this sound.\n * `pitch` (direction in) - Frequency to use, in Hz.\n * `delay` (direction in) - Delay to wait before playing this voice; value is in milliseconds.\n * `snd` (direction in) - Buffer containing samples to play back; the buffer <b>must</b> be aligned and padded to 32 bytes!\n * `size_snd` (direction in) - Size of the buffer samples, in bytes.\n * `volume_l` (direction in) - voicevol of the left channel; value can be 0 - 255 inclusive.\n * `volume_r` (direction in) - voicevol of the right channel; value can be 0 - 255 inclusive.\n * `callback` (direction in) - Optional callback function to use; set to NULL for no callback. See the note above for details.\n # Returns\n\nSND_OK or SND_INVALID."]
    pub fn ASND_SetVoice(
        voice: s32,
        format: s32,
        pitch: s32,
        delay: s32,
        snd: *mut ::libc::c_void,
        size_snd: s32,
        volume_l: s32,
        volume_r: s32,
        callback: ASNDVoiceCallback,
    ) -> s32;
}
extern "C" {
    #[doc = "Sets a PCM voice to play infinitely.\n > **Note:** See ASND_SetVoice() for a detailed description, as it is largely identical."]
    pub fn ASND_SetInfiniteVoice(
        voice: s32,
        format: s32,
        pitch: s32,
        delay: s32,
        snd: *mut ::libc::c_void,
        size_snd: s32,
        volume_l: s32,
        volume_r: s32,
    ) -> s32;
}
extern "C" {
    #[doc = "Adds a PCM voice to play from the second buffer.\n > **Note:** This function requires a call to ASND_SetVoice() and its subsequent return value to be a status other than SND_UNUSED prior to calling this one.\n # Arguments\n\n* `voice` (direction in) - Voice slot to attach this buffer to; value must be 0 to (MAX_SND_VOICES-1).\n * `snd` (direction in) - Buffer containing the samples; it <b>must</b> be aligned and padded to 32 bytes AND have the same sample format as the first buffer.\n * `size_snd` (direction in) - Size of the buffer samples, in bytes.\n # Returns\n\nSND_OK or SND_INVALID; it may also return SND_BUSY if the second buffer is not empty and the voice cannot be added."]
    pub fn ASND_AddVoice(voice: s32, snd: *mut ::libc::c_void, size_snd: s32) -> s32;
}
extern "C" {
    #[doc = "Stops the selected voice.\n \n\nIf the voice is used in song mode, you need to assign the samples with ASND_SetSongSampleVoice() again. In this case, use ANS_PauseSongVoice()\n to stop the voice without loss of samples.\n # Arguments\n\n* `voice` (direction in) - Voice to stop, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nSND_OK or SND_INVALID."]
    pub fn ASND_StopVoice(voice: s32) -> s32;
}
extern "C" {
    #[doc = "Pauses the selected voice.\n # Arguments\n\n* `voice` (direction in) - Voice to pause, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nSND_OK or SND_INVALID."]
    pub fn ASND_PauseVoice(voice: s32, pause: s32) -> s32;
}
extern "C" {
    #[doc = "Returns the status of the selected voice.\n # Arguments\n\n* `voice` (direction in) - Voice slot to get the status from, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nSND_INVALID if invalid, else a value from sndiavretvals."]
    pub fn ASND_StatusVoice(voice: s32) -> s32;
}
extern "C" {
    #[doc = "Returns the first unused voice.\n > **Note:** Voice 0 is the last possible voice that can be returned. The idea is that this voice is reserved for a MOD/OGG/MP3/etc. player. With this in mind,\n you can use this function to determine that the rest of the voices are working if the return value is < 1.\n # Returns\n\nSND_INVALID or the first free voice from 0 to (MAX_SND_VOICES-1)."]
    pub fn ASND_GetFirstUnusedVoice() -> s32;
}
extern "C" {
    #[doc = "Changes the voice pitch in real-time.\n \n\nThis function can be used to create audio effects such as Doppler effect emulation.\n # Arguments\n\n* `voice` (direction in) - Voice to change the pitch of, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nSND_OK or SND_INVALID."]
    pub fn ASND_ChangePitchVoice(voice: s32, pitch: s32) -> s32;
}
extern "C" {
    #[doc = "Changes the voice volume in real-time.\n \n\nThis function can be used to create audio effects like distance attenuation.\n # Arguments\n\n* `voice` (direction in) - Voice to change the volume of, from 0 to (MAX_SND_VOICES-1).\n * `volume_l` (direction in) - voicevol to set the left channel to, from 0 to 255.\n * `volume_r` (direction in) - voicevol to set the right channel to, from 0 to 255.\n # Returns\n\nSND_OK or SND_INVALID."]
    pub fn ASND_ChangeVolumeVoice(voice: s32, volume_l: s32, volume_r: s32) -> s32;
}
extern "C" {
    #[doc = "Returns the voice tick counter.\n \n\nThis value represents the number of ticks since this voice started to play, sans delay time. It uses the same resolution as the internal\n sound buffer. For example, if the lib is initialized with INIT_RATE_48000, a return value of 24000 is equal to 0.5 seconds. This value can be used, for\n example, to synchronize audio and video.\n > **Note:** This function does not return error codes.\n # Arguments\n\n* `voice` (direction in) - Voice to retrieve the counter value from, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nNumber of ticks since this voice started playing."]
    pub fn ASND_GetTickCounterVoice(voice: s32) -> u32_;
}
extern "C" {
    #[doc = "Returns the voice playback time.\n \n\nThis value represents the time, in milliseconds, since this voice started playing, sans delay time. This value can be used, for example, to\n synchronize audio and video.\n > **Note:** This function does not return error codes.\n # Arguments\n\n* `voice` (direction in) - Voice to retrieve the time value from, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nAmount of time since this voice has started playing."]
    pub fn ASND_GetTimerVoice(voice: s32) -> u32_;
}
extern "C" {
    #[doc = "Tests if _pointer_ is in use by _voice_ as a buffer.\n # Arguments\n\n* `voice` (direction in) - Voice to test, from 0 to (MAX_SND_VOICES-1).\n * `pointer` (direction in) - Address to test. This must be the same pointer sent to ASND_AddVoice() or ASND_SetVoice().\n # Returns\n\nSND_INVALID if invalid\n 0 if the pointer is unused\n 1 if the pointer used as a buffer."]
    pub fn ASND_TestPointer(voice: s32, pointer: *mut ::libc::c_void) -> s32;
}
extern "C" {
    #[doc = "Tests to determine if the _voice_ is ready to receive a new buffer sample with ASND_AddVoice().\n \n\nYou can use this function to block a reader when double buffering is used. It works similarly to ASND_TestPointer() without needing to pass a\n pointer.\n # Arguments\n\n* `voice` (direction in) - Voice to test, from 0 to (MAX_SND_VOICES-1).\n # Returns\n\nSND_INVALID\n 0 if voice is NOT ready to receive a new voice.\n 1 if voice is ready to receive a new voice with ASND_AddVoice()."]
    pub fn ASND_TestVoiceBufferReady(voice: s32) -> s32;
}
extern "C" {
    #[doc = "Returns the DSP usage.\n \n\nThe value is a percentage of DSP usage.\n # Returns\n\nDSP usage, in percent."]
    pub fn ASND_GetDSP_PercentUse() -> u32_;
}
extern "C" {
    pub fn ASND_GetDSP_ProcessTime() -> u32_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aesndpb_t {
    _unused: [u8; 0],
}
pub type AESNDPB = aesndpb_t;
pub type AESNDVoiceCallbackArg = ::core::option::Option<
    unsafe extern "C" fn(pb: *mut AESNDPB, state: u32_, cbArg: *mut ::libc::c_void),
>;
pub type AESNDVoiceCallback =
    ::core::option::Option<unsafe extern "C" fn(pb: *mut AESNDPB, state: u32_)>;
pub type AESNDAudioCallbackArg = ::core::option::Option<
    unsafe extern "C" fn(audio_buffer: *mut ::libc::c_void, len: u32_, cbArg: *mut ::libc::c_void),
>;
pub type AESNDAudioCallback =
    ::core::option::Option<unsafe extern "C" fn(audio_buffer: *mut ::libc::c_void, len: u32_)>;
extern "C" {
    pub fn AESND_Init();
}
extern "C" {
    pub fn AESND_Reset();
}
extern "C" {
    pub fn AESND_Pause(pause: bool);
}
extern "C" {
    pub fn AESND_GetDSPProcessTime() -> u32_;
}
extern "C" {
    pub fn AESND_GetDSPProcessUsage() -> f32_;
}
extern "C" {
    pub fn AESND_RegisterAudioCallbackWithArg(
        cb: AESNDAudioCallbackArg,
        cbArg: *mut ::libc::c_void,
    ) -> AESNDAudioCallbackArg;
}
extern "C" {
    pub fn AESND_AllocateVoiceWithArg(
        cb: AESNDVoiceCallbackArg,
        cbArg: *mut ::libc::c_void,
    ) -> *mut AESNDPB;
}
extern "C" {
    pub fn AESND_FreeVoice(pb: *mut AESNDPB);
}
extern "C" {
    pub fn AESND_SetVoiceStop(pb: *mut AESNDPB, stop: bool);
}
extern "C" {
    pub fn AESND_SetVoiceMute(pb: *mut AESNDPB, mute: bool);
}
extern "C" {
    pub fn AESND_SetVoiceLoop(pb: *mut AESNDPB, loop_: bool);
}
extern "C" {
    pub fn AESND_SetVoiceFormat(pb: *mut AESNDPB, format: u32_);
}
extern "C" {
    pub fn AESND_SetVoiceStream(pb: *mut AESNDPB, stream: bool);
}
extern "C" {
    pub fn AESND_SetVoiceFrequency(pb: *mut AESNDPB, freq: f32_);
}
extern "C" {
    pub fn AESND_SetVoiceVolume(pb: *mut AESNDPB, volume_l: u16_, volume_r: u16_);
}
extern "C" {
    pub fn AESND_SetVoiceDelay(pb: *mut AESNDPB, delay: u32_);
}
extern "C" {
    pub fn AESND_SetVoiceBuffer(pb: *mut AESNDPB, buffer: *const ::libc::c_void, len: u32_);
}
extern "C" {
    pub fn AESND_PlayVoice(
        pb: *mut AESNDPB,
        format: u32_,
        buffer: *const ::libc::c_void,
        len: u32_,
        freq: f32_,
        delay: u32_,
        looped: bool,
    );
}
extern "C" {
    pub fn AESND_RegisterVoiceCallbackWithArg(
        pb: *mut AESNDPB,
        cb: AESNDVoiceCallbackArg,
        cbArg: *mut ::libc::c_void,
    ) -> AESNDVoiceCallbackArg;
}
extern "C" {
    pub static mad_version: [s8; 0usize];
}
extern "C" {
    pub static mad_copyright: [s8; 0usize];
}
extern "C" {
    pub static mad_author: [s8; 0usize];
}
extern "C" {
    pub static mad_build: [s8; 0usize];
}
pub type mad_fixed_t = s32;
pub type mad_fixed64hi_t = s32;
pub type mad_fixed64lo_t = u32_;
pub type mad_sample_t = mad_fixed_t;
extern "C" {
    pub fn mad_f_abs(arg1: mad_fixed_t) -> mad_fixed_t;
}
extern "C" {
    pub fn mad_f_div(arg1: mad_fixed_t, arg2: mad_fixed_t) -> mad_fixed_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_bitptr {
    pub byte: *const u8_,
    pub cache: u16_,
    pub left: u16_,
}
extern "C" {
    pub fn mad_bit_init(arg1: *mut mad_bitptr, arg2: *const u8_);
}
extern "C" {
    pub fn mad_bit_length(arg1: *const mad_bitptr, arg2: *const mad_bitptr) -> u32_;
}
extern "C" {
    pub fn mad_bit_nextbyte(arg1: *const mad_bitptr) -> *const u8_;
}
extern "C" {
    pub fn mad_bit_skip(arg1: *mut mad_bitptr, arg2: u32_);
}
extern "C" {
    pub fn mad_bit_read(arg1: *mut mad_bitptr, arg2: u32_) -> u32_;
}
extern "C" {
    pub fn mad_bit_write(arg1: *mut mad_bitptr, arg2: u32_, arg3: u32_);
}
extern "C" {
    pub fn mad_bit_crc(arg1: mad_bitptr, arg2: u32_, arg3: u16_) -> u16_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_timer_t {
    pub seconds: ::libc::c_long,
    pub fraction: u32_,
}
extern "C" {
    pub static mad_timer_zero: mad_timer_t;
}
pub const MAD_UNITS_HOURS: mad_units = -2;
pub const MAD_UNITS_MINUTES: mad_units = -1;
pub const MAD_UNITS_SECONDS: mad_units = 0;
pub const MAD_UNITS_DECISECONDS: mad_units = 10;
pub const MAD_UNITS_CENTISECONDS: mad_units = 100;
pub const MAD_UNITS_MILLISECONDS: mad_units = 1000;
pub const MAD_UNITS_8000_HZ: mad_units = 8000;
pub const MAD_UNITS_11025_HZ: mad_units = 11025;
pub const MAD_UNITS_12000_HZ: mad_units = 12000;
pub const MAD_UNITS_16000_HZ: mad_units = 16000;
pub const MAD_UNITS_22050_HZ: mad_units = 22050;
pub const MAD_UNITS_24000_HZ: mad_units = 24000;
pub const MAD_UNITS_32000_HZ: mad_units = 32000;
pub const MAD_UNITS_44100_HZ: mad_units = 44100;
pub const MAD_UNITS_48000_HZ: mad_units = 48000;
pub const MAD_UNITS_24_FPS: mad_units = 24;
pub const MAD_UNITS_25_FPS: mad_units = 25;
pub const MAD_UNITS_30_FPS: mad_units = 30;
pub const MAD_UNITS_48_FPS: mad_units = 48;
pub const MAD_UNITS_50_FPS: mad_units = 50;
pub const MAD_UNITS_60_FPS: mad_units = 60;
pub const MAD_UNITS_75_FPS: mad_units = 75;
pub const MAD_UNITS_23_976_FPS: mad_units = -24;
pub const MAD_UNITS_24_975_FPS: mad_units = -25;
pub const MAD_UNITS_29_97_FPS: mad_units = -30;
pub const MAD_UNITS_47_952_FPS: mad_units = -48;
pub const MAD_UNITS_49_95_FPS: mad_units = -50;
pub const MAD_UNITS_59_94_FPS: mad_units = -60;
pub type mad_units = ::libc::c_int;
extern "C" {
    pub fn mad_timer_compare(arg1: mad_timer_t, arg2: mad_timer_t) -> s32;
}
extern "C" {
    pub fn mad_timer_negate(arg1: *mut mad_timer_t);
}
extern "C" {
    pub fn mad_timer_abs(arg1: mad_timer_t) -> mad_timer_t;
}
extern "C" {
    pub fn mad_timer_set(arg1: *mut mad_timer_t, arg2: u32_, arg3: u32_, arg4: u32_);
}
extern "C" {
    pub fn mad_timer_add(arg1: *mut mad_timer_t, arg2: mad_timer_t);
}
extern "C" {
    pub fn mad_timer_multiply(arg1: *mut mad_timer_t, arg2: ::libc::c_long);
}
extern "C" {
    pub fn mad_timer_count(arg1: mad_timer_t, arg2: mad_units) -> ::libc::c_long;
}
extern "C" {
    pub fn mad_timer_fraction(arg1: mad_timer_t, arg2: u32_) -> u32_;
}
extern "C" {
    pub fn mad_timer_string(
        arg1: mad_timer_t,
        arg2: *mut s8,
        arg3: *const s8,
        arg4: mad_units,
        arg5: mad_units,
        arg6: u32_,
    );
}
pub const MAD_ERROR_NONE: mad_error = 0;
pub const MAD_ERROR_BUFLEN: mad_error = 1;
pub const MAD_ERROR_BUFPTR: mad_error = 2;
pub const MAD_ERROR_NOMEM: mad_error = 49;
pub const MAD_ERROR_LOSTSYNC: mad_error = 257;
pub const MAD_ERROR_BADLAYER: mad_error = 258;
pub const MAD_ERROR_BADBITRATE: mad_error = 259;
pub const MAD_ERROR_BADSAMPLERATE: mad_error = 260;
pub const MAD_ERROR_BADEMPHASIS: mad_error = 261;
pub const MAD_ERROR_BADCRC: mad_error = 513;
pub const MAD_ERROR_BADBITALLOC: mad_error = 529;
pub const MAD_ERROR_BADSCALEFACTOR: mad_error = 545;
pub const MAD_ERROR_BADFRAMELEN: mad_error = 561;
pub const MAD_ERROR_BADBIGVALUES: mad_error = 562;
pub const MAD_ERROR_BADBLOCKTYPE: mad_error = 563;
pub const MAD_ERROR_BADSCFSI: mad_error = 564;
pub const MAD_ERROR_BADDATAPTR: mad_error = 565;
pub const MAD_ERROR_BADPART3LEN: mad_error = 566;
pub const MAD_ERROR_BADHUFFTABLE: mad_error = 567;
pub const MAD_ERROR_BADHUFFDATA: mad_error = 568;
pub const MAD_ERROR_BADSTEREO: mad_error = 569;
pub type mad_error = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_stream {
    pub buffer: *const u8_,
    pub bufend: *const u8_,
    pub skiplen: u32_,
    pub sync: s32,
    pub freerate: u32_,
    pub this_frame: *const u8_,
    pub next_frame: *const u8_,
    pub ptr: mad_bitptr,
    pub anc_ptr: mad_bitptr,
    pub anc_bitlen: u32_,
    pub main_data: *mut [u8_; 2567usize],
    pub md_len: u32_,
    pub options: s32,
    pub error: mad_error,
}
pub const MAD_OPTION_IGNORECRC: _bindgen_ty_14 = 1;
pub const MAD_OPTION_HALFSAMPLERATE: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::libc::c_uint;
extern "C" {
    pub fn mad_stream_init(arg1: *mut mad_stream);
}
extern "C" {
    pub fn mad_stream_finish(arg1: *mut mad_stream);
}
extern "C" {
    pub fn mad_stream_buffer(arg1: *mut mad_stream, arg2: *const u8_, arg3: u32_);
}
extern "C" {
    pub fn mad_stream_skip(arg1: *mut mad_stream, arg2: u32_);
}
extern "C" {
    pub fn mad_stream_sync(arg1: *mut mad_stream) -> s32;
}
extern "C" {
    pub fn mad_stream_errorstr(arg1: *const mad_stream) -> *const s8;
}
pub const MAD_LAYER_I: mad_layer = 1;
pub const MAD_LAYER_II: mad_layer = 2;
pub const MAD_LAYER_III: mad_layer = 3;
pub type mad_layer = ::libc::c_uint;
pub const MAD_MODE_SINGLE_CHANNEL: mad_mode = 0;
pub const MAD_MODE_DUAL_CHANNEL: mad_mode = 1;
pub const MAD_MODE_JOINT_STEREO: mad_mode = 2;
pub const MAD_MODE_STEREO: mad_mode = 3;
pub type mad_mode = ::libc::c_uint;
pub const MAD_EMPHASIS_NONE: mad_emphasis = 0;
pub const MAD_EMPHASIS_50_15_US: mad_emphasis = 1;
pub const MAD_EMPHASIS_CCITT_J_17: mad_emphasis = 3;
pub const MAD_EMPHASIS_RESERVED: mad_emphasis = 2;
pub type mad_emphasis = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_header {
    pub layer: mad_layer,
    pub mode: mad_mode,
    pub mode_extension: s32,
    pub emphasis: mad_emphasis,
    pub bitrate: u32_,
    pub samplerate: u32_,
    pub crc_check: u16_,
    pub crc_target: u16_,
    pub flags: s32,
    pub private_bits: s32,
    pub duration: mad_timer_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_frame {
    pub header: mad_header,
    pub options: s32,
    pub sbsample: [[[mad_fixed_t; 32usize]; 36usize]; 2usize],
    pub overlap: *mut [[[mad_fixed_t; 18usize]; 32usize]; 2usize],
}
pub const MAD_FLAG_NPRIVATE_III: _bindgen_ty_15 = 7;
pub const MAD_FLAG_INCOMPLETE: _bindgen_ty_15 = 8;
pub const MAD_FLAG_PROTECTION: _bindgen_ty_15 = 16;
pub const MAD_FLAG_COPYRIGHT: _bindgen_ty_15 = 32;
pub const MAD_FLAG_ORIGINAL: _bindgen_ty_15 = 64;
pub const MAD_FLAG_PADDING: _bindgen_ty_15 = 128;
pub const MAD_FLAG_I_STEREO: _bindgen_ty_15 = 256;
pub const MAD_FLAG_MS_STEREO: _bindgen_ty_15 = 512;
pub const MAD_FLAG_FREEFORMAT: _bindgen_ty_15 = 1024;
pub const MAD_FLAG_LSF_EXT: _bindgen_ty_15 = 4096;
pub const MAD_FLAG_MC_EXT: _bindgen_ty_15 = 8192;
pub const MAD_FLAG_MPEG_2_5_EXT: _bindgen_ty_15 = 16384;
pub type _bindgen_ty_15 = ::libc::c_uint;
pub const MAD_PRIVATE_HEADER: _bindgen_ty_16 = 256;
pub const MAD_PRIVATE_III: _bindgen_ty_16 = 31;
pub type _bindgen_ty_16 = ::libc::c_uint;
extern "C" {
    pub fn mad_header_init(arg1: *mut mad_header);
}
extern "C" {
    pub fn mad_header_decode(arg1: *mut mad_header, arg2: *mut mad_stream) -> s32;
}
extern "C" {
    pub fn mad_frame_init(arg1: *mut mad_frame);
}
extern "C" {
    pub fn mad_frame_finish(arg1: *mut mad_frame);
}
extern "C" {
    pub fn mad_frame_decode(arg1: *mut mad_frame, arg2: *mut mad_stream) -> s32;
}
extern "C" {
    pub fn mad_frame_mute(arg1: *mut mad_frame);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_pcm {
    pub samplerate: u32_,
    pub channels: u16_,
    pub length: u16_,
    pub samples: [[mad_fixed_t; 1152usize]; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_synth {
    pub filter: [[[[[mad_fixed_t; 8usize]; 16usize]; 2usize]; 2usize]; 2usize],
    pub phase: u32_,
    pub pcm: mad_pcm,
}
pub const MAD_PCM_CHANNEL_SINGLE: _bindgen_ty_17 = 0;
pub type _bindgen_ty_17 = ::libc::c_uint;
pub const MAD_PCM_CHANNEL_DUAL_1: _bindgen_ty_18 = 0;
pub const MAD_PCM_CHANNEL_DUAL_2: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::libc::c_uint;
pub const MAD_PCM_CHANNEL_STEREO_LEFT: _bindgen_ty_19 = 0;
pub const MAD_PCM_CHANNEL_STEREO_RIGHT: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::libc::c_uint;
extern "C" {
    pub fn mad_synth_init(arg1: *mut mad_synth);
}
extern "C" {
    pub fn mad_synth_mute(arg1: *mut mad_synth);
}
extern "C" {
    pub fn mad_synth_frame(arg1: *mut mad_synth, arg2: *const mad_frame);
}
pub const MAD_DECODER_MODE_SYNC: mad_decoder_mode = 0;
pub const MAD_DECODER_MODE_ASYNC: mad_decoder_mode = 1;
pub type mad_decoder_mode = ::libc::c_uint;
pub const MAD_FLOW_CONTINUE: mad_flow = 0;
pub const MAD_FLOW_STOP: mad_flow = 16;
pub const MAD_FLOW_BREAK: mad_flow = 17;
pub const MAD_FLOW_IGNORE: mad_flow = 32;
pub type mad_flow = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_decoder {
    pub mode: mad_decoder_mode,
    pub options: s32,
    pub async_: mad_decoder__bindgen_ty_1,
    pub sync: *mut mad_decoder__bindgen_ty_2,
    pub cb_data: *mut ::libc::c_void,
    pub input_func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *mut mad_stream) -> mad_flow,
    >,
    pub header_func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *const mad_header) -> mad_flow,
    >,
    pub filter_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *const mad_stream,
            arg3: *mut mad_frame,
        ) -> mad_flow,
    >,
    pub output_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *const mad_header,
            arg3: *mut mad_pcm,
        ) -> mad_flow,
    >,
    pub error_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *mut mad_stream,
            arg3: *mut mad_frame,
        ) -> mad_flow,
    >,
    pub message_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: *mut ::libc::c_void,
            arg3: *mut u32_,
        ) -> mad_flow,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_decoder__bindgen_ty_1 {
    pub pid: ::libc::c_long,
    pub in_: s32,
    pub out: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mad_decoder__bindgen_ty_2 {
    pub stream: mad_stream,
    pub frame: mad_frame,
    pub synth: mad_synth,
}
extern "C" {
    pub fn mad_decoder_init(
        arg1: *mut mad_decoder,
        arg2: *mut ::libc::c_void,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *mut mad_stream) -> mad_flow,
        >,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *const mad_header) -> mad_flow,
        >,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const mad_stream,
                arg3: *mut mad_frame,
            ) -> mad_flow,
        >,
        arg6: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const mad_header,
                arg3: *mut mad_pcm,
            ) -> mad_flow,
        >,
        arg7: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *mut mad_stream,
                arg3: *mut mad_frame,
            ) -> mad_flow,
        >,
        arg8: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *mut ::libc::c_void,
                arg3: *mut u32_,
            ) -> mad_flow,
        >,
    );
}
extern "C" {
    pub fn mad_decoder_finish(arg1: *mut mad_decoder) -> s32;
}
extern "C" {
    pub fn mad_decoder_run(arg1: *mut mad_decoder, arg2: mad_decoder_mode) -> s32;
}
extern "C" {
    pub fn mad_decoder_message(
        arg1: *mut mad_decoder,
        arg2: *mut ::libc::c_void,
        arg3: *mut u32_,
    ) -> s32;
}
extern "C" {
    pub fn MP3Player_Init();
}
extern "C" {
    pub fn MP3Player_Stop();
}
extern "C" {
    pub fn MP3Player_IsPlaying() -> bool;
}
extern "C" {
    pub fn MP3Player_Volume(volume: u32_);
}
extern "C" {
    pub fn MP3Player_PlayBuffer(
        buffer: *const ::libc::c_void,
        len: s32,
        filterfunc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut mad_stream, arg2: *mut mad_frame),
        >,
    ) -> s32;
}
extern "C" {
    pub fn MP3Player_PlayFile(
        cb_data: *mut ::libc::c_void,
        reader: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *mut ::libc::c_void,
                arg3: s32,
            ) -> s32,
        >,
        filterfunc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut mad_stream, arg2: *mut mad_frame),
        >,
    ) -> s32;
}
pub const WIIUSE_IR_ABOVE: ir_position_t = 0;
pub const WIIUSE_IR_BELOW: ir_position_t = 1;
pub type ir_position_t = ::libc::c_uint;
pub type ubyte = ::libc::c_uchar;
pub type sbyte = ::libc::c_char;
pub type uword = ::libc::c_ushort;
pub type sword = ::libc::c_short;
pub type sint = ::libc::c_char;
#[doc = "Callback that handles a read event.\n\n # Arguments\n\n* `wm` - Pointer to a wiimote_t structure.\n * `data` - Pointer to the filled data block.\n * `len` - Length in bytes of the data block.\n\n [`wiiuse_init()`]\n\n A registered function of this type is called automatically by the wiiuse\n library when the wiimote has returned the full data requested by a previous\n call to wiiuse_read_data()."]
pub type wiiuse_data_cb = ::core::option::Option<
    unsafe extern "C" fn(wm: *mut wiimote_t, data: *mut ubyte, len: ::libc::c_ushort),
>;
pub const REQ_READY: data_req_s = 0;
pub const REQ_SENT: data_req_s = 1;
pub const REQ_DONE: data_req_s = 2;
pub type data_req_s = ::libc::c_uint;
#[doc = "\tdata_req_t\n\tData read request structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct data_req_t {
    pub node: lwp_node,
    #[doc = "< buffer where read data is written"]
    pub data: [ubyte; 48usize],
    pub len: ::libc::c_uint,
    #[doc = "< set to 1 if not using callback and needs to be cleaned up"]
    pub state: data_req_s,
    #[doc = "< read data callback"]
    pub cb: wiiuse_data_cb,
    pub next: *mut data_req_t,
}
pub type cmd_blk_cb =
    ::core::option::Option<unsafe extern "C" fn(wm: *mut wiimote_t, data: *mut ubyte, len: uword)>;
pub const CMD_READY: cmd_blk_s = 0;
pub const CMD_SENT: cmd_blk_s = 1;
pub const CMD_DONE: cmd_blk_s = 2;
pub type cmd_blk_s = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_blk_t {
    pub node: lwp_node,
    pub data: [ubyte; 48usize],
    pub len: uint,
    pub state: cmd_blk_s,
    pub cb: cmd_blk_cb,
    pub next: *mut cmd_blk_t,
}
#[doc = "\tvec2b_t\n\tUnsigned x,y byte vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec2b_t {
    pub x: ubyte,
    pub y: ubyte,
}
#[doc = "\tvec3b_t\n\tUnsigned x,y,z byte vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec3b_t {
    pub x: ubyte,
    pub y: ubyte,
    pub z: ubyte,
}
#[doc = "\tvec3b_t\n\tUnsigned x,y,z byte vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec3w_t {
    pub x: uword,
    pub y: uword,
    pub z: uword,
}
#[doc = "\tvec3f_t\n\tSigned x,y,z float struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec3f_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[doc = "\torient_t\n\tOrientation struct.\n\n\tYaw, pitch, and roll range from -180 to 180 degrees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct orient_t {
    #[doc = "< roll, this may be smoothed if enabled"]
    pub roll: f32,
    #[doc = "< pitch, this may be smoothed if enabled"]
    pub pitch: f32,
    pub yaw: f32,
    #[doc = "< absolute roll, unsmoothed"]
    pub a_roll: f32,
    #[doc = "< absolute pitch, unsmoothed"]
    pub a_pitch: f32,
}
#[doc = "\tgforce_t\n\tGravity force struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gforce_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[doc = "\taccel_t\n\tAccelerometer struct. For any device with an accelerometer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accel_t {
    #[doc = "< zero calibration"]
    pub cal_zero: vec3w_t,
    #[doc = "< 1g difference around 0cal"]
    pub cal_g: vec3w_t,
    #[doc = "< last smoothed roll value"]
    pub st_roll: f32,
    #[doc = "< last smoothed roll pitch"]
    pub st_pitch: f32,
    #[doc = "< alpha value for smoothing [0-1]"]
    pub st_alpha: f32,
}
#[doc = "\tir_dot_t\n\tA single IR source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_dot_t {
    #[doc = "< if the IR source is visible"]
    pub visible: ubyte,
    #[doc = "< raw X coordinate (0-1023)"]
    pub rx: ::libc::c_short,
    #[doc = "< raw Y coordinate (0-767)"]
    pub ry: ::libc::c_short,
    #[doc = "< size of the IR dot (0-15)"]
    pub size: ubyte,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdot_t {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sb_t {
    pub dots: [fdot_t; 2usize],
    pub acc_dots: [fdot_t; 2usize],
    pub rot_dots: [fdot_t; 2usize],
    pub angle: f32,
    pub off_angle: f32,
    pub score: f32,
}
pub const WIIUSE_ASPECT_4_3: aspect_t = 0;
pub const WIIUSE_ASPECT_16_9: aspect_t = 1;
#[doc = "\t\n\tScreen aspect ratio."]
pub type aspect_t = ::libc::c_uint;
#[doc = "\tir_t\n\tIR struct. Hold all data related to the IR tracking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_t {
    #[doc = "< IR dots"]
    pub dot: [ir_dot_t; 4usize],
    #[doc = "< number of dots at this time"]
    pub num_dots: ubyte,
    #[doc = "< keeps track of the IR state"]
    pub state: ::libc::c_int,
    #[doc = "< is the raw position valid?"]
    pub raw_valid: ::libc::c_int,
    #[doc = "< sensor bar, detected or guessed"]
    pub sensorbar: sb_t,
    #[doc = "< raw X coordinate"]
    pub ax: f32,
    #[doc = "< raw Y coordinate"]
    pub ay: f32,
    #[doc = "< pixel width of the sensor bar"]
    pub distance: f32,
    #[doc = "< calculated distance in meters"]
    pub z: f32,
    #[doc = "< angle of the wiimote to the sensor bar"]
    pub angle: f32,
    #[doc = "< is the smoothed position valid?"]
    pub smooth_valid: ::libc::c_int,
    #[doc = "< smoothed X coordinate"]
    pub sx: f32,
    #[doc = "< smoothed Y coordinate"]
    pub sy: f32,
    #[doc = "< error count, for smoothing algorithm"]
    pub error_cnt: f32,
    #[doc = "< glitch count, same"]
    pub glitch_cnt: f32,
    #[doc = "< is the bounded position valid?"]
    pub valid: ::libc::c_int,
    #[doc = "< bounded X coordinate"]
    pub x: f32,
    #[doc = "< bounded Y coordinate"]
    pub y: f32,
    #[doc = "< aspect ratio of the screen"]
    pub aspect: aspect_t,
    #[doc = "< IR sensor bar position"]
    pub pos: ir_position_t,
    #[doc = "< IR virtual screen resolution"]
    pub vres: [::libc::c_uint; 2usize],
    #[doc = "< IR XY correction offset"]
    pub offset: [::libc::c_int; 2usize],
}
#[doc = "\tjoystick_t\n\tJoystick calibration structure.\n\n\tThe angle _ang_ is relative to the positive y-axis into quadrant I\n\tand ranges from 0 to 360 degrees. So if the joystick is held straight\n\tupwards then angle is 0 degrees. If it is held to the right it is 90,\n\tdown is 180, and left is 270.\n\n\tThe magnitude _mag_ is the distance from the center to where the\n\tjoystick is being held. The magnitude ranges from 0 to 1.\n\tIf the joystick is only slightly tilted from the center the magnitude\n\twill be low, but if it is closer to the outter edge the value will\n\tbe higher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct joystick_t {
    #[doc = "< maximum joystick values"]
    pub max: vec2b_t,
    #[doc = "< minimum joystick values"]
    pub min: vec2b_t,
    #[doc = "< center joystick values"]
    pub center: vec2b_t,
    #[doc = "< raw position values"]
    pub pos: vec2b_t,
    #[doc = "< angle the joystick is being held"]
    pub ang: f32,
    #[doc = "< magnitude of the joystick (range 0-1)"]
    pub mag: f32,
}
#[doc = "\tnunchuk_t\n\tNunchuk expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nunchuk_t {
    #[doc = "< nunchuk accelerometer calibration"]
    pub accel_calib: accel_t,
    #[doc = "< joystick calibration"]
    pub js: joystick_t,
    #[doc = "< options flag (points to wiimote_t.flags)"]
    pub flags: *mut ::libc::c_int,
    #[doc = "< what buttons have just been pressed"]
    pub btns: ubyte,
    #[doc = "< what buttons have just been pressed"]
    pub btns_last: ubyte,
    #[doc = "< what buttons are being held down"]
    pub btns_held: ubyte,
    #[doc = "< what buttons were just released this"]
    pub btns_released: ubyte,
    #[doc = "< current raw acceleration data"]
    pub accel: vec3w_t,
    #[doc = "< current orientation on each axis"]
    pub orient: orient_t,
    #[doc = "< current gravity forces on each axis"]
    pub gforce: gforce_t,
}
#[doc = "\tclassic_ctrl_t\n\tClassic controller expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct classic_ctrl_t {
    #[doc = "< what buttons have just been pressed"]
    pub btns: ::libc::c_short,
    #[doc = "< what buttons have just been pressed"]
    pub btns_last: ::libc::c_short,
    #[doc = "< what buttons are being held down"]
    pub btns_held: ::libc::c_short,
    #[doc = "< what buttons were just released this"]
    pub btns_released: ::libc::c_short,
    pub rs_raw: ubyte,
    pub ls_raw: ubyte,
    #[doc = "< right shoulder button (range 0-1)"]
    pub r_shoulder: f32,
    #[doc = "< left shoulder button (range 0-1)"]
    pub l_shoulder: f32,
    #[doc = "< left joystick calibration"]
    pub ljs: joystick_t,
    #[doc = "< right joystick calibration"]
    pub rjs: joystick_t,
    #[doc = "< original, pro, wiiu pro"]
    pub type_: ubyte,
}
#[doc = "\tguitar_hero_3_t\n\tGuitar Hero 3 expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct guitar_hero_3_t {
    #[doc = "< what buttons have just been pressed"]
    pub btns: ::libc::c_short,
    #[doc = "< what buttons have just been pressed"]
    pub btns_last: ::libc::c_short,
    #[doc = "< what buttons are being held down"]
    pub btns_held: ::libc::c_short,
    #[doc = "< what buttons were just released this"]
    pub btns_released: ::libc::c_short,
    pub wb_raw: ubyte,
    #[doc = "< whammy bar (range 0-1)"]
    pub whammy_bar: f32,
    pub tb_raw: ubyte,
    #[doc = "< touch bar"]
    pub touch_bar: ::libc::c_int,
    #[doc = "< joystick calibration"]
    pub js: joystick_t,
}
#[doc = "wii_board_t\n Wii Balance Board expansion device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wii_board_t {
    pub tl: f32,
    pub tr: f32,
    pub bl: f32,
    pub br: f32,
    pub rtl: ::libc::c_short,
    pub rtr: ::libc::c_short,
    pub rbl: ::libc::c_short,
    pub rbr: ::libc::c_short,
    pub ctl: [::libc::c_short; 3usize],
    pub ctr: [::libc::c_short; 3usize],
    pub cbl: [::libc::c_short; 3usize],
    pub cbr: [::libc::c_short; 3usize],
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct motion_plus_t {
    pub rx: ::libc::c_short,
    pub ry: ::libc::c_short,
    pub rz: ::libc::c_short,
    pub status: ubyte,
    pub ext: ubyte,
}
#[doc = "\texpansion_t\n\tGeneric expansion device plugged into wiimote."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expansion_t {
    #[doc = "< type of expansion attached"]
    pub type_: ::libc::c_int,
    pub __bindgen_anon_1: expansion_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expansion_t__bindgen_ty_1 {
    pub nunchuk: __BindgenUnionField<nunchuk_t>,
    pub classic: __BindgenUnionField<classic_ctrl_t>,
    pub gh3: __BindgenUnionField<guitar_hero_3_t>,
    pub wb: __BindgenUnionField<wii_board_t>,
    pub mp: __BindgenUnionField<motion_plus_t>,
    pub bindgen_union_field: [u32; 22usize],
}
pub const WIIUSE_STACK_UNKNOWN: win_bt_stack_t = 0;
pub const WIIUSE_STACK_MS: win_bt_stack_t = 1;
pub const WIIUSE_STACK_BLUESOLEIL: win_bt_stack_t = 2;
#[doc = "\t\n\tbluetooth stacks for Windows."]
pub type win_bt_stack_t = ::libc::c_uint;
#[doc = "\twiimote_state_t\n\tSignificant data from the previous event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiimote_state_t {
    pub btns: ::libc::c_ushort,
    pub ir: ir_t,
    pub accel: vec3w_t,
    pub exp: expansion_t,
}
pub const WIIUSE_NONE: WIIUSE_EVENT_TYPE = 0;
pub const WIIUSE_EVENT: WIIUSE_EVENT_TYPE = 1;
pub const WIIUSE_STATUS: WIIUSE_EVENT_TYPE = 2;
pub const WIIUSE_CONNECT: WIIUSE_EVENT_TYPE = 3;
pub const WIIUSE_DISCONNECT: WIIUSE_EVENT_TYPE = 4;
pub const WIIUSE_UNEXPECTED_DISCONNECT: WIIUSE_EVENT_TYPE = 5;
pub const WIIUSE_READ_DATA: WIIUSE_EVENT_TYPE = 6;
pub const WIIUSE_ACK: WIIUSE_EVENT_TYPE = 7;
pub const WIIUSE_NUNCHUK_INSERTED: WIIUSE_EVENT_TYPE = 8;
pub const WIIUSE_NUNCHUK_REMOVED: WIIUSE_EVENT_TYPE = 9;
pub const WIIUSE_CLASSIC_CTRL_INSERTED: WIIUSE_EVENT_TYPE = 10;
pub const WIIUSE_CLASSIC_CTRL_REMOVED: WIIUSE_EVENT_TYPE = 11;
pub const WIIUSE_GUITAR_HERO_3_CTRL_INSERTED: WIIUSE_EVENT_TYPE = 12;
pub const WIIUSE_GUITAR_HERO_3_CTRL_REMOVED: WIIUSE_EVENT_TYPE = 13;
pub const WIIUSE_WII_BOARD_INSERTED: WIIUSE_EVENT_TYPE = 14;
pub const WIIUSE_WII_BOARD_REMOVED: WIIUSE_EVENT_TYPE = 15;
pub const WIIUSE_MOTION_PLUS_ACTIVATED: WIIUSE_EVENT_TYPE = 16;
pub const WIIUSE_MOTION_PLUS_REMOVED: WIIUSE_EVENT_TYPE = 17;
#[doc = "\t\n\tEvents that wiiuse can generate from a poll."]
pub type WIIUSE_EVENT_TYPE = ::libc::c_uint;
#[doc = "\twiimote_t\n\tWiimote structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiimote_t {
    #[doc = "< user specified id"]
    pub unid: ::libc::c_int,
    #[doc = "< various state flags"]
    pub state: ::libc::c_int,
    #[doc = "< currently lit leds"]
    pub leds: ubyte,
    #[doc = "< battery level"]
    pub battery_level: f32,
    #[doc = "< options flag"]
    pub flags: ::libc::c_int,
    #[doc = "< the state of the connection handshake"]
    pub handshake_state: ubyte,
    #[doc = "< the state of the expansion handshake"]
    pub expansion_state: ubyte,
    #[doc = "< list of data read requests"]
    pub data_req: *const data_req_t,
    pub cmd_head: *const cmd_blk_t,
    pub cmd_tail: *const cmd_blk_t,
    #[doc = "< wiimote accelerometer calibration"]
    pub accel_calib: accel_t,
    #[doc = "< wiimote expansion device"]
    pub exp: expansion_t,
    #[doc = "< current raw acceleration data"]
    pub accel: vec3w_t,
    #[doc = "< current orientation on each axis"]
    pub orient: orient_t,
    #[doc = "< current gravity forces on each axis"]
    pub gforce: gforce_t,
    #[doc = "< IR data"]
    pub ir: ir_t,
    #[doc = "< what buttons are down"]
    pub btns: ::libc::c_ushort,
    #[doc = "< what buttons were down before"]
    pub btns_last: ::libc::c_ushort,
    #[doc = "< what buttons are and were held down"]
    pub btns_held: ::libc::c_ushort,
    #[doc = "< what buttons were just released"]
    pub btns_released: ::libc::c_ushort,
    #[doc = "< last saved state"]
    pub lstate: wiimote_state_t,
    #[doc = "< type of event that occured"]
    pub event: WIIUSE_EVENT_TYPE,
    #[doc = "< event buffer"]
    pub event_buf: [ubyte; 32usize],
    pub motion_plus_id: [ubyte; 6usize],
}
#[doc = "\twiimote_t\n\tWiimote structure."]
pub type wiimote = wiimote_t;
extern "C" {
    pub fn wiiuse_version() -> *const ::libc::c_char;
}
extern "C" {
    pub fn wiiuse_init(wiimotes: ::libc::c_int) -> *mut *mut wiimote_t;
}
extern "C" {
    pub fn wiiuse_disconnected(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_cleanup(wm: *mut *mut wiimote_t, wiimotes: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_rumble(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_toggle_rumble(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_set_leds(wm: *mut wiimote_t, leds: ::libc::c_int, cb: cmd_blk_cb);
}
extern "C" {
    pub fn wiiuse_motion_sensing(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_read_data(
        wm: *mut wiimote_t,
        buffer: *mut ubyte,
        offset: ::libc::c_uint,
        len: ::libc::c_ushort,
        cb: cmd_blk_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_write_data(
        wm: *mut wiimote_t,
        addr: ::libc::c_uint,
        data: *mut ubyte,
        len: ubyte,
        cb: cmd_blk_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_status(wm: *mut wiimote_t, cb: cmd_blk_cb);
}
extern "C" {
    pub fn wiiuse_get_by_id(
        wm: *mut *mut wiimote_t,
        wiimotes: ::libc::c_int,
        unid: ::libc::c_int,
    ) -> *mut wiimote_t;
}
extern "C" {
    pub fn wiiuse_set_flags(
        wm: *mut wiimote_t,
        enable: ::libc::c_int,
        disable: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_set_smooth_alpha(wm: *mut wiimote_t, alpha: f32) -> f32;
}
extern "C" {
    pub fn wiiuse_set_bluetooth_stack(
        wm: *mut *mut wiimote_t,
        wiimotes: ::libc::c_int,
        type_: win_bt_stack_t,
    );
}
extern "C" {
    pub fn wiiuse_resync(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_set_timeout(
        wm: *mut *mut wiimote_t,
        wiimotes: ::libc::c_int,
        normal_timeout: ubyte,
        exp_timeout: ubyte,
    );
}
extern "C" {
    pub fn wiiuse_write_streamdata(
        wm: *mut wiimote_t,
        data: *mut ubyte,
        len: ubyte,
        cb: cmd_blk_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_find(
        wm: *mut *mut wiimote_t,
        max_wiimotes: ::libc::c_int,
        timeout: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_connect(wm: *mut *mut wiimote_t, wiimotes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_disconnect(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_poll(wm: *mut *mut wiimote_t, wiimotes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn wiiuse_set_ir_mode(wm: *mut wiimote_t);
}
extern "C" {
    pub fn wiiuse_set_ir(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_set_ir_vres(wm: *mut wiimote_t, x: ::libc::c_uint, y: ::libc::c_uint);
}
extern "C" {
    pub fn wiiuse_set_ir_position(wm: *mut wiimote_t, pos: ir_position_t);
}
extern "C" {
    pub fn wiiuse_set_aspect_ratio(wm: *mut wiimote_t, aspect: aspect_t);
}
extern "C" {
    pub fn wiiuse_set_ir_sensitivity(wm: *mut wiimote_t, level: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_set_motion_plus(wm: *mut wiimote_t, status: ::libc::c_int);
}
extern "C" {
    pub fn wiiuse_set_speaker(wm: *mut wiimote_t, status: ::libc::c_int);
}
pub const WPAD_CHAN_ALL: _bindgen_ty_20 = -1;
pub const WPAD_CHAN_0: _bindgen_ty_20 = 0;
pub const WPAD_CHAN_1: _bindgen_ty_20 = 1;
pub const WPAD_CHAN_2: _bindgen_ty_20 = 2;
pub const WPAD_CHAN_3: _bindgen_ty_20 = 3;
pub const WPAD_BALANCE_BOARD: _bindgen_ty_20 = 4;
pub const WPAD_MAX_WIIMOTES: _bindgen_ty_20 = 5;
pub type _bindgen_ty_20 = ::libc::c_int;
pub const WPAD_EXP_NONE: _bindgen_ty_21 = 0;
pub const WPAD_EXP_NUNCHUK: _bindgen_ty_21 = 1;
pub const WPAD_EXP_CLASSIC: _bindgen_ty_21 = 2;
pub const WPAD_EXP_GUITARHERO3: _bindgen_ty_21 = 3;
pub const WPAD_EXP_WIIBOARD: _bindgen_ty_21 = 4;
pub const WPAD_EXP_UNKNOWN: _bindgen_ty_21 = 255;
pub type _bindgen_ty_21 = ::libc::c_uint;
pub const WPAD_FMT_BTNS: _bindgen_ty_22 = 0;
pub const WPAD_FMT_BTNS_ACC: _bindgen_ty_22 = 1;
pub const WPAD_FMT_BTNS_ACC_IR: _bindgen_ty_22 = 2;
pub type _bindgen_ty_22 = ::libc::c_uint;
pub const WPAD_STATE_DISABLED: _bindgen_ty_23 = 0;
pub const WPAD_STATE_ENABLING: _bindgen_ty_23 = 1;
pub const WPAD_STATE_ENABLED: _bindgen_ty_23 = 2;
pub type _bindgen_ty_23 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wpad_data {
    pub err: s16,
    pub data_present: u32_,
    pub battery_level: u8_,
    pub btns_h: u32_,
    pub btns_l: u32_,
    pub btns_d: u32_,
    pub btns_u: u32_,
    pub ir: ir_t,
    pub accel: vec3w_t,
    pub orient: orient_t,
    pub gforce: gforce_t,
    pub exp: expansion_t,
}
pub type WPADData = _wpad_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wpad_encstatus {
    pub data: [u8_; 32usize],
}
pub type WPADEncStatus = _wpad_encstatus;
pub type WPADDataCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: s32, data: *const WPADData)>;
pub type WPADShutdownCallback = ::core::option::Option<unsafe extern "C" fn(chan: s32)>;
extern "C" {
    pub fn WPAD_Init() -> s32;
}
extern "C" {
    pub fn WPAD_ControlSpeaker(chan: s32, enable: s32) -> s32;
}
extern "C" {
    pub fn WPAD_ReadEvent(chan: s32, data: *mut WPADData) -> s32;
}
extern "C" {
    pub fn WPAD_DroppedEvents(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_Flush(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_ReadPending(chan: s32, datacb: WPADDataCallback) -> s32;
}
extern "C" {
    pub fn WPAD_SetDataFormat(chan: s32, fmt: s32) -> s32;
}
extern "C" {
    pub fn WPAD_SetMotionPlus(chan: s32, enable: u8_) -> s32;
}
extern "C" {
    pub fn WPAD_SetVRes(chan: s32, xres: u32_, yres: u32_) -> s32;
}
extern "C" {
    pub fn WPAD_GetStatus() -> s32;
}
extern "C" {
    pub fn WPAD_Probe(chan: s32, type_: *mut u32_) -> s32;
}
extern "C" {
    pub fn WPAD_SetEventBufs(chan: s32, bufs: *mut WPADData, cnt: u32_) -> s32;
}
extern "C" {
    pub fn WPAD_Disconnect(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_IsSpeakerEnabled(chan: s32) -> s32;
}
extern "C" {
    pub fn WPAD_SendStreamData(chan: s32, buf: *mut ::libc::c_void, len: u32_) -> s32;
}
extern "C" {
    pub fn WPAD_Shutdown();
}
extern "C" {
    pub fn WPAD_SetIdleTimeout(seconds: u32_);
}
extern "C" {
    pub fn WPAD_SetPowerButtonCallback(cb: WPADShutdownCallback);
}
extern "C" {
    pub fn WPAD_SetBatteryDeadCallback(cb: WPADShutdownCallback);
}
extern "C" {
    pub fn WPAD_ScanPads() -> s32;
}
extern "C" {
    pub fn WPAD_Rumble(chan: s32, status: ::libc::c_int) -> s32;
}
extern "C" {
    pub fn WPAD_SetIdleThresholds(
        chan: s32,
        btns: s32,
        ir: s32,
        accel: s32,
        js: s32,
        wb: s32,
        mp: s32,
    ) -> s32;
}
extern "C" {
    pub fn WPAD_EncodeData(
        info: *mut WPADEncStatus,
        flag: u32_,
        pcmSamples: *const s16,
        numSamples: s32,
        encData: *mut u8_,
    );
}
extern "C" {
    pub fn WPAD_Data(chan: ::libc::c_int) -> *mut WPADData;
}
extern "C" {
    pub fn WPAD_BatteryLevel(chan: ::libc::c_int) -> u8_;
}
extern "C" {
    pub fn WPAD_ButtonsUp(chan: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn WPAD_ButtonsDown(chan: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn WPAD_ButtonsHeld(chan: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn WPAD_IR(chan: ::libc::c_int, ir: *mut ir_t);
}
extern "C" {
    pub fn WPAD_Orientation(chan: ::libc::c_int, orient: *mut orient_t);
}
extern "C" {
    pub fn WPAD_GForce(chan: ::libc::c_int, gforce: *mut gforce_t);
}
extern "C" {
    pub fn WPAD_Accel(chan: ::libc::c_int, accel: *mut vec3w_t);
}
extern "C" {
    pub fn WPAD_Expansion(chan: ::libc::c_int, exp: *mut expansion_t);
}
pub type __builtin_va_list = [[u32; 3usize]; 1usize];
